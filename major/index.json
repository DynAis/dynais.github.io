[{"content":"受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了\nOrcad Pspice版本: 9.1 Student\n概述  受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了\nOrcad Pspice版本: 9.1 Student\n文档进入方法:\nWin10还要上网找一下win32hlp.exe装一下才能看, 下载: win32hlp.exe\n路径:\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png 50% 50% \u0026quot; \u0026quot; %}\n 语法  search\t[direction]\t[/start_point/]\t[#consecutive_points#]\t[(range_x [,range_y])]\t[for]\t[repeat:]\t\u0026lt;condition\u0026gt;\n能把搜索语法写这么麻烦我真的服\n 常用范例  其实语法不需要打全称, 是接收缩写的, 但是文档里一点没说\n常用的是:\n   example describtion     sf xv (这里是数字) 向前找到下一个X坐标最符合当前用户输入数字的点   sf le (这里是数字) 向前找到下一个Y坐标最符合当前用户输入数字的点    sf 是 SerchForword 的缩写, xv 是 XValue 的缩写, le 是 LEvel 的缩写\n更加具体的可以在语法里的 \u0026lt;condition\u0026gt; 下找到\n","permalink":"https://dynais.github.io/major/posts/pspice-probe%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84cursor%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/","summary":"受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了\nOrcad Pspice版本: 9.1 Student\n概述  受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了\nOrcad Pspice版本: 9.1 Student\n文档进入方法:\nWin10还要上网找一下win32hlp.exe装一下才能看, 下载: win32hlp.exe\n路径:\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png 50% 50% \u0026quot; \u0026quot; %}\n 语法  search\t[direction]\t[/start_point/]\t[#consecutive_points#]\t[(range_x [,range_y])]\t[for]\t[repeat:]\t\u0026lt;condition\u0026gt;\n能把搜索语法写这么麻烦我真的服\n 常用范例  其实语法不需要打全称, 是接收缩写的, 但是文档里一点没说","title":"PSpice中常用的Cursor查询命令"},{"content":"基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析\n概述  基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析\n流程  在 PSpice 得到模拟数据后, 选中需要导出的曲线\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png 50% 50% \u0026quot; \u0026quot; %}\n看到它变红了\n然后直接 Ctrl + C 就可以获得曲线数据\n然后新建一个文本文档, 复制粘贴保存成 .csv 文件\n直接导入 Excel 应该也是可行的, 但是由于改成了德国的计数方法, 这里的逗号和小数点会有问题, 先导入 csv 文件的话就没问题, 所以还是建议保存到 csv, 这样 Matlab 什么的也能用\n","permalink":"https://dynais.github.io/major/posts/pspice%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5excel%E5%B7%A5%E4%BD%9C%E6%B5%81/","summary":"基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析\n概述  基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析\n流程  在 PSpice 得到模拟数据后, 选中需要导出的曲线\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png 50% 50% \u0026quot; \u0026quot; %}\n看到它变红了\n然后直接 Ctrl + C 就可以获得曲线数据\n然后新建一个文本文档, 复制粘贴保存成 .csv 文件\n直接导入 Excel 应该也是可行的, 但是由于改成了德国的计数方法, 这里的逗号和小数点会有问题, 先导入 csv 文件的话就没问题, 所以还是建议保存到 csv, 这样 Matlab 什么的也能用","title":"PSpice模拟数据导入Excel工作流"},{"content":"小车已经全部搭好了，虽然不确定硬件是否哪里还有些问题，但是好歹摄像头和图像处理模块是已经可以正常使用没有问题的。\n已经写好的二值化算法已经够用了，但是仍然存在不可以过滤背景中无效信息的问题，多多少少会给之后的计算带来麻烦，于是写了一个提取图像主要信息的算法。\n前言：\n小车已经全部搭好了，虽然不确定硬件是否哪里还有些问题，但是好歹摄像头和图像处理模块是已经可以正常使用没有问题的。\n已经写好的二值化算法已经够用了，但是仍然存在不可以过滤背景中无效信息的问题，多多少少会给之后的计算带来麻烦，于是写了一个提取图像主要信息的算法。\n 利用泛洪填充（Flood Fill）的优化方式完成对特定图像的主要信息的提取 完成目标： 处理前\n[图像已丢失]\n处理后\n[图像已丢失]\n可以观察到，背景中多余的信息被算法过滤掉了。\n思路 这种算法大概的思路相当于画图软件中的油漆桶，选取一个目标点并使用DFS来选出区域内所有和他连通并且颜色相同的像素点，这样根据智能车行驶路径的特点可知捕捉到的画面下方正中间的位置必然是属于白色的，借此就可以只选出当前赛道的图像，并同时纪录下左右边线。\n问题与解决方案 1.内存占用过大 首先遇到的问题就是，如果使用原始的算法，只要图像稍微很大，就需要一个非常大的数组来进行信息的储存。甚至在使用PC进行模拟的时候，都因为内存过大而产生溢出了，所以说如此大的内存消耗对LPC来说是不可接受的。\n解\n简单思路是把原来的对像素堆栈改为了对扫描线种子点的堆栈，大大减小了内存的消耗，具体的算法在参考文献中列出。\n2.数据类型使用错误/不匹配 转移算法的时候出现好几处警告，提示数据类型与逻辑判断可能出现问题，比如 uint8 和 0 比大小，这个运算的结果一定是 uint8 大于 0 的，当 uint类型 “小于” 0 时，他会变为一个很大的数字。并且 uint 与传统 int 进行数学运算的时候也一定要小心，最好避免这种情况，提前转化为相同类型数据再运算。\n 参考文献:\n","permalink":"https://dynais.github.io/major/posts/%E4%BD%BF%E7%94%A8%E6%B3%9B%E6%B4%AA%E5%A1%AB%E5%85%85%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E5%AF%B9%E7%89%B9%E5%AE%9A%E5%9B%BE%E5%83%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%90%E5%8F%96/","summary":"小车已经全部搭好了，虽然不确定硬件是否哪里还有些问题，但是好歹摄像头和图像处理模块是已经可以正常使用没有问题的。\n已经写好的二值化算法已经够用了，但是仍然存在不可以过滤背景中无效信息的问题，多多少少会给之后的计算带来麻烦，于是写了一个提取图像主要信息的算法。\n前言：\n小车已经全部搭好了，虽然不确定硬件是否哪里还有些问题，但是好歹摄像头和图像处理模块是已经可以正常使用没有问题的。\n已经写好的二值化算法已经够用了，但是仍然存在不可以过滤背景中无效信息的问题，多多少少会给之后的计算带来麻烦，于是写了一个提取图像主要信息的算法。\n 利用泛洪填充（Flood Fill）的优化方式完成对特定图像的主要信息的提取 完成目标： 处理前\n[图像已丢失]\n处理后\n[图像已丢失]\n可以观察到，背景中多余的信息被算法过滤掉了。\n思路 这种算法大概的思路相当于画图软件中的油漆桶，选取一个目标点并使用DFS来选出区域内所有和他连通并且颜色相同的像素点，这样根据智能车行驶路径的特点可知捕捉到的画面下方正中间的位置必然是属于白色的，借此就可以只选出当前赛道的图像，并同时纪录下左右边线。\n问题与解决方案 1.内存占用过大 首先遇到的问题就是，如果使用原始的算法，只要图像稍微很大，就需要一个非常大的数组来进行信息的储存。甚至在使用PC进行模拟的时候，都因为内存过大而产生溢出了，所以说如此大的内存消耗对LPC来说是不可接受的。\n解\n简单思路是把原来的对像素堆栈改为了对扫描线种子点的堆栈，大大减小了内存的消耗，具体的算法在参考文献中列出。\n2.数据类型使用错误/不匹配 转移算法的时候出现好几处警告，提示数据类型与逻辑判断可能出现问题，比如 uint8 和 0 比大小，这个运算的结果一定是 uint8 大于 0 的，当 uint类型 “小于” 0 时，他会变为一个很大的数字。并且 uint 与传统 int 进行数学运算的时候也一定要小心，最好避免这种情况，提前转化为相同类型数据再运算。\n 参考文献:","title":"利用泛洪填充（Flood Fill）的优化方式完成对特定图像的主要信息的提取"},{"content":"遇到的问题   OLED无法点亮 困扰了很久的问题，最后发现是硬件上出了毛病，使用飞线或者杜邦线会导致连接不稳定\n  OLED屏幕显示闪烁 可能是因为屏幕刷新不够快，尝试保持一个高刷新率即可\n  OLED屏幕数字重叠 使用uint16时调用现有函数显示数字会有5位的空位（0占位）在设定的坐标之前，注意防止显示内容重叠\n  中断计时时间不准确（很慢） 原因是在中断中加入了函数\nmrt_clean(MRT_CH0); 本来是我认为防止数据溢出而使用的，最后发现会使每次中断的速度大大降低，导致计时不准确，并且去掉这个函数数据好像也不会溢出\u0026hellip;\n   工程目标  了解MRT的使用方法 了解OLED的工作协议和引脚定义 了解IIC的工作原理 结合MET和OLED制作计时器 使用按钮控制调节计时器的几个工作状态  问题解决思路 查阅底层函数了解使用方法，结合OLED的数据手册了解OLED的使用方法，查阅IIC的时序，通过一步步调试减少错误，也便于即时修改。\n待解决问题  如何初始化，打开，调用和关闭MRT IIC协议如何工作 如何开启MRT的计时中断操作 OLED的数据引脚如何发送命令 如何把MRT的反馈显示到OLED上 如何通过按钮控制计时器状态  实行（可能）流程  通过底层函数观察如何使用MRT 通过网上资料或数据手册了解IIC如何工作 通过底层函数观察如何使用OLED 通过简单的程序让OLED显示字符 编写计时函数 编写按钮函数 封装程序   Lösungen   如何操作MRT\n/********************************************************************************************************************* * COPYRIGHT NOTICE * Copyright (c) 2018,逐飞科技 * All rights reserved. * 技术讨论QQ群：179029047 * * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途， * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。 * * @file MRT(多速率定时器) * @company\t成都逐飞科技有限公司 * @author 逐飞科技(QQ3184284598) * @version 查看LPC546XX_config.h文件内版本宏定义 * @Software IAR 7.8 or MDK 5.24a * @Target core\tLPC54606J512BD100 * @Taobao https://seekfree.taobao.com/ * @date 2018-11-21 ********************************************************************************************************************/ #include \u0026#34;LPC546XX_mrt.h\u0026#34; //------------------------------------------------------------------------------------------------------------------- // @brief MRT周期中断模式初始化 // @param mrtchx MRT通道号 // @param time 周期中断时间 // @return void // Sample usage: mrt_pit_init(MRT_CH0,1000); //无需用户调用 请使用H文件内的宏定义 //------------------------------------------------------------------------------------------------------------------- void mrt_pit_init(MRTNUM_enum mrtchx, uint32 time) { SYSCON-\u0026gt;AHBCLKCTRLSET[1] = SYSCON_AHBCLKCTRL_MRT_MASK; //打开MRT时钟  SYSCON-\u0026gt;PRESETCTRLCLR[1] = SYSCON_PRESETCTRL_MRT_RST_MASK; //清除MRT复位时钟  ASSERT(time \u0026lt;= MRT_CHANNEL_TIMER_VALUE_MASK);//断言  MRT0-\u0026gt;CHANNEL[mrtchx].CTRL = MRT_CHANNEL_CTRL_INTEN_MASK | MRT_CHANNEL_CTRL_MODE(0);//PIT模式 打开中断  MRT0-\u0026gt;CHANNEL[mrtchx].INTVAL = time; //设置间隔时间 定时器停止后载入时间 并启动定时器  enable_irq(MRT0_IRQn); //开启RIT中断  //set_irq_priority(MRT0_IRQn,0);//设置优先级 越低优先级越高 } //------------------------------------------------------------------------------------------------------------------- // @brief MRT延时函数 // @param mrtchx MRT通道号 // @param time 周期中断时间 // @return void // Sample usage: mrt_delay(MRT_CH0,1000); //无需用户调用 请使用H文件内的宏定义 //------------------------------------------------------------------------------------------------------------------- void mrt_delay(MRTNUM_enum mrtchx, uint32 time) { SYSCON-\u0026gt;AHBCLKCTRLSET[1] = SYSCON_AHBCLKCTRL_MRT_MASK; //打开MRT时钟  SYSCON-\u0026gt;PRESETCTRLCLR[1] = SYSCON_PRESETCTRL_MRT_RST_MASK; //清除MRT复位时钟  ASSERT(time \u0026lt;= MRT_CHANNEL_TIMER_VALUE_MASK);//断言  MRT0-\u0026gt;CHANNEL[mrtchx].CTRL = MRT_CHANNEL_CTRL_MODE(1); //一次中断模式模式  MRT0-\u0026gt;CHANNEL[mrtchx].INTVAL = time | MRT_CHANNEL_INTVAL_LOAD_MASK; //设置间隔时间 立即载入时间 并启动定时器  while(!MRT_FLAG_READ(mrtchx)); //等待时间到  MRT_FLAG_CLR(mrtchx); //清除标志位 } //------------------------------------------------------------------------------------------------------------------- // @brief MRT开始计时 // @param mrtchx MRT通道号 // @param time 周期中断时间 // @return void // Sample usage: mrt_start(MRT_CH0); //------------------------------------------------------------------------------------------------------------------- void mrt_start(MRTNUM_enum mrtchx) { SYSCON-\u0026gt;AHBCLKCTRLSET[1] = SYSCON_AHBCLKCTRL_MRT_MASK; //打开MRT时钟  SYSCON-\u0026gt;PRESETCTRLCLR[1] = SYSCON_PRESETCTRL_MRT_RST_MASK; //清除MRT复位时钟  MRT0-\u0026gt;CHANNEL[mrtchx].CTRL = MRT_CHANNEL_CTRL_MODE(1); //一次中断模式模式  MRT0-\u0026gt;CHANNEL[mrtchx].INTVAL = MRT_CHANNEL_INTVAL_IVALUE_MASK | MRT_CHANNEL_INTVAL_LOAD_MASK;//设置间隔时间 立即载入时间 并启动定时器 } //------------------------------------------------------------------------------------------------------------------- // @brief MRT获取计时时间 // @param mrtchx MRT通道号 // @return void // Sample usage: uint32 time = mrt_get(MRT_CH0); //无需用户调用 请使用H文件内的宏定义 //------------------------------------------------------------------------------------------------------------------- uint32 mrt_get(MRTNUM_enum mrtchx) { return (MRT_CHANNEL_INTVAL_IVALUE_MASK - MRT0-\u0026gt;CHANNEL[mrtchx].TIMER); //如果返回的是0，则计时已经超出 } //------------------------------------------------------------------------------------------------------------------- // @brief MRT计时清除 // @param mrtchx MRT通道号 // @return void // Sample usage: 清除计时并重新启动 //------------------------------------------------------------------------------------------------------------------- void mrt_clean(MRTNUM_enum mrtchx) { MRT0-\u0026gt;CHANNEL[mrtchx].INTVAL = MRT_CHANNEL_INTVAL_IVALUE_MASK | MRT_CHANNEL_INTVAL_LOAD_MASK;//设置间隔时间 立即载入时间 并启动定时器 }   如何设置延时？\n//------------------------------------------------------------------------------------------------------------------- // @brief 毫秒级systick延时函数 // @param ms 延时多少毫秒 // @return void // Sample usage: systick_delay_ms(1000); //延时1000毫秒 //------------------------------------------------------------------------------------------------------------------- void systick_delay_ms(uint32 ms) { //get_clk();//获取内核时钟便于后面设置 \twhile(ms--) systick_delay(main_clk_mhz*1000); }   ","permalink":"https://dynais.github.io/major/posts/%E7%94%B1mrt%E4%B8%BA%E5%8E%9F%E7%90%86%E7%9A%84oled%E8%AE%A1%E6%97%B6%E6%98%BE%E7%A4%BA%E5%99%A8/","summary":"遇到的问题   OLED无法点亮 困扰了很久的问题，最后发现是硬件上出了毛病，使用飞线或者杜邦线会导致连接不稳定\n  OLED屏幕显示闪烁 可能是因为屏幕刷新不够快，尝试保持一个高刷新率即可\n  OLED屏幕数字重叠 使用uint16时调用现有函数显示数字会有5位的空位（0占位）在设定的坐标之前，注意防止显示内容重叠\n  中断计时时间不准确（很慢） 原因是在中断中加入了函数\nmrt_clean(MRT_CH0); 本来是我认为防止数据溢出而使用的，最后发现会使每次中断的速度大大降低，导致计时不准确，并且去掉这个函数数据好像也不会溢出\u0026hellip;\n   工程目标  了解MRT的使用方法 了解OLED的工作协议和引脚定义 了解IIC的工作原理 结合MET和OLED制作计时器 使用按钮控制调节计时器的几个工作状态  问题解决思路 查阅底层函数了解使用方法，结合OLED的数据手册了解OLED的使用方法，查阅IIC的时序，通过一步步调试减少错误，也便于即时修改。\n待解决问题  如何初始化，打开，调用和关闭MRT IIC协议如何工作 如何开启MRT的计时中断操作 OLED的数据引脚如何发送命令 如何把MRT的反馈显示到OLED上 如何通过按钮控制计时器状态  实行（可能）流程  通过底层函数观察如何使用MRT 通过网上资料或数据手册了解IIC如何工作 通过底层函数观察如何使用OLED 通过简单的程序让OLED显示字符 编写计时函数 编写按钮函数 封装程序   Lösungen   如何操作MRT\n/********************************************************************************************************************* * COPYRIGHT NOTICE * Copyright (c) 2018,逐飞科技 * All rights reserved. * 技术讨论QQ群：179029047 * * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途， * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。 * * @file MRT(多速率定时器) * @company\t成都逐飞科技有限公司 * @author 逐飞科技(QQ3184284598) * @version 查看LPC546XX_config.","title":"由MRT为原理的OLED计时显示器"},{"content":"在Markdown中插入数学公式的语法是 $数学公式$ 和 $$数学公式$$.\n行内公式 行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:\n   示例 显示     $2x+3y=34$    2x+3y=34 2x+3y=34    因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量,也要进入数学模式,使用$1+1=2$,$x$,而不是使用排版普通文字的方式\n独立公式 独立公式单独占一行,不和其他文字混编\n多行公式 在独立公式中使用\\来换行 示例:\n$$ 2x+3y=34\\\\ x+4y=25 $$ 显示: ![2x+3y=34\\ x+4y=25](https://math.jianshu.com/math?formula=2x%2B3y%3D34\\ x%2B4y%3D25)\n常用符号    符号 示例 显示     上下标 S=a_{1}^2+a_{2}^2+a_{3}^2$    括号 $f(x, y) = 100 * \\lbrace[(x + y) * 3] - 5\\rbrace$    分数 $\\frac{1}{3} 与 \\cfrac{1}{3}$    开方 $\\sqrt[3]{X}$和$\\sqrt{5 - x}$ ![\\sqrt[3]{X}](D:\\WorkSpace.Typora Images Hub\\math-1583415699231.svg)和    其他字符 关系运算符    代码 符号     \\pm    \\times    \\div    \\mid    \\nmid    \\cdot    \\circ    \\ast    \\bigodot    \\bigotimes    \\bigoplus    \\leq    \\geq    \\neq    \\approx    \\equiv    \\sum    \\prod     对数运算符    代码 符号     \\log    \\lg    \\ln     三角运算符    代码 符号     \\bot    \\angle    \\sin    \\cos    \\tan    \\cot    \\sec    \\csc     微积分运算符    代码 符号     \\prime    \\int    \\iint    \\iiint    \\oint    \\lim    \\infty    \\nabla    \\mathrm{d}     集合运算符    代码 符号     \\emptyset    \\in    \\notin    \\subset    \\subseteq    \\supseteq    \\bigcap    \\bigcup    \\bigvee    \\bigwedge    \\biguplus    \\bigsqcup     希腊字母    代码 大写 代码 小写     A  \\alpha    B  \\beta    \\Gamma  \\gamma    \\Delta  \\delta    E  \\epsilon    Z  \\zeta    H  \\eta    \\Theta  \\theta    I  \\iota    K  \\kappa    \\Lambda  \\lambda    M  \\mu    N  \\nu    Xi  \\xi    O  \\omicron    \\Pi  \\pi    P  \\rho    \\Sigma  \\sigma    T  \\tau    \\Upsilon  \\upsilon    \\Phi  \\phi    X  \\chi    \\Psi  \\psi    \\Omega  \\omega       需要大写希腊字母，将命令首字母大写即可。 \\Gamma呈现为\n  若需要斜体希腊字母，将命令前加上var前缀即可。\n  向量和复数 普通的变量x:x:$x$\n粗体1：使用\\boldsymbol{}进行加粗，如：\\boldsymbol{x}:$\\boldsymbol{x}$\n粗体2：使用\\mathbf{}进行加粗，如：\\mathbf{x}:$\\mathbf{x}$\n带箭头的向量：使用\\vec{}使向量带箭头，如\\vec{x}:$\\vec{x}$\n复数表示: \\underline{} 表示为 $\\underline{U}$\n绝对值 使用\\vert:$\\vert U \\vert$\n字体 分组 括号 求和、极限与积分 空格 矩阵 基本语法 起始标记\\begin{matrix}，结束标记\\end{matrix} 每一行末尾标记\\\\\\，行间元素之间以\u0026amp;分隔 举例:\n$$\\begin{matrix} 1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\\\\ \\end{matrix}$$ 呈现为：\n矩阵边框  在起始、结束标记处用下列词替换 matrix pmatrix ：小括号边框 bmatrix ：中括号边框 Bmatrix ：大括号边框 vmatrix ：单竖线边框 Vmatrix ：双竖线边框  省略元素  横省略号：\\cdots 竖省略号：\\vdots 斜省略号：\\ddots  $$\\begin{bmatrix} {a_{11}}\u0026amp;{a_{12}}\u0026amp;{\\cdots}\u0026amp;{a_{1n}}\\\\ {a_{21}}\u0026amp;{a_{22}}\u0026amp;{\\cdots}\u0026amp;{a_{2n}}\\\\ {\\vdots}\u0026amp;{\\vdots}\u0026amp;{\\ddots}\u0026amp;{\\vdots}\\\\ {a_{m1}}\u0026amp;{a_{m2}}\u0026amp;{\\cdots}\u0026amp;{a_{mn}}\\\\ \\end{bmatrix}$$ 呈现为：\n阵列 举例\n$$\\begin{array}{c|lll} {↓}\u0026amp;{a}\u0026amp;{b}\u0026amp;{c}\\\\ \\hline {R_1}\u0026amp;{c}\u0026amp;{b}\u0026amp;{a}\\\\ {R_2}\u0026amp;{b}\u0026amp;{c}\u0026amp;{c}\\\\ \\end{array}$$ 呈现为\n方程组  需要cases环境：起始、结束处以{cases}声明  举例\n$$\\begin{cases} a_1x+b_1y+c_1z=d_1\\\\ a_2x+b_2y+c_2z=d_2\\\\ a_3x+b_3y+c_3z=d_3\\\\ \\end{cases} $$ 呈现为\n","permalink":"https://dynais.github.io/major/posts/latex%E5%85%AC%E5%BC%8F%E6%9F%A5%E6%89%BE%E8%A1%A8/","summary":"在Markdown中插入数学公式的语法是 $数学公式$ 和 $$数学公式$$.\n行内公式 行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:\n   示例 显示     $2x+3y=34$    2x+3y=34 2x+3y=34    因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量,也要进入数学模式,使用$1+1=2$,$x$,而不是使用排版普通文字的方式\n独立公式 独立公式单独占一行,不和其他文字混编\n多行公式 在独立公式中使用\\来换行 示例:\n$$ 2x+3y=34\\\\ x+4y=25 $$ 显示: ![2x+3y=34\\ x+4y=25](https://math.jianshu.com/math?formula=2x%2B3y%3D34\\ x%2B4y%3D25)\n常用符号    符号 示例 显示     上下标 S=a_{1}^2+a_{2}^2+a_{3}^2$    括号 $f(x, y) = 100 * \\lbrace[(x + y) * 3] - 5\\rbrace$    分数 $\\frac{1}{3} 与 \\cfrac{1}{3}$    开方 $\\sqrt[3]{X}$和$\\sqrt{5 - x}$ !","title":"在Markdown文件中使用Latex表示数学公式"}]