[{"content":"这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。\n这个项目的一个主要的灵感来源是@稚晖君很早以前发在Arduino论坛上的一个项目 (Link: 如何制作一个带指纹识别的机械键盘), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能\n然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目\u0026hellip;\n这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：https://github.com/DynAis/duino-access\n0x00 - 前言  这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。\n这个项目的一个主要的灵感来源是@稚晖君很早以前发在Arduino论坛上的一个项目 (Link: 如何制作一个带指纹识别的机械键盘), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能\n然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目\u0026hellip;\n这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：https://github.com/DynAis/duino-access\n   0x01 - 核心部分元器件选型 这次的目标是能够使用指纹解锁的方式让电脑自动解锁，思路是使用指纹模块给出信号+单片机模拟键盘输入的简单思路，由于整体的体积要求越小越好，所以元件的选型基本没有选择\n   使用模块 价格     arduino-pro-micro (VCC 5v or 3.3v) 19.80 CNY   HN0610 指纹模块 45.00 CNY   AMS1117-3.3v/5v 降压模块 (假如使用5v的arduino，3.3v的不需要) 1.29 CNY   蜂鸣器、导线若干 -    之所以没有用稚晖的那个FPM3X指纹模块的原因是因为那个好像在TB上已经快找不到了，只剩下最后一家而且卖的很贵，所以当时就选择了这个卖得最好的来做(有几天自闭的时候非常后悔这个选择)，并且从外观上来说我更喜欢这款一点\n   0x02 - 环境选择与搭建 VSCode + PlatformIO 整个环境方面没有使用传统的 ArduinoIDE 来做，而是选择的使用 VSCode 来完成这次的项目，主要原因是为了以后做其他单片机项目的时候也都统一到 VSCode上去，这样整个一致性会比较好\n最后选择了 VSCode 的 PlatformIO 拓展\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184349.png 100% 100% \u0026quot; \u0026quot; %}\n直接在 VSCode 的拓展商店里搜索即可，点击安装即可安装插件，不用动什么脑子，安装过程会有些慢需要耐心等待一会，安装完成后如果成功了你应该可以在左下角看到这个小图标\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184359.png 30% 30% \u0026quot; \u0026quot; %}\n恭喜，如果你看到了这个小房子，那你基本就是安装成功了，但是由于各种各样的原因，你也很有可能等了半天他也还是在转圈圈加载，像我一样\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184405.png 90% 90% \u0026quot; \u0026quot; %}\n那么大概率他是不能自己装上了，我们只能来手动安装\n首先，如果你安装失败了，请先卸载原来的安装失败的 PlatformIO ，重启 VSCode，之后在VSCode的终端里输入\nsudo pip --no-cache-dir install -U platformio\n等待他安装完成，重启VSCode，重新去商店点一下安装，就可以顺利的装上了\n{% alert info %}\n如果依旧不行，可以尝试: 移除Anaconda(假如你安装了Anaconda环境)、安装Python2.7版本并且添加进环境变量、安装Python最新版本并添加进环境变量，如果这也不行，那就尝试使用ArduinoIDE吧(不过这样也许需要稍微改动下代码)\n{% endalert %}\n PlatformIO开发准备 点击Home按钮打开 PlatformIO 主界面，new project 后选择对应的板子，他会进行自动的初始化\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184414.png 90% 90% \u0026quot; \u0026quot; %}\n初始化完成后，在src文件夹里就是我们的main文件\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184421.png 90% 90% \u0026quot; \u0026quot; %}\nPlatformIO 和 ArduinoIDE 不同的地方就是，他是使用cpp文件来进行编译上传的，而不是ino文件，所以每个需要用到 Arduino 库的文件中，都需要包含#include \u0026quot;Arduino.h\u0026quot;才能够使用\n此外，比较麻烦的一点是，对于某些库的支持，也是需要我们手动来加入的，比如这块 Pro Micro 支持的HID键盘和鼠标的功能，就需要我们手动加入\n首先打开刚才的Home界面，在左边一栏里可以找到 Libraries\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184426.png 40% 40% \u0026quot; \u0026quot; %}\n搜索keyboard，找到这个 Arduino 的官方库文件安装\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184431.png 100% 100% \u0026quot; \u0026quot; %}\n安装完成以后，到左边的资源管理器，找到platformio.ini这个文件{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184436.png 70% 70% \u0026quot; \u0026quot; %}\n在文件最后加入\nlib_deps = Keyboard 告诉他我们要调用这个库，这样就完成了，可以开始硬件部分的测试了\n   0x03 - 硬件部分 {% alert warning %}\n一定要注意指纹模块的供电是3.3v，使用5v虽然不会烧坏模块但是会无法工作(当初因为这个原因卡了好久不知道哪错了)\n{% endalert %}\n指纹模块的话是线给剪了直接焊在了板子上，有点粗糙\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184449.jpg 100% 100% \u0026quot; \u0026quot; %}\n看不清楚的话也可以看源文件里 /lib/HN0610/pinDef.h 里的内容\n最后附上Micro的引脚图\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184454.png 100% 100% \u0026quot; \u0026quot; %}\n 测试指纹模块 修改 /src/min.cpp 文件中参数调整宏定义区域的参数 DASTATE 就可以设定当前运行在什么模式下，由于是测试，就把值改为0，运行在检测手指模式上，其他模式的定义也在下面给出\n   功能实现 DASTATE值     检测手指按压 0   指纹注册 1   验证指纹(最后留这一个) 2   检测手指按压后输出硬件信息(需要打开电脑串口) 3   清除所有指纹信息 4    点击上传烧录进Arduino\n如果没有问题的话，按下手指蜂鸣器就会鸣响了\n   0x04 - 遇到的坑和问题 1. 底层数据类型定义问题 通常来说，开发单片机会定义一系列的UINT\n在这次，定义文件写在了 hzTypes.h 文件里，其中对于UINT32的定义出现了兼容错误\n原始内容是\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184458.png 100% 100% \u0026quot; \u0026quot; %}\n我猜测可能是由于他们使用的单片机上int是32位，所以能够正常运行，而在Arduino上，int并不是32位的，long才是，所以需要改为\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184502.png 100% 100% \u0026quot; \u0026quot; %}\n 2.电源的坑 已经说过了，不过这次也是因为在家里没有万用表的缘故，并且提醒，虽然原理图上有一个SJ1来控制Micro的输出电压是5v还是3.3v，但是你并不可以通过连接或者断开这个引脚来达到修改电压的目的，因为5v的Micro和3.3v的Micro主频也是不一样的，这会导致工作不稳定\n并且很有可能改了也没有作用(对于很多国产板)\n{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184513.png 100% 100% \u0026quot; \u0026quot; %}\n 3.注意Micro的中断脚 因为这个指纹识别模块还有自动休眠的功能，所以虽然我现在并没有使用，但是很有可能会用到这个模块的中断信号，那么就要注意Micro的中断引脚定义和Uno是不一样的\n   PIN 中断号     3 0   2 1   0 2   1 3   7 6       0x05 - 后续开发 库HN610    文件名 内容     auth 通讯签名算法(默认不签名)   fp 大部分能直接用的API   fpmComm 模块命令API   hzDevice 串口通信底层   pinDef 主板引脚定义   hzTypes 数据类型定义    ","permalink":"https://dynais.github.io/project/posts/da-duinoaccess/","summary":"这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。\n这个项目的一个主要的灵感来源是@稚晖君很早以前发在Arduino论坛上的一个项目 (Link: 如何制作一个带指纹识别的机械键盘), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能\n然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目\u0026hellip;\n这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：https://github.com/DynAis/duino-access\n0x00 - 前言  这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。\n这个项目的一个主要的灵感来源是@稚晖君很早以前发在Arduino论坛上的一个项目 (Link: 如何制作一个带指纹识别的机械键盘), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能\n然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目\u0026hellip;\n这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：https://github.com/DynAis/duino-access\n   0x01 - 核心部分元器件选型 这次的目标是能够使用指纹解锁的方式让电脑自动解锁，思路是使用指纹模块给出信号+单片机模拟键盘输入的简单思路，由于整体的体积要求越小越好，所以元件的选型基本没有选择\n   使用模块 价格     arduino-pro-micro (VCC 5v or 3.3v) 19.80 CNY   HN0610 指纹模块 45.00 CNY   AMS1117-3.3v/5v 降压模块 (假如使用5v的arduino，3.3v的不需要) 1.29 CNY   蜂鸣器、导线若干 -    之所以没有用稚晖的那个FPM3X指纹模块的原因是因为那个好像在TB上已经快找不到了，只剩下最后一家而且卖的很贵，所以当时就选择了这个卖得最好的来做(有几天自闭的时候非常后悔这个选择)，并且从外观上来说我更喜欢这款一点\n   0x02 - 环境选择与搭建 VSCode + PlatformIO 整个环境方面没有使用传统的 ArduinoIDE 来做，而是选择的使用 VSCode 来完成这次的项目，主要原因是为了以后做其他单片机项目的时候也都统一到 VSCode上去，这样整个一致性会比较好","title":"DuinoAccess"},{"content":"前往原文\n前言 博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。\n这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。\n下面就开始吧~\n准备环境 准备 node 和 git 环境， 首先，安装 NodeJS，因为 Hexo 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。 然后，安装 git，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 Git 教程。\n两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。 在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。\ngit version node -v npm -v 安装 Hexo 如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 Hexo 的详细文档。 在命令行输入执行以下命令：\nnpm install -g hexo-cli 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init myBlog cd myBlog npm install 新建完成后，指定文件夹的目录如下：\n. ├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds # 模版文件夹 ├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹 | ├── _drafts # 草稿文件 | └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。\nhexo s 以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。\n至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。\n注册 Github 首先如果你还没有 Github 账号的先注册一个，具体过程如下\n点击 Start project 或者下面的 new repository 创建一个新的仓库\n注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。\n然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World.\n这个时候打开 http://你的用户名.github.io 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 http://你的用户名.github.io 看到你自己的博客啦！ 比如我的就是 http://webw3c.github.io 了。\n配置 SSH key 要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。\n打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。\ncat ~/.ssh/id_rsa.pub 如果之前没有创建，则执行以下命令全局配置一下本地账户：\ngit config --global user.name \u0026#34;用户名\u0026#34; git config --global user.email \u0026#34;邮箱地址\u0026#34; 然后开始生成密钥 SSH key\nssh-keygen -t rsa -C \u0026#39;上面的邮箱\u0026#39; 按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key\n（此图引用自码云）\n首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You\u0026rsquo;ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。\nssh -T git@github.com 到这还没完，还要登录 Github 上添加刚刚生成的SSH key，按以下步骤添加：\n创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。\n部署到 Github 此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的部署教程。 先不着急，部署之前还需要修改配置和安装部署插件。 第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：\n第二：要安装一个部署插件 hexo-deployer-git。\nnpm install hexo-deployer-git --save 最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：\nhexo g -d 稍等一会，在浏览器访问网址： https://你的用户名.github.io 就会看到你的博客啦！！\n开始写作 博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 hexo 官网。 新建文章，输入以下命令即可\nhexo new \u0026#39;文章标题\u0026#39; 执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。\n在 Markdown 文章里面输入你的文章内容\n再执行一下以下命令\nhexo g hexo s 就可以看到你的文章在博客显示了，以下就是刚刚\n最后，只要部署到你的 Github 上就可以了！\nhexo clean hexo g -d 部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft \u0026ldquo;文章标题\u0026rdquo;，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。\nhexo publish [layout] \u0026lt;filename\u0026gt; 静态图床 文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是测试域名不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外sm.ms这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。\n可以去chrome网上应用商店下载一个叫微博图床的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。\n主题配置 你可以到官网主题页或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题官网使用文档说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。\n一、添加评论系统 *注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置*\n添加 valine 评论系统，打开 /themes/next/_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。\n然后到 leanCloud 登录或者注册 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。\n二、配置腾讯公益404页面  在博客根目录 /source 文件夹下创建404.html（具体内容见下图及代码）； 在 html 上方加入上面3行代码；  腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图\n上图最前面的那几行也要加进去哦。\nlayout: false title: \u0026#34;404\u0026#34; --- 这里放一下上面用到的几个js链接，来自腾讯公益404官方接入文档\n\u0026lt;script type=\u0026#34;text/plain\u0026#34; src=\u0026#34;http://www.qq.com/404/search_children.js\u0026#34; charset=\u0026#34;utf-8\u0026#34; homePageUrl=\u0026#34;https://pojian.xyz\u0026#34; homePageName=\u0026#34;回到我的博客主页\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://qzone.qq.com/gy/404/data.js\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://qzone.qq.com/gy/404/page.js\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 你也可以直接复制我 Github 上的404页面代码，以下是我博客的预览效果。\n另外如果需要自定义个性化404页面的只要删除相应腾讯的JS，直接修改上面的 404.html 文件就可以了。\n三、添加字数统计和阅读时长 首先安装一个插件\n$ npm install hexo-symbols-count-time --save 接着博客根目录下的配置文件里添加以下配置\n# 文章字数统计 symbols_count_time: symbols: true time: true total_symbols: true total_time: true 最后到 next 主题的配置文件下开启 symbols_count_time 字段\n重启一下 hexo 就可以看到效果啦\n四、开启fancybox 打开主题配置文件搜索 fancybox 设置为 true，另外，vendors 填上对应 CDN 地址即可开启\n五、文章分享 百度分享有个 https 的坑，按网上的方法把文件放到自己的服务器是我以前在其他的网站上测试过是能使用的，但在 hexo 中却报错了，具体不清楚是什么原因，感觉可能是 hexo 版本的问题，因为有的人可以，有的人报和我一样的错误，忘记截图了。因为这个功能也没有十分需要，就不继续爬了。换了 share.js 实现了同样的功能，具体可以看本文文末的效果。\n绑定域名 如果你感觉直接使用 github.io 的域名作为你的博客链接不够专业，不够程序员的话那么就购买一个域名解析绑定到你的博客，我也比较建议这样做。 我的是在阿里万网注册的，注册流程比较常规这里就不多详述了，\n注册登录控制台后找到你的域名，点右侧的解析按钮进去解析列表\n点右边的“添加记录”添加两条 CNAME 类型的记录，如上图，后面的记录值就填写你们自己的 Github 地址哈\n记录添加完后就要到 Github 设置绑定你购买的域名了，进入你的博客仓库点 Setting，然后拉到 GitHub Pages 那里填上你的申请购买的域名保存就可以了\n这里说下，当你点击保存的时候 Github Pages 会自动帮你生成一个 CNAME 的文件在根目录，里面的内容就是你绑定的域名地址\n注意，如果是按上面的方法操作还会有一点小问题，就是当你执行 hexo d 部署你本地的文章到 Github 时，你本地的文件会全部覆盖掉你现有仓库上的所有内容，包括 Github Pages 帮你创建的那个 CNAME 文件，这样的话当你访问域名的时候又会访问不到了。所以呢，你需要自己手动在本地根目录 /source 目录下手动创建一个 CNAME 文件，内容就是你的域名地址，因为 source 目录下的文件部署的时候是不会被删除的，所以部署的时候也会一起被部署上去，最后还需要重新到你仓库 Setting，拉到 GitHub Pages 那里再一次绑定你的域名，这样以后就没问题了。\n稍等一会就可以用你申请的域名就访问你的博客了！\nSEO优化 接下来说下百度收录，据说 Github 屏蔽了百度的蜘蛛，也有的人说没，具体不是很清楚，Github 在2015的时候遭受了史上最大规模的DDoS攻击，有国外媒体指百度干的，具体不得而知啦，但感觉百度收录 Github 确认是比较难，时间也比较长，所以还是优化一下吧。\n一、代码同时部署到 coding 那有什么方法呢？就是把博客站点同时托管在国内的 coding 平台上，这样收录就会容易很多，同时又不影响 Github 上的代码，coding 是国内的一个提供代码托管服务的平台，跟 Github 差不多。使用方法也和 Github 差不多，下面我就具体说一下怎么把代码同时部署到 coding 和 Github 上面，让百度更容易收录。\n注册、登录 coding 后创建一个新的仓库，注意点就是新建项目的时候命名规则和 Github 上的一样，就是 用户名.coding.me 可以看下图，还有记得别忘了添加 SSH key\n仓库建好后进入仓库，选左侧的 Page 服务，在设置中绑定新的域名，输入后点击绑定就可以了\n接着到你的域名解析控制台修改添加两条 CNAME 记录指向你的 Page 地址，看下图，注意看记录值哦，换成你自己的。\n最后呢修改根目录下的 _config.yml 配置文件中的部署配置，把 coding 的 git 地址添加进去就行了\n最后执行部署命令\nhexo clean hexo g -d 这时就可以在 coding 仓库中看到你提交部署的代码了，同时 你的用户名.coding.me 也可以访问你的博客站点了，这里 Github 和 coding 的代码是同时更新的，互不影响。而绑定的域名解析可能需要稍等一会才会生效。\n二、百度提交链接 部署到 coding 后也不是百度就可以收录的，我们还需要继续优化。如果在百度搜索输入 site:你的域名 如果出现以下的效果证明就是网站还没被百度收录的，我们现在点下面的提交网址，进入百度站长工具提交。\n三、百度站长平台添加网站管理 注册百度站长工具，并添加网站\n添加网站的过程有三步，主要操作集中在最后一步的网站验证方式里，我选择的是 HTML标签验证，按下面使用方法添加代码到你的网站即可\n而使用 next 主题的同学可以直接在主题的配置文件下搜索 baidu_site_verification 后面填上第三步中 meta 标签中 content 的值就可以\n最后点完成验证就可以通过了。\n四、添加sitemap站点地图 站点地图包含了你网站上的站点链接，方便搜索引擎蜘蛛的抓取工作，搜索蜘蛛会通过网站地图中链接的深层次爬行，抓取新的内容。所以我们要生成 sitemap 文件助于网站优化，安装生成插件\nnpm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 接着在博客根目录下的配置文件里添加对应配置项\n# sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 注意缩进，要不会编译报错\n还要修改一个根目录配置文件下的URL，url 一项的值改成你在百度站长平台里面添加的自己站点的地址，这样生成的 sitemap.xml 文件里的 url 才是你站点的地址，看下图\n五、添加蜘蛛协议robots.txt 增加 robots.txt 文件，就是蜘蛛协议，新建 robots.txt 文件添加以下内容，把 robots.txt 放在 /source 文件下，我们前面说过 /source 目录下的文件是会被打包上传的。\n# hexo robots.txt User-agent: * Allow: / Allow: /archives/ Disallow: /vendors/ Disallow: /js/ Disallow: /css/ Disallow: /fonts/ Disallow: /vendors/ Disallow: /fancybox/ Sitemap: https://pojian.xyz/sitemap.xml Sitemap: https://pojian.xyz/baidusitemap.xml Allow后面的就是你的menu，还有最下面的 Sitemap 地址请自行改成你们自己的地址\n完成后，重启hexo，执行 hexo g -d 重新生成文件并提交后，在public目录下会生成对应的xml文件。可以通过 http://xxx.com/sitemap.xml 和 http://xxx.com/baidusitemap.xml 访问到 sitemap 文件，通过 http://xxx.com/robots.txt 访问到 robots.txt 文件。\n可以到百度站长检测一下 robots.txt 文件是否生效\n六、自动推送 百度有自动推送、主动推送、sitemap、手动提交几种方式。 自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。怎么安装呢？ 如果你的是 next 主题，只要打开主题配置文件搜索找到 baidu_push 设置为 true 即可\n如果你使用的不是 next 主题，也可以手动把以下代码粘贴到你的站点，一般放在 head 头部公共文件里面\n\u0026lt;script\u0026gt; (function(){ var bp = document.createElement(\u0026#39;script\u0026#39;); var curProtocol = window.location.protocol.split(\u0026#39;:\u0026#39;)[0]; if (curProtocol === \u0026#39;https\u0026#39;) { bp.src = \u0026#39;https://zz.bdstatic.com/linksubmit/push.js\u0026#39;; } else { bp.src = \u0026#39;http://push.zhanzhang.baidu.com/push.js\u0026#39;; } var s = document.getElementsByTagName(\u0026#34;script\u0026#34;)[0]; s.parentNode.insertBefore(bp, s); })(); \u0026lt;/script\u0026gt; 七、主动推送 这里利用一个第三方插件 hexo-baidu-url-submit 进行主动推送 安装\nnpm install hexo-baidu-url-submit --save 添加想关配置到根目录下的配置文件里\n# 百度链接提交-主动推送配置 baidu_url_submit: count: 3 ## 提交最新的一个链接 host: pojian.xyz ## 在百度站长平台中注册的域名 token: 3GIEYsuq5ZTkvDBm ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 添加新的部署配置，注意这里跟之前有点不一样，要在 type 前添加一个破折号 -\ndeploy: - type: git repo: github: https://github.com/webw3c/webw3c.github.io.git coding: https://git.dev.tencent.com/yusting/yusting.coding.me.git - type: baidu_url_submitter 最后，执行 hexo deploy 的时候，新的连接就会被推送了。 实现原理 新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接 新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎\n八、手动推送 就是直接直接把你需要提交的链接直接使用手动的方式填写提交就可以。\n最后你可以看到是否已经被百度成功收录了\n如果抓取成功了就证明已经被收录了，好像一般不会这么快，我的等了两天左右才抓取得到。\n九、添加百度统计 添加百度统计就可以查看你网站相关的一些数据，便于你自己的站点\n多端同步写作 原理就是利用 Git 的分支功能，比如新建立一个 blog 分支来存放 Hexo 的源文件，而 master 分支则用来放编译后的静态文件，这样在使用另外一台电脑编写的时候只要把 blog 分支拉取下来然后进行写作再 push 到分支就可以了。具体内容或者步骤后续会有更新。。。\n手机编写 网上好像找不到什么资料，不过通过在手机端安装 SSH 客户端远程操作服务器端，安装配置 node / git / hexo 环境编写应该可以的，原理同多台电脑编写差不多，不过这样做不太省心，不折腾了哈。\n结语 文章到这差不多啦！后续有些小点深入学习后还是会保持更新的，希望文章对曾经像我一样的小白有那么一点帮助，技术有限，难免有纰漏，欢迎指正批评和讨论，感谢阅读！:-)\n","permalink":"https://dynais.github.io/project/posts/%E8%BD%AC-hexo-github-page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"前往原文\n前言 博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。\n这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。\n下面就开始吧~\n准备环境 准备 node 和 git 环境， 首先，安装 NodeJS，因为 Hexo 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。 然后，安装 git，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 Git 教程。\n两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。 在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。\ngit version node -v npm -v 安装 Hexo 如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 Hexo 的详细文档。 在命令行输入执行以下命令：\nnpm install -g hexo-cli 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。","title":"[转] Hexo-Github-Page搭建博客教程"},{"content":"项目进度   重构了代码\n  修正了大部分bug\n  一. 重要代码模块 1. Qtimer  https://blog.csdn.net/jia666666/article/details/81672344\n Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式\n多次触发 timer.timeout.connect(function) ... timer = Qtimer() timer.start(1000) 这里timeout是Qtimer的中断信号, 这里设定timer.start(1000)代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块\n如果要停止Qtimer,使用\ntimer.stop() 2. 自定义信号  https://blog.csdn.net/foreveronly/article/details/82453697\n 二. 已解决的问题 1. 拖动窗口时时间不走动的问题 加完Qtimer中断完全没有问题\n3. 进程无法完全退出问题 -\u0026gt; window.close()效果问题 -\u0026gt; 响铃bug 通过将子窗口变为主窗口类的成员, 并使用以下语句初始化\nclass MainWindow(QMainWindow): def __init__(self): super().__init__() #子窗口建立 self.subBreak = BreakWindow(self)# 注意这里 class BreakWindow(QDialog): def __init__(self,parent=None): super().__init__(parent) 关键也就是加入def __init__(self,parent=None), 使主从窗口关联起来(具体实现逻辑尚不清晰), 再加上合理的退出判断, 就可以实现干净的退出了\n响铃bug加完Qtimer中断完后全没有问题\n4. 占用cpu过高问题 加完Qtimer中断完全没有问题\n5. 交互逻辑混乱问题 通过重构代码逻辑解决了, 现在所有的子窗口都是主窗口的成员了\n三. 待解决的问题 1. Qt里写了中文uic()命令就无法成功执行的问题 暂时没有思路\n四. 下一阶段的目标 1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据? 五. 总结 再此理解了那句话, 不能让程序假死, 比如之前我想要time.sleep()来实现\u0026hellip;\n正确使用中断是很重要的, 这方面还要多加练习\n并且另外很重要的一点就是, 使用一个库里现成的东西往往整个的整合度会更好\n本来甚至都准备上多线程了\u0026hellip;\n","permalink":"https://dynais.github.io/project/posts/t-clk-%E7%95%AA%E8%8C%84%E9%92%9F%E9%87%8D%E6%9E%84/","summary":"项目进度   重构了代码\n  修正了大部分bug\n  一. 重要代码模块 1. Qtimer  https://blog.csdn.net/jia666666/article/details/81672344\n Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式\n多次触发 timer.timeout.connect(function) ... timer = Qtimer() timer.start(1000) 这里timeout是Qtimer的中断信号, 这里设定timer.start(1000)代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块\n如果要停止Qtimer,使用\ntimer.stop() 2. 自定义信号  https://blog.csdn.net/foreveronly/article/details/82453697\n 二. 已解决的问题 1. 拖动窗口时时间不走动的问题 加完Qtimer中断完全没有问题\n3. 进程无法完全退出问题 -\u0026gt; window.close()效果问题 -\u0026gt; 响铃bug 通过将子窗口变为主窗口类的成员, 并使用以下语句初始化\nclass MainWindow(QMainWindow): def __init__(self): super().__init__() #子窗口建立 self.subBreak = BreakWindow(self)# 注意这里 class BreakWindow(QDialog): def __init__(self,parent=None): super().__init__(parent) 关键也就是加入def __init__(self,parent=None), 使主从窗口关联起来(具体实现逻辑尚不清晰), 再加上合理的退出判断, 就可以实现干净的退出了","title":"重构完成, 焕发新生"},{"content":"项目进度  加入了自己指定时间的模块   加入保存用户设置的文件config.json 在倒计时结束时发出铃声通知 完善了除统计和To Do List外的Menu界面   修正了部分bug  一. 重要代码模块 1. 打包程序成exe文件 pyInstaller模块 pyInstaller是python的一个库, 使用它可以很方便的打包文件成为exe可执行文件\n要使用这个库, 首先在Pycharm里安装相应的环境, 之后新建一个.py文件, 比如我的:\n在里面输入代码(以这次工程为例):\nimport os if __name__ == \u0026#39;__main__\u0026#39;: from PyInstaller.__main__ import run opts=[\u0026#39;main.py\u0026#39;,\u0026#39;-w\u0026#39;,\u0026#39;-F\u0026#39;,\u0026#39;--icon=image/tomato.ico\u0026#39;] run(opts) 其中主要注意opts=['main.py','-w','-F','--icon=image/tomato.ico']这一句\nmain.py是主文件, 是进程的入口\n-w这个参数使编译出来的文件时exe+文件的形式, 去掉这个参数编译出来是一个整体的exe文件\n-F参数强制编译, 也就是说本次会覆盖上次的文件, 我觉得加上比较好\n最后--icon=image/tomato.ico是我指定的exe文件图标, 需要是一个ico文件\n直接运行.py脚本就可以在/dist里得到编译的文件\n资源文件夹问题 本次制作番茄钟使用到的资源文件, 比如配置文件, 或者是.MP3的铃声文件, pyInstaller在编译的时候都是不会编译的, 也就是说需要自己将文件复制到产生出来的目录下, 不然程序会报错无法运行\n2. 读取和写入配置文件 使用Json作为配置文件 Json是一种常见的语言, 其中一种用法就是作为书写配置文件的语言, 虽然有人说它不适合作为配置文件语言, 但是小项目用用还是没有问题的\nJson配置文件以{开头, 以}结束, 大括号在Json里代表一个对象, 具有一个键与一个值, 用:对应,\n可以理解为Python里的字典(其实就是)\n用Python的语法来看Json没有一点问题\n如\n{\u0026#34;tomato\u0026#34;: {\u0026#34;t_target\u0026#34;: \u0026#34;00:05\u0026#34;, \u0026#34;t_break\u0026#34;: \u0026#34;00:05\u0026#34;}} 值得注意的是Json对语法的要求非常严格, 并且不可以有注释\nPython3读取Json文件 Python官方内置了Json的使用库\nimport json #假设config是一个字典 # Json读取 with open(\u0026#34;config.json\u0026#34;, \u0026#34;r\u0026#34;) as c: config = json.load(c) # Json写入 with open(\u0026#34;config.json\u0026#34;, \u0026#34;w\u0026#34;) as c: json.dump(config, c) 读取文件以字典形式展现, 写入的变量也需要是一个字典\n3. 在对象方法定义里直接调用具体的实例 发现在对象的方法定义里, 可以直接调用看起来还没有定义的实例, 比如\nclass BreakWindow(QtWidgets.QDialog): ... def start_a_new_tomato(self): ... window.start_a_tomato() 在这里我定义了BreakWindow类, 方法里调用了window.start_a_tomato(), window是另一个类, 并且在后文才定义(当然是在方法调用之前)\n4. 循环不退出? - 使用flag标志的重要性 因为循环不退出而产生bug已经不知道多少次了, 以后注意在书写循环的时候一定要提前想好尽可能全的情况, 并且写好flag, 循环不在该退的时候退真的很讨厌\n二. 已解决的问题 1. 在Python中播放声音/音乐 - playsound包 在环境里加入playsound包\n调用使用\nfrom playsound import playsound playsound(\u0026#34;sound/XXXX.mp3\u0026#34;) 真的是非常简单的API了\n但是缺点也是太简单了, 几乎没有其他的可操作选项了, 可以看的出来作者基本也是没有什么经验的\n还有一个就是响铃的速度好像不是很快\n2. 窗口关闭事件信号 - 重写closeEvent()方法 在窗口关闭时, 会执行.closeEvent()方法, 通过重写这个方法, 可以达到检测窗口关闭的效果\ndef closeEvent(self, event): event.accept() 3. 验证窗口是否在关闭 - isHidden() 三. 待解决的问题 1. 拖动窗口时时间不走动的问题 暂时没有思路\n2. Qt里写了中文uic()命令就无法成功执行的问题 暂时没有思路\n3. 进程无法完全退出问题 -\u0026gt; window.close()效果问题 -\u0026gt; 响铃bug 4. 占用cpu过高问题 猜测是在循环时关闭窗口导致循环还在后台运行, 没有正常退出的问题\n但怎么说这个占用也太夸张了吧就算是我有个循环\n你一个循环凭什么吃掉我1/4个CPU啊\n5. 交互逻辑混乱问题 完全是我的锅, 因为各种小bug, 以及前期准备不足, 经验不到位, 结果使得各种循环判断, 各种地方交错调用, 命名没规范之类\u0026hellip;\n导致出现大问题无从下手, 如果要进一步给软件加入功能, 最起码的, 让他**\u0026ldquo;能用\u0026rdquo;**, 是肯定要重构代码的\n四. 下一阶段的目标  代码重构 五. 总结 虽然程序交互有很大进步, 但还是可以看出我的经验不足, 前期准备缺乏, 导致结构混乱, 后期出现Bug无从下手\n经过这次教训, 我知道了前期纸上的准备和写代码同样重要, 写代码和我整理电脑一样, 都不可以把东西随意乱放, 不然图一时之快只会给以后的自己带来麻烦\n虽然标题上写着**\u0026ldquo;又不是不能用\u0026rdquo;, 但CPU占用如此之高, 进程无法干净退出, 无故响铃的软件, 确实就是\u0026ldquo;不能用\u0026rdquo;**的\n","permalink":"https://dynais.github.io/project/posts/t-clk-%E7%95%AA%E8%8C%84%E9%92%9F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%BB%BA%E8%AE%BE/","summary":"项目进度  加入了自己指定时间的模块   加入保存用户设置的文件config.json 在倒计时结束时发出铃声通知 完善了除统计和To Do List外的Menu界面   修正了部分bug  一. 重要代码模块 1. 打包程序成exe文件 pyInstaller模块 pyInstaller是python的一个库, 使用它可以很方便的打包文件成为exe可执行文件\n要使用这个库, 首先在Pycharm里安装相应的环境, 之后新建一个.py文件, 比如我的:\n在里面输入代码(以这次工程为例):\nimport os if __name__ == \u0026#39;__main__\u0026#39;: from PyInstaller.__main__ import run opts=[\u0026#39;main.py\u0026#39;,\u0026#39;-w\u0026#39;,\u0026#39;-F\u0026#39;,\u0026#39;--icon=image/tomato.ico\u0026#39;] run(opts) 其中主要注意opts=['main.py','-w','-F','--icon=image/tomato.ico']这一句\nmain.py是主文件, 是进程的入口\n-w这个参数使编译出来的文件时exe+文件的形式, 去掉这个参数编译出来是一个整体的exe文件\n-F参数强制编译, 也就是说本次会覆盖上次的文件, 我觉得加上比较好\n最后--icon=image/tomato.ico是我指定的exe文件图标, 需要是一个ico文件\n直接运行.py脚本就可以在/dist里得到编译的文件\n资源文件夹问题 本次制作番茄钟使用到的资源文件, 比如配置文件, 或者是.MP3的铃声文件, pyInstaller在编译的时候都是不会编译的, 也就是说需要自己将文件复制到产生出来的目录下, 不然程序会报错无法运行\n2. 读取和写入配置文件 使用Json作为配置文件 Json是一种常见的语言, 其中一种用法就是作为书写配置文件的语言, 虽然有人说它不适合作为配置文件语言, 但是小项目用用还是没有问题的\nJson配置文件以{开头, 以}结束, 大括号在Json里代表一个对象, 具有一个键与一个值, 用:对应,\n可以理解为Python里的字典(其实就是)\n用Python的语法来看Json没有一点问题","title":"又不是不能用, 番茄钟基本功能建设完毕"},{"content":"项目进度  实现了番茄钟最基本的倒计时功能 实现了按钮交互的功能  一. 重要代码模块 1. 显示时间与计算时间的转换 实现倒计时时的一个问题是: 显示的时间格式需要是\u0026quot;XX:XX\u0026quot;, 但是为了方便计算, 需要把这个格式的时间转化为秒数的形式, 这就需要一个显示时间与计算时间互相转换的模块\n# 显示时间转秒数 \u0026#34;XX:XX\u0026#34; -\u0026gt; flout def tomato2sec(tomato): sec = int(tomato[3:]) sec = sec + 60 * int(tomato[:2]) return sec # 秒数转显示时间 flout -\u0026gt; \u0026#34;XX:XX\u0026#34; def sec2tomato(sec): t = [] t.append(str(int(sec / 60))) t.append(str(int(sec % 60))) for i in range(0, len(t)): if len(t[i]) \u0026lt; 2: t[i] = \u0026#34;0\u0026#34; + t[i] tomato = \u0026#34;:\u0026#34;.join(t) return tomato 2. 获取系统时间 获取系统时间在python里我使用的是time包, 还有一个相似的是datetime.time包, 注意不要搞混了\nimport time 倒计时的基本思路是点击开始按钮时获取一个开启的系统时间, 然后用户会有一个给定的目标时间, 然后点按钮以后会进入一个循环, 知道计时结束才会退出, 在循环里面一直获取系统时间和其实时间运算就得到了已经过了多久, 再和目标时间判断就行了\nt_start = time.time() 这个语句是获取以秒数显示的当前系统时间, 用于运算会比较方便\n3. 页面元素的交互 简单的页面元素交互可以在Qt里直接实现\n原理基本上是, 按下按钮之类的东西, 会发出一个信号\nui_window.button_start.clicked这个信号就是ui_window这个窗口下button_start按钮发出的点击信号, 使用connect绑定一个slot之后\nui_window.button_start.clicked.connect(start_a_tomato) 在这里的意思就是: 单击这个按钮以后执行start_a_tomato函数, 注意函数名在这里不带括号\n二. 已解决的问题 1. 倒计时使用time.sleep()效果不好的问题 最开始的思路里, 用户点击开始后进入一个循环, 这个循环每次执行一秒, 然后让页面更新一次, 用到的函数是这个\nimport time time.sleep(1)\t#控制系统空置一秒 但是问题就是, 和单片机上不能乱用delay()一样, 使用sleep()会使程序整个无法响应, 导致拖拽手感奇怪, 且拖拽时倒计时直接停止\n然后换了思路, 直接不断读取系统时间实时刷新, 解决了拖拽手感的问题, 但拖拽时倒计时还是会停止, 不过放下窗口后时间并不会出错, 就先不管了\n2. 改变窗口元素但窗口显示不刷新的问题 最开始在循环里改变了元素, 但发现直到循环退出窗口才改变了显示, 但使用print输出又没什么问题, 于是想可能是窗口刷新的问题, 最后的解决办法就一条指令\nQtWidgets.QApplication.processEvents() 让窗口刷新\n三. 待解决的问题 1. 拖动窗口时时间不走动的问题 暂时没有思路\n2. Qt里写了中文uic()命令就无法成功执行的问题 应该是编码不统一的问题, 但是改了Qt的编码几次还是不行, 暂时先用英文顶着, 看看以后有没有解决办法\n暂时没有思路\n四. 下一阶段的目标  加入自己指定时间的模块 加入保存用户设置的文件 在倒计时结束时尝试发出通知  ","permalink":"https://dynais.github.io/project/posts/t-clk-%E7%95%AA%E8%8C%84%E9%92%9F%E5%80%92%E8%AE%A1%E6%97%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/","summary":"项目进度  实现了番茄钟最基本的倒计时功能 实现了按钮交互的功能  一. 重要代码模块 1. 显示时间与计算时间的转换 实现倒计时时的一个问题是: 显示的时间格式需要是\u0026quot;XX:XX\u0026quot;, 但是为了方便计算, 需要把这个格式的时间转化为秒数的形式, 这就需要一个显示时间与计算时间互相转换的模块\n# 显示时间转秒数 \u0026#34;XX:XX\u0026#34; -\u0026gt; flout def tomato2sec(tomato): sec = int(tomato[3:]) sec = sec + 60 * int(tomato[:2]) return sec # 秒数转显示时间 flout -\u0026gt; \u0026#34;XX:XX\u0026#34; def sec2tomato(sec): t = [] t.append(str(int(sec / 60))) t.append(str(int(sec % 60))) for i in range(0, len(t)): if len(t[i]) \u0026lt; 2: t[i] = \u0026#34;0\u0026#34; + t[i] tomato = \u0026#34;:\u0026#34;.join(t) return tomato 2. 获取系统时间 获取系统时间在python里我使用的是time包, 还有一个相似的是datetime.","title":"番茄钟倒计时模块的基本实现"},{"content":"一. 软件 1. Pycharm 2019.3.3 ​\tPycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成\n2. Qt 5.12.7 / Qt Creator ​\tQt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版\n二. 环境搭建(对于已有Anaconda3) 1.Python解释器 由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用\n2. 配置环境变量(对于Anaconda3) 对于Anaconda3的用户, 需要再自行配置一下环境变量, 在环境变量的path选项卡中添加Anaconda的以下目录\n不然在Pycharm中搭建环境时会遇到提示pip无法成功的提示, 导致包无法安装\n3. 在Pycharm里搭建环境/安装必要的包 完成以上两步准备就可以开始配置Pycharm了\n首先新建一个项目\n有几点需要注意的地方:\n首先, 确保New environment using中是新建了一个环境,而不是使用Conda.\n其次, 确保Base interpreter中选择的是pythonw解释器, 而不是python\n最后注意, 此处不需勾选\n然后就可以让它新建一个项目了\n打开工程后进入 文件 -\u0026gt; 设置 -\u0026gt; 项目 -\u0026gt; Project Interpreter 在这里管理需要用到的包文件\n需要使用Qt编程的话, 必须添加QtPy和PyQt5两个包\nPycharm会自己管理, 下载好就算是配置完成了\n三. 工作流 大致的思路是:\n 使用Qt Creator创作图形界面 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中 使用Pycharm编写整体逻辑  1. 使用Qt Creator创作图形界面 打开Qt Creator新建工程\n注意创建时选择桌面图形应用, 这里不需要选Python的那个\n工程最好命名为ui, 保存在一个项目文件夹下\n2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中 在Pycharm中新建一个builder.py文件\nfrom qtpy import uic uic.compileUiDir(\u0026#34;这里填入Qt工程的文件夹路径\u0026#34;) 运行便可以得到一个.py文件, 里面是应用程序外观的描述\n在主程序py文件中写入\nimport sys from qtpy import QtWidgets from ui.mainwindow import Ui_MainWindow app = QtWidgets.QApplication(sys.argv)\t#设置一个App window = QtWidgets.QMainWindow()\t#新建一个窗口 ui_window = Ui_MainWindow()\t#新建一个导入包中窗口的类 ui_window.setupUi(window)\t#注意自己的窗口要填入括号 window.setWindowTitle(\u0026#34;Tomato Clock v0\u0026#34;)\t#设置标题 window.show()\t#显示窗口 sys.exit(app.exec_())\t#设置退出 设置完成\n","permalink":"https://dynais.github.io/project/posts/t-clk-python+qt5%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/","summary":"一. 软件 1. Pycharm 2019.3.3 ​\tPycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成\n2. Qt 5.12.7 / Qt Creator ​\tQt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版\n二. 环境搭建(对于已有Anaconda3) 1.Python解释器 由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用\n2. 配置环境变量(对于Anaconda3) 对于Anaconda3的用户, 需要再自行配置一下环境变量, 在环境变量的path选项卡中添加Anaconda的以下目录\n不然在Pycharm中搭建环境时会遇到提示pip无法成功的提示, 导致包无法安装\n3. 在Pycharm里搭建环境/安装必要的包 完成以上两步准备就可以开始配置Pycharm了\n首先新建一个项目\n有几点需要注意的地方:\n首先, 确保New environment using中是新建了一个环境,而不是使用Conda.\n其次, 确保Base interpreter中选择的是pythonw解释器, 而不是python\n最后注意, 此处不需勾选\n然后就可以让它新建一个项目了\n打开工程后进入 文件 -\u0026gt; 设置 -\u0026gt; 项目 -\u0026gt; Project Interpreter 在这里管理需要用到的包文件\n需要使用Qt编程的话, 必须添加QtPy和PyQt5两个包\nPycharm会自己管理, 下载好就算是配置完成了\n三. 工作流 大致的思路是:\n 使用Qt Creator创作图形界面 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中 使用Pycharm编写整体逻辑  1.","title":"Python+Qt5项目环境的搭建"},{"content":"本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.\n项目总结_人脸识别的Haar实现 项目历时:\t2020.2.3 - 2020.2.5 负责人:\tDynais 项目花费:\t无 报告撰写时间: 2020.2.6  项目概述 本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.\n目录   第一部分\t部分原理粗解\n 1.1\t图像压缩 1.2 直方图均衡化 1.3 Haar特征检测    第二部分 软件结构设计与实现\n  第三部分 难点与优化方法\n 3.1 难点一:\t面部检测速度过慢    第四部分 总结\n 4.1 不足之处 4.2 总结    第五部分 参考文献\n   第一部分 部分原理粗解 1.1 图像压缩 对原图多个像素求和后取平均值, 得到一个新的像素值, 作为目标图像的像素值, 这样得到的新图像就是经过了压缩的原图像, 原理过于简单就不详细展开\n1.2 直方图均衡化 直方图 建立一个桶, 将一幅图像的某一个通道的像素值进行桶排序并可视化, 呈现出来的图像称为直方图\n一幅灰度图像的直方图通常如下:\n[图没了]\n直方图可以直观的反应图像上的像素值分布情况, 如:\n直方图均衡化\n直方图均衡化是将原图像通过某种变换，得到一幅灰度直方图为均匀分布的新图像的方法.\n直方图均衡化方法的基本思想是对在图像中像素个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减. 从而达到清晰图像的目的.\n将原图的像素值进行重新映射, 使直方图分布更加均匀, 达到了加强图像对比度的目的.\n具体解析见:\n直方图均衡化\n1.3 Haar特征检测 Haar 特征检测部分, 由于已经有大量的博客详细描述过了, 所以不再浪费时间写\n值得一提的是原作者的论文《Robust Real-Time Face Detection》是人脸检测的经典论文, 虽然读起来很困难(更何况是英文) 但还是值得一读, 如果希望深入了解的话\n更多博客文章: 印象笔记关键字: Haar\n 第二部分 软件结构设计与实现方法 文件夹\u0026quot;OpenCV_FaceDetectPro\u0026quot;中包含了两个.cpp文件:\n OpenCV_Process.cpp\t包括人脸检测函数及其相关调用函数 OpenCV_main.cpp 程序主入口  人脸检测流程 人脸检测(优化后的版本)的步骤分为:\n  识别标志位, 判断当前状态是检测还是跟踪\n  对摄像头当前采集图像进行分割\n  灰度化\n  压缩\n  直方图均衡化\n  Haar特征检测\n  返回人脸位置\n  相关实现 状态识别 由于时间复杂度问题(在下一章会说到), 采用了检测和跟踪分开的思路, 主要的思路是降低输入图像的大小. 采用每次检测完人脸后进行标志的判断为方法, 确定程序运行在那种状态下.\n对于检测和跟踪模式, 使用了不同的思路来进行图像分割\nHaar 直接使用了现成的数据, 自己并不会训练, 直接调用OpenCV的 CascadeClassifier 类实现\n 第三部分 难点与优化方法 3.1 难点一: 面部检测速度过慢 未优化前的程序, 每次读入摄像头图像后直接进行灰度化与直方图均衡化, 然后进行全图的面部检测, 并且没有面部跟踪的实现, 导致每次图像的处理时间非常长, 达到了每帧图像0.8秒.\n针对时间过长的问题, 首先引入了面部识别的标志位, 每次程序识别到面部时, 打开标志位, 然后在接下来的循环里只根据上次判断的面部位置截取小块图像进行判断,大大降低处理时间\n其次, 使用图像压缩, 使待处理图像处于一个大小和准确度都可以接受的点上.\n引入后, 面部检测的时间从0.8秒降低到0.04秒\n部分代码:\n图像压缩(前置函数为自己写的areaAvarage())\n/**************************************************** * Function: * 用于图像压缩函数zipImg, 基于周边像素求出当前像素值 * * Note: * 算法用左上像素求, 不知道会不会失真 * * ******************************************************/ uchar areaAvarage(Mat src, Point pos, int channal, int gain) { int pixel = 0; if (src.channels() != 1) { int i, j; for (i = 0; i \u0026lt; gain; i++) { for (j = 0; j \u0026lt; gain; j++) { pixel += src.at\u0026lt;Vec3b\u0026gt;(pos.y - j, pos.x - i)[channal]; } } pixel /= (gain * gain); return saturate_cast\u0026lt;uchar\u0026gt;(pixel); } else { int i, j; for (i = 0; i \u0026lt; gain; i++) { for (j = 0; j \u0026lt; gain; j++) { pixel += src.at\u0026lt;uchar\u0026gt;(pos.y - j, pos.x - i); } } pixel /= (gain * gain); return saturate_cast\u0026lt;uchar\u0026gt;(pixel); } } /**************************************************** * Function: * 图像压缩 gain^2 倍,长宽变为原先 1/gain * * Note: *\t速度还是不够理想 * 留出了一圈白边 * ******************************************************/ void zipImg(Mat\u0026amp; src, Mat\u0026amp; dst, int gain) { dst = Mat(src.size() / gain, src.type()); int i, j; if (src.channels() != 1) { //遍历 for (i = 1; i \u0026lt; dst.cols - 1; i++) { for (j = 1; j \u0026lt; dst.rows - 1; j++) { uchar b, g, r; int realpos_x = i * gain; int realpos_y = j * gain; Point pos(realpos_x, realpos_y); //对周边像素求均值,赋值给新图 b = areaAvarage(src, pos, 0, gain); g = areaAvarage(src, pos, 1, gain); r = areaAvarage(src, pos, 2, gain); dst.at\u0026lt;Vec3b\u0026gt;(j, i) = { b,g,r }; } } } else { for (i = 1; i \u0026lt; dst.cols - 1; i++) { for (j = 1; j \u0026lt; dst.rows - 1; j++) { uchar g; int realpos_x = i * gain; int realpos_y = j * gain; Point pos(realpos_x, realpos_y); //对周边像素求均值,赋值给新图 g = areaAvarage(src, pos, 1, gain); dst.at\u0026lt;uchar\u0026gt;(j, i) = g; } } } }  第四部分 总结 4.1 不足之处  虽然采用检测与跟踪同样裁剪画面的方法, 但是效果其实并不理想, 速度提升微弱 面部检测对侧脸准确性几乎没有 光照优化有待加强 速度还是不够快 脸太大或太小检测不了  4.2 总结 总的来说这次项目还是挺成功的, 在几天以内就完成了, 虽然借由了大量API, 但原理也还是有所了解的. 接下来的任务是使他能够在树莓派上也能正常运行.\n","permalink":"https://dynais.github.io/project/posts/hf-%E4%BD%BF%E7%94%A8opencv%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/","summary":"本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.\n项目总结_人脸识别的Haar实现 项目历时:\t2020.2.3 - 2020.2.5 负责人:\tDynais 项目花费:\t无 报告撰写时间: 2020.2.6  项目概述 本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.\n目录   第一部分\t部分原理粗解\n 1.1\t图像压缩 1.2 直方图均衡化 1.3 Haar特征检测    第二部分 软件结构设计与实现\n  第三部分 难点与优化方法\n 3.1 难点一:\t面部检测速度过慢    第四部分 总结\n 4.1 不足之处 4.2 总结    第五部分 参考文献","title":"OpenCV中人脸识别的Haar实现"}]