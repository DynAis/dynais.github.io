<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DynAis的个人站</title>
  
  <subtitle>DynAis&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dynais.xyz/"/>
  <updated>2021-02-21T09:42:48.000Z</updated>
  <id>http://dynais.xyz/</id>
  
  <author>
    <name>DynAis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欢迎! Willkommen!</title>
    <link href="http://dynais.xyz/posts/872a1608.html"/>
    <id>http://dynais.xyz/posts/872a1608.html</id>
    <published>2029-12-31T23:00:00.000Z</published>
    <updated>2021-02-21T09:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎来到我的个人博客，这是我的第二次尝试，我会尝试持续更新的😉</strong><br><strong>Willkommen zum meinem persönlichen Blog, eigentlich ist das mein zweiter Versuch und ich werde versuchen, der Blog ständig zu aktualisieren😉</strong></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010149.png" alt=""></p><a id="more"></a><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/872a1608.html">http://dynais.xyz/posts/872a1608.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;欢迎来到我的个人博客，这是我的第二次尝试，我会尝试持续更新的😉&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Willkommen zum meinem persönlichen Blog, eigentlich ist das mein zweiter Versuch und ich werde versuchen, der Blog ständig zu aktualisieren😉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010149.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>圣诞快乐!</title>
    <link href="http://dynais.xyz/posts/8be3b054.html"/>
    <id>http://dynais.xyz/posts/8be3b054.html</id>
    <published>2029-12-31T23:00:00.000Z</published>
    <updated>2021-12-21T21:00:53.750Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><blockquote><p>A plate of Gingerbread treats for the reindeer.</p><p>A glass of schnapps for Santa.</p></blockquote><p>展信佳</p><p>圣诞快乐! pyl同学! </p><p>总算是熬到圣诞假期了… 已经不想再上课了! 每天早上七点起床也太折磨了. 放假万岁!</p><p>虽然这么说, 但是圣诞以后就正式开始期末考试了, 所以说是放假, 实际上只是个考试周而已. 读个大学怎么这么折磨啊. 要开始不开心了.</p><p>说起圣诞树啊, 德国这边很早之前去超市的时候就看见门口有人在卖整棵整棵的树呢, 而且也不是很贵的样子, 要是有车的话是不是能拉回寝室呢? 说起来, 快要过圣诞节了, 寝室里一点圣诞元素都没有呢… 初来乍到是这样的. (好想尝尝姜饼人)</p><p>不过现在不是说这个的时候, 先来看看给你准备的圣诞树比较重要. </p><p>说起你的圣诞树, 其实当天你发我的时候我就准备用画的来着的, 然后唰唰画完之后, 虽然当时挺满意的, 但是第二天总觉得又缺了什么. 想了想还是缺了点新意, 所以决定再练练新的技术, 探索一下新的方式, 其实通常这种尝试都没有什么结果的, 但是说实话这次我还挺满意的, 所以请你务必看一看! (然后再和我锐评一波)</p><p>好啦, 那就请你收下这棵赛博圣诞树吧, 就在下面, 试着去点点它吧.</p><p><strong>Marry Chrismas !</strong></p><p>DynAis, 2021-12-21</p><p>(请确保浏览设备系统至少为IOS12及以上同时使用Safari浏览器, 并且身处环境网络连接状况良好, 室内光线充足, 最后, 如果什么都没有发生, 请再给它几秒钟…)</p><div class="figure center">    <a rel="ar" href="http://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/storage/paper_tree_loop.usdz" target="_self">        <img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/web.jpg" alt="???">    </a></div><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/8be3b054.html">http://dynais.xyz/posts/8be3b054.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这里发生了什么🎄?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/image-20211218133239506.png&quot; alt=&quot;image-20211218133239506&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>解决Python脚本在运行环境下依赖库缺失的问题</title>
    <link href="http://dynais.xyz/posts/ce920ebf.html"/>
    <id>http://dynais.xyz/posts/ce920ebf.html</id>
    <published>2021-02-23T11:40:37.000Z</published>
    <updated>2021-03-03T03:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在某一个虚拟环境中完成脚本后, 想要实际使用时可能会出现错误<br><div class="figure center" style="width:;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210223124433.png?x-oss-process=image/resize,h_2000/quality,q_90" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210223124433.png?x-oss-process=image/resize,h_2000/quality,q_90" alt=""></a></div><div style="clear:both;"></div><br>这是由于虚拟环境和运行环境不一致导致依赖库缺失无法<code>import</code>导致的<br><br><br><br></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方式就是在编写脚本时, 对于第三方的库进行一次检测, 如果没有的话就进行<code>pip install</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> regex <span class="keyword">as</span> re</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    os.system(<span class="string">'pip install regex'</span>)</span><br><span class="line">    <span class="keyword">import</span> regex <span class="keyword">as</span> re</span><br></pre></td></tr></table></figure><br>对于小脚本来说这样就足够了, 项目大的话不建议这样使用</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/ce920ebf.html">http://dynais.xyz/posts/ce920ebf.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某一个虚拟环境中完成脚本后, 想要实际使用时可能会出现错误&lt;br&gt;&lt;div class=&quot;figure center&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210223124433.png?x-oss-process=image/resize,h_2000/quality,q_90&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;&quot; data-caption=&quot;&quot; data-fancybox=&quot;default&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210223124433.png?x-oss-process=image/resize,h_2000/quality,q_90&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;&lt;br&gt;这是由于虚拟环境和运行环境不一致导致依赖库缺失无法&lt;code&gt;import&lt;/code&gt;导致的&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/Python/"/>
    
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>线性回归模型分析</title>
    <link href="http://dynais.xyz/posts/4618ba09.html"/>
    <id>http://dynais.xyz/posts/4618ba09.html</id>
    <published>2021-02-20T23:00:00.000Z</published>
    <updated>2021-02-24T09:10:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h2 id="1-线性回归概述"><a href="#1-线性回归概述" class="headerlink" title="1.线性回归概述"></a>1.线性回归概述</h2><hr><p>线性回归是回归问题中的一种，线性回归假设目标值与特征之间线性相关，即满足一个多元一次方程。通过构建损失函数，来求解损失函数最小时的参数 $w$ 和$b$。通常我们可以表达成如下公式：</p><script type="math/tex; mode=display">\begin{equation}\hat{y} = wX + b \tag{1}\end{equation}</script><p>$\hat{y}$ 为预测值，自变量 $x$ 和因变量 $y$ 是已知的，而我们想实现的是预测新增一个 $x$ ，其对应的 $y$ 是多少。因此，为了构建这个函数关系，目标是通过已知数据点，求解线性模型中 $w$ 和 $b$ 两个参数。</p><p>为此, 线性回归分为两个部分, 向前传播和向后传播, 向前传播负责验证当前参数下对数据的拟合程度, 而向后传播通过在向前传播内得到的数据对参数进行优化</p><hr><a id="more"></a><p><br></p><p><br></p><h2 id="2-向前传播"><a href="#2-向前传播" class="headerlink" title="2.向前传播"></a>2.向前传播</h2><hr><h3 id="2-1-进行数据预处理"><a href="#2-1-进行数据预处理" class="headerlink" title="2.1.进行数据预处理"></a>2.1.进行数据预处理</h3><p>拟合数据之前, 需要对数据先进行预处理</p><h4 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h4><p>参数 $w$ 和 $b$ 对初始化没有特别的需求, 置 $0$ 即可</p><h4 id="特征缩放-均一化"><a href="#特征缩放-均一化" class="headerlink" title="特征缩放/均一化"></a>特征缩放/均一化</h4><p>对于输入特征值矩阵 $X$ 中数据规模差距大的时候, 应该事先对数据进行特征缩放, 此举的目的是为了在计算中使梯度更快的收敛</p><p><br></p><h3 id="2-2-计算预测结果及损失函数"><a href="#2-2-计算预测结果及损失函数" class="headerlink" title="2.2.计算预测结果及损失函数"></a>2.2.计算预测结果及损失函数</h3><p>求解最佳参数，需要一个标准来对结果进行衡量，为此我们需要定量化一个目标函数式，使得计算机可以在求解过程中不断地优化。</p><p>针对任何模型求解问题，都是最终都是可以得到一组预测值 $\hat{y}$ ，对比已有的真实值 $y$ ，数据行数为 $m$ ，可以将损失函数定义如下：</p><script type="math/tex; mode=display">\begin{equation}J = \frac{1}{m}\sum_{i=1}^{m}{(\hat{y_i} - y_i)^2} \tag{2}\end{equation}</script><p>值 $J$ 就代表着当前模型和数据点的偏移程度</p><hr><p><br></p><p><br></p><h2 id="3-向后传播"><a href="#3-向后传播" class="headerlink" title="3.向后传播"></a>3.向后传播</h2><hr><h3 id="3-1-梯度下降"><a href="#3-1-梯度下降" class="headerlink" title="3.1.梯度下降"></a>3.1.梯度下降</h3><p>计算出损失函数之后, 通过使用原有参数减去一个常数与函数求导结果相乘的方式就可以不断地减小损失函数的值, 使参数不断收敛到最佳值, 这种方法在数学上也被称为<strong>最小二乘法</strong>, 在这里我们称为<strong>梯度下降</strong>:</p><script type="math/tex; mode=display">\begin{align*}&w := w - \alpha \cdot dw \tag{3} \\&d := d - \alpha \cdot dw \tag{4} \\\end{align*}</script><h3 id="3-2-学习速率α"><a href="#3-2-学习速率α" class="headerlink" title="3.2.学习速率α"></a>3.2.学习速率α</h3><p>梯度下降算法的每次迭代受到学习率影响, 如果 <strong>$\alpha$ 过小</strong>, 则<strong>达到收敛所需的迭代次数会非常高</strong>; 如果学习率 <strong>$\alpha$ 过大</strong>,每次迭代可能不会减小价函数, 可能越局部最大, 导致<strong>无法收敛</strong></p><p>使用时可以从小到大成倍增加尝试, 如 $0.01, 0.02, 0.04 …$</p><hr><p><br></p><p><br></p><h2 id="4-拓展-多项式回归"><a href="#4-拓展-多项式回归" class="headerlink" title="4.拓展-多项式回归"></a>4.拓展-多项式回归</h2><hr><p>有时候, 预测结果与输入值之间的关系<strong>并非是线性</strong>的, 此时就需要使用<strong>多项式回归</strong>进行拟合</p><p>比如一个二次方模型:</p><script type="math/tex; mode=display">\begin{align*}\hat{y} = w_1 x_1 + w_2 x_2^2 + d \tag{5}\end{align*}</script><p>此时可以使</p><script type="math/tex; mode=display">x_2 = x^2 \tag{6}</script><p>来转化问题成为一个线性回归问题</p><hr><p><br></p><p><br></p><h2 id="5-拓展-正规方程"><a href="#5-拓展-正规方程" class="headerlink" title="5.拓展-正规方程"></a>5.拓展-正规方程</h2><hr><p>通过正规方程可以直接解出向量 $w$, 这种方法适用于样本量不大的情况</p><script type="math/tex; mode=display">w = (X^T X)^{-1} X^T Y \tag{7}</script><hr><p><br></p><p><br></p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><hr><p><a href="tps://www.cnblogs.com/geo-will/p/10468253.html">机器学习 | 算法笔记- 线性回归（Linear Regression）</a></p><hr><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/4618ba09.html">http://dynais.xyz/posts/4618ba09.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性回归是回归问题中的一种，线性回归假设目标值与特征之间线性相关，即满足一个多元一次方程。通过构建损失函数，来求解损失函数最小时的参数 $w$ 和$b$。通常我们可以表达成如下公式：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\hat{y} = wX + b&lt;/script&gt;&lt;p&gt;$\hat{y}$ 为预测值，自变量 $x$ 和因变量 $y$ 是已知的，而我们想实现的是预测新增一个 $x$ ，其对应的 $y$ 是多少。因此，为了构建这个函数关系，目标是通过已知数据点，求解线性模型中 $w$ 和 $b$ 两个参数。&lt;br&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://dynais.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PSpice模拟数据导入Excel工作流</title>
    <link href="http://dynais.xyz/posts/da7f3a9c.html"/>
    <id>http://dynais.xyz/posts/da7f3a9c.html</id>
    <published>2020-12-16T23:00:00.000Z</published>
    <updated>2021-02-24T09:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析</p><p><br></p><p><br></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><hr><p>在 PSpice 得到模拟数据后, 选中需要导出的曲线</p><div class="figure center" style="width:50%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png" style="width:50%;height:50%;"alt=""></a></div><div style="clear:both;"></div><p>看到它变红了</p><p>然后直接 <code>Ctrl + C</code> 就可以获得曲线数据</p><p>然后新建一个文本文档, 复制粘贴保存成 <code>.csv</code> 文件</p><p>直接导入 Excel 应该也是可行的, 但是由于改成了德国的计数方法, 这里的逗号和小数点会有问题, 先导入 csv 文件的话就没问题, 所以还是建议保存到 csv, 这样 Matlab 什么的也能用</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/da7f3a9c.html">http://dynais.xyz/posts/da7f3a9c.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PSpice" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/PSpice/"/>
    
    
      <category term="PSpice" scheme="http://dynais.xyz/tags/PSpice/"/>
    
  </entry>
  
  <entry>
    <title>PSpice中常用的Cursor查询命令</title>
    <link href="http://dynais.xyz/posts/457ee858.html"/>
    <id>http://dynais.xyz/posts/457ee858.html</id>
    <published>2020-12-16T23:00:00.000Z</published>
    <updated>2021-02-21T09:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了</p><p>Orcad Pspice版本: 9.1 Student</p><p>文档进入方法:</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161535.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161535.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>Win10还要上网找一下<strong>win32hlp.exe</strong>装一下才能看, 下载: <a href="http://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/storage/win10%E7%9A%84winhlp32%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%A1%88.zip" target="_blank" rel="noopener"><strong>win32hlp.exe</strong></a></p><p>路径:</p><div class="figure center" style="width:50%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png" style="width:50%;height:50%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><hr><p><code>search    [direction]    [/start_point/]    [#consecutive_points#]    [(range_x [,range_y])]    [for]    [repeat:]    &lt;condition&gt;</code></p><p>能把搜索语法写这么麻烦我真的服</p><p><br/></p><h2 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h2><hr><p>其实语法不需要打全称, 是接收缩写的, 但是文档里一点没说</p><p>常用的是:</p><div class="table-container"><table><thead><tr><th>example</th><th>describtion</th></tr></thead><tbody><tr><td><code>sf xv (这里是数字)</code></td><td>向前找到下一个X坐标最符合当前用户输入数字的点</td></tr><tr><td><code>sf le (这里是数字)</code></td><td>向前找到下一个Y坐标最符合当前用户输入数字的点</td></tr></tbody></table></div><p><code>sf</code> 是 <strong>SerchForword</strong> 的缩写, <code>xv</code> 是 <strong>XValue</strong> 的缩写, <code>le</code> 是 <strong>LEvel</strong> 的缩写</p><p>更加具体的可以在语法里的 <code>&lt;condition&gt;</code> 下找到</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/457ee858.html">http://dynais.xyz/posts/457ee858.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了&lt;/p&gt;
&lt;p&gt;Orcad Pspice版本: 9.1 Student&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="PSpice" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/PSpice/"/>
    
    
      <category term="PSpice" scheme="http://dynais.xyz/tags/PSpice/"/>
    
  </entry>
  
  <entry>
    <title>DuinoAccess</title>
    <link href="http://dynais.xyz/posts/c75b2aac.html"/>
    <id>http://dynais.xyz/posts/c75b2aac.html</id>
    <published>2020-08-19T22:00:00.000Z</published>
    <updated>2021-02-21T09:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 - 前言"></a>0x00 - 前言</h2><hr><p>这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。</p><p>这个项目的一个主要的灵感来源是@<a href="https://space.bilibili.com/20259914/dynamic" target="_blank" rel="noopener">稚晖君</a>很早以前发在Arduino论坛上的一个项目 (<a href="https://www.arduino.cn/thread-86889-1-3.html" target="_blank" rel="noopener">Link: 如何制作一个带指纹识别的机械键盘</a>), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能</p><p>然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目…</p><p>这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：<a href="https://github.com/DynAis/duino-access" target="_blank" rel="noopener">https://github.com/DynAis/duino-access</a></p><a id="more"></a><p><br/></p><p><br/></p><hr><h2 id="0x01-核心部分元器件选型"><a href="#0x01-核心部分元器件选型" class="headerlink" title="0x01 - 核心部分元器件选型"></a>0x01 - 核心部分元器件选型</h2><p>这次的目标是能够使用指纹解锁的方式让电脑自动解锁，思路是使用指纹模块给出信号+单片机模拟键盘输入的简单思路，由于整体的体积要求越小越好，所以元件的选型基本没有选择</p><div class="table-container"><table><thead><tr><th>使用模块</th><th>价格</th></tr></thead><tbody><tr><td>arduino-pro-micro (VCC 5v or 3.3v)</td><td>19.80 CNY</td></tr><tr><td>HN0610 指纹模块</td><td>45.00 CNY</td></tr><tr><td>AMS1117-3.3v/5v 降压模块 (假如使用5v的arduino，3.3v的不需要)</td><td>1.29 CNY</td></tr><tr><td>蜂鸣器、导线若干</td><td>-</td></tr></tbody></table></div><p>之所以没有用稚晖的那个FPM3X指纹模块的原因是因为那个好像在TB上已经快找不到了，只剩下最后一家而且卖的很贵，所以当时就选择了这个卖得最好的来做(有几天自闭的时候非常后悔这个选择)，并且从外观上来说我更喜欢这款一点</p><p><br/></p><p><br/></p><hr><h2 id="0x02-环境选择与搭建"><a href="#0x02-环境选择与搭建" class="headerlink" title="0x02 - 环境选择与搭建"></a>0x02 - 环境选择与搭建</h2><h3 id="VSCode-PlatformIO"><a href="#VSCode-PlatformIO" class="headerlink" title="VSCode + PlatformIO"></a>VSCode + PlatformIO</h3><p>整个环境方面没有使用传统的 ArduinoIDE 来做，而是选择的使用 VSCode 来完成这次的项目，主要原因是为了以后做其他单片机项目的时候也都统一到 VSCode上去，这样整个一致性会比较好</p><p>最后选择了 VSCode 的 PlatformIO 拓展</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184349.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184349.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>直接在 VSCode 的拓展商店里搜索即可，点击安装即可安装插件，不用动什么脑子，安装过程会有些慢需要耐心等待一会，安装完成后如果成功了你应该可以在左下角看到这个小图标</p><div class="figure center" style="width:30%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184359.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184359.png" style="width:30%;height:30%;"alt=""></a></div><div style="clear:both;"></div><p>恭喜，如果你看到了这个小房子，那你基本就是安装成功了，但是由于各种各样的原因，你也很有可能等了半天他也还是在转圈圈加载，像我一样</p><div class="figure center" style="width:90%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184405.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184405.png" style="width:90%;height:90%;"alt=""></a></div><div style="clear:both;"></div><p>那么大概率他是不能自己装上了，我们只能来手动安装</p><p>首先，如果你安装失败了，请先卸载原来的安装失败的 PlatformIO ，重启 VSCode，之后在VSCode的终端里输入</p><p><code>sudo pip --no-cache-dir install -U platformio</code></p><p>等待他安装完成，重启VSCode，重新去商店点一下安装，就可以顺利的装上了</p><div class="alert info"><p>如果依旧不行，可以尝试: 移除Anaconda(假如你安装了Anaconda环境)、安装Python2.7版本并且添加进环境变量、安装Python最新版本并添加进环境变量，如果这也不行，那就尝试使用ArduinoIDE吧(不过这样也许需要稍微改动下代码)</p></div><p><br/></p><h3 id="PlatformIO开发准备"><a href="#PlatformIO开发准备" class="headerlink" title="PlatformIO开发准备"></a>PlatformIO开发准备</h3><p>点击Home按钮打开 PlatformIO 主界面，new project 后选择对应的板子，他会进行自动的初始化</p><div class="figure center" style="width:90%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184414.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184414.png" style="width:90%;height:90%;"alt=""></a></div><div style="clear:both;"></div><p>初始化完成后，在src文件夹里就是我们的main文件</p><div class="figure center" style="width:90%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184421.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184421.png" style="width:90%;height:90%;"alt=""></a></div><div style="clear:both;"></div><p>PlatformIO 和 ArduinoIDE 不同的地方就是，他是使用cpp文件来进行编译上传的，而不是ino文件，所以每个需要用到 Arduino 库的文件中，都需要包含<code>#include &quot;Arduino.h&quot;</code>才能够使用</p><p>此外，比较麻烦的一点是，对于某些库的支持，也是需要我们手动来加入的，比如这块 Pro Micro 支持的HID键盘和鼠标的功能，就需要我们手动加入</p><p>首先打开刚才的Home界面，在左边一栏里可以找到 Libraries</p><div class="figure center" style="width:40%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184426.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184426.png" style="width:40%;height:40%;"alt=""></a></div><div style="clear:both;"></div><p>搜索<code>keyboard</code>，找到这个 Arduino 的官方库文件安装</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184431.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184431.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>安装完成以后，到左边的资源管理器，找到<code>platformio.ini</code>这个文件<div class="figure center" style="width:70%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184436.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184436.png" style="width:70%;height:70%;"alt=""></a></div><div style="clear:both;"></div></p><p>在文件最后加入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lib_deps</span> = </span><br><span class="line">    Keyboard</span><br></pre></td></tr></table></figure><p>告诉他我们要调用这个库，这样就完成了，可以开始硬件部分的测试了</p><p><br/></p><p><br/></p><hr><h2 id="0x03-硬件部分"><a href="#0x03-硬件部分" class="headerlink" title="0x03 - 硬件部分"></a>0x03 - 硬件部分</h2><div class="alert warning"><p>一定要注意指纹模块的供电是3.3v，使用5v虽然不会烧坏模块但是会无法工作(当初因为这个原因卡了好久不知道哪错了)</p></div><p>指纹模块的话是线给剪了直接焊在了板子上，有点粗糙</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184449.jpg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184449.jpg" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>看不清楚的话也可以看源文件里 <code>/lib/HN0610/pinDef.h</code> 里的内容</p><p>最后附上Micro的引脚图</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184454.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184454.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="测试指纹模块"><a href="#测试指纹模块" class="headerlink" title="测试指纹模块"></a>测试指纹模块</h3><p>修改 <code>/src/min.cpp</code> 文件中参数调整宏定义区域的参数  <code>DASTATE</code> 就可以设定当前运行在什么模式下，由于是测试，就把值改为0，运行在检测手指模式上，其他模式的定义也在下面给出</p><div class="table-container"><table><thead><tr><th>功能实现</th><th>DASTATE值</th></tr></thead><tbody><tr><td>检测手指按压</td><td>0</td></tr><tr><td>指纹注册</td><td>1</td></tr><tr><td>验证指纹(最后留这一个)</td><td>2</td></tr><tr><td>检测手指按压后输出硬件信息(需要打开电脑串口)</td><td>3</td></tr><tr><td>清除所有指纹信息</td><td>4</td></tr></tbody></table></div><p> 点击上传烧录进Arduino</p><p>如果没有问题的话，按下手指蜂鸣器就会鸣响了</p><p><br/></p><p><br/></p><hr><h2 id="0x04-遇到的坑和问题"><a href="#0x04-遇到的坑和问题" class="headerlink" title="0x04 - 遇到的坑和问题"></a>0x04 - 遇到的坑和问题</h2><h3 id="1-底层数据类型定义问题"><a href="#1-底层数据类型定义问题" class="headerlink" title="1. 底层数据类型定义问题"></a>1. 底层数据类型定义问题</h3><p>通常来说，开发单片机会定义一系列的UINT</p><p>在这次，定义文件写在了 <code>hzTypes.h</code> 文件里，其中对于UINT32的定义出现了兼容错误</p><p>原始内容是</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184458.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184458.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>我猜测可能是由于他们使用的单片机上int是32位，所以能够正常运行，而在Arduino上，int并不是32位的，long才是，所以需要改为</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184502.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184502.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="2-电源的坑"><a href="#2-电源的坑" class="headerlink" title="2.电源的坑"></a>2.电源的坑</h3><p>已经说过了，不过这次也是因为在家里没有万用表的缘故，并且提醒，虽然原理图上有一个SJ1来控制Micro的输出电压是5v还是3.3v，但是你并不可以通过连接或者断开这个引脚来达到修改电压的目的，因为5v的Micro和3.3v的Micro主频也是不一样的，这会导致工作不稳定</p><p>并且很有可能改了也没有作用(对于很多国产板)</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184513.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184513.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="3-注意Micro的中断脚"><a href="#3-注意Micro的中断脚" class="headerlink" title="3.注意Micro的中断脚"></a>3.注意Micro的中断脚</h3><p>因为这个指纹识别模块还有自动休眠的功能，所以虽然我现在并没有使用，但是很有可能会用到这个模块的中断信号，那么就要注意Micro的中断引脚定义和Uno是不一样的</p><div class="table-container"><table><thead><tr><th>PIN</th><th>中断号</th></tr></thead><tbody><tr><td>3</td><td>0</td></tr><tr><td>2</td><td>1</td></tr><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>3</td></tr><tr><td>7</td><td>6</td></tr></tbody></table></div><p><br/></p><p><br/></p><hr><h2 id="0x05-后续开发"><a href="#0x05-后续开发" class="headerlink" title="0x05 - 后续开发"></a>0x05 - 后续开发</h2><h3 id="库HN610"><a href="#库HN610" class="headerlink" title="库HN610"></a>库HN610</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>内容</th></tr></thead><tbody><tr><td>auth</td><td>通讯签名算法(默认不签名)</td></tr><tr><td>fp</td><td>大部分能直接用的API</td></tr><tr><td>fpmComm</td><td>模块命令API</td></tr><tr><td>hzDevice</td><td>串口通信底层</td></tr><tr><td>pinDef</td><td>主板引脚定义</td></tr><tr><td>hzTypes</td><td>数据类型定义</td></tr></tbody></table></div><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/c75b2aac.html">http://dynais.xyz/posts/c75b2aac.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。&lt;/p&gt;
&lt;p&gt;这个项目的一个主要的灵感来源是@&lt;a href=&quot;https://space.bilibili.com/20259914/dynamic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;稚晖君&lt;/a&gt;很早以前发在Arduino论坛上的一个项目 (&lt;a href=&quot;https://www.arduino.cn/thread-86889-1-3.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link: 如何制作一个带指纹识别的机械键盘&lt;/a&gt;), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能&lt;/p&gt;
&lt;p&gt;然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目…&lt;/p&gt;
&lt;p&gt;这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：&lt;a href=&quot;https://github.com/DynAis/duino-access&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/DynAis/duino-access&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="duino-access" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/duino-access/"/>
    
    
      <category term="单片机" scheme="http://dynais.xyz/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="Arduino" scheme="http://dynais.xyz/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>[转载]Hexo+Github Page搭建博客教程</title>
    <link href="http://dynais.xyz/posts/4f8b0717.html"/>
    <id>http://dynais.xyz/posts/4f8b0717.html</id>
    <published>2020-07-23T08:40:06.000Z</published>
    <updated>2021-02-24T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">前往原文</a></strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。</p><p>这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p><p>下面就开始吧~</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>准备 node 和 git 环境，<br>首先，安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a>，因为 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。<br>然后，安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git</a> 教程。</p><a id="more"></a><p>两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。<br>在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011037" alt="image"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 的详细文档。<br>在命令行输入执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds # 模版文件夹</span><br><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br><span class="line">|   ├── _drafts # 草稿文件</span><br><span class="line">|   └── _posts # 文章Markdowm文件 </span><br><span class="line">└── themes  # 主题文件夹</span><br></pre></td></tr></table></figure><p>好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:4000 回车就可以预览效果了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011041" alt="image"></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。</p><h2 id="注册-Github"><a href="#注册-Github" class="headerlink" title="注册 Github"></a>注册 Github</h2><p>首先如果你还没有 Github 账号的先<a href="https://github.com/" target="_blank" rel="noopener">注册</a>一个，具体过程如下</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011044" alt="image"></p><p>点击 Start project 或者下面的 new repository 创建一个新的仓库</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011052" alt="image"></p><p>注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011055" alt="image"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World.</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011058" alt="image"><br><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011100" alt="image"></p><p>这个时候打开 <a href="http://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">http://你的用户名.github.io</a> 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 <a href="http://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">http://你的用户名.github.io</a> 看到你自己的博客啦！ 比如我的就是 <a href="http://webw3c.github.io/" target="_blank" rel="noopener">http://webw3c.github.io</a> 了。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011103" alt="image"></p><h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p><p>打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011105" alt="image"></p><p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>然后开始生成密钥 SSH key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;上面的邮箱&#39;</span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011106" alt="image"></p><p>（此图引用自码云）</p><p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011109" alt="image"></p><p>到这还没完，还要登录 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上添加刚刚生成的SSH key，按以下步骤添加：</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011110" alt="image"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011112" alt="image"></p><h2 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h2><p>此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">部署</a>教程。<br>先不着急，部署之前还需要修改配置和安装部署插件。<br>第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011114" alt="image"></p><p>第二：要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <a href="https://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">https://你的用户名.github.io</a> 就会看到你的博客啦！！</p><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> 官网。<br>新建文章，输入以下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span><br></pre></td></tr></table></figure><p>执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。</p><p>在 Markdown 文章里面输入你的文章内容</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011117" alt="image"></p><p>再执行一下以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以看到你的文章在博客显示了，以下就是刚刚</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011119" alt="image"></p><p>最后，只要部署到你的 Github 上就可以了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="静态图床"><a href="#静态图床" class="headerlink" title="静态图床"></a>静态图床</h2><p>文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是<a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules" target="_blank" rel="noopener">测试域名</a>不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。</p><p>可以去chrome网上应用商店下载一个叫<a href="https://chrome.google.com/webstore/detail/微博图床/pinjkilghdfhnkibhcangnpmcpdpmehk?hl=zh-CN" target="_blank" rel="noopener">微博图床</a>的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011122" alt="image"></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题页</a>或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官网使用文档</a>说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。</p><h3 id="一、添加评论系统"><a href="#一、添加评论系统" class="headerlink" title="一、添加评论系统"></a><strong>一、添加评论系统</strong></h3><p><strong><em>注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置\</em></strong></p><p>添加 <a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a> 评论系统，打开 /themes/next/_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011125" alt="image"></p><p>然后到 leanCloud <a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">登录</a>或者<a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册</a> 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011127" alt="image"></p><h3 id="二、配置腾讯公益404页面"><a href="#二、配置腾讯公益404页面" class="headerlink" title="二、配置腾讯公益404页面"></a><strong>二、配置腾讯公益404页面</strong></h3><ol><li>在博客根目录 /source 文件夹下创建404.html（具体内容见下图及代码）；</li><li>在 html 上方加入上面3行代码；</li></ol><p>腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011129" alt="image"></p><p>上图最前面的那几行也要加进去哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">title: &quot;404&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这里放一下上面用到的几个js链接，来自腾讯公益404官方<a href="https://www.qq.com/404/" target="_blank" rel="noopener">接入文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;plain&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;https:&#x2F;&#x2F;pojian.xyz&quot; homePageName&#x3D;&quot;回到我的博客主页&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;data.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;page.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>你也可以直接复制我 Github 上的<a href="https://github.com/webw3c/webw3c.github.io/blob/master/404.html" target="_blank" rel="noopener">404页面代码</a>，以下是我博客的预览效果。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011131" alt="image"></p><p>另外如果需要自定义个性化404页面的只要删除相应腾讯的JS，直接修改上面的 404.html 文件就可以了。</p><h3 id="三、添加字数统计和阅读时长"><a href="#三、添加字数统计和阅读时长" class="headerlink" title="三、添加字数统计和阅读时长"></a><strong>三、添加字数统计和阅读时长</strong></h3><p>首先安装一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>接着博客根目录下的配置文件里添加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文章字数统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure><p>最后到 next 主题的配置文件下开启 symbols_count_time 字段</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011133" alt="image"></p><p>重启一下 hexo 就可以看到效果啦</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011135" alt="image"></p><h3 id="四、开启fancybox"><a href="#四、开启fancybox" class="headerlink" title="四、开启fancybox"></a><strong>四、开启fancybox</strong></h3><p>打开主题配置文件搜索 fancybox 设置为 true，另外，vendors 填上对应 CDN 地址即可开启</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011137" alt="image"></p><h3 id="五、文章分享"><a href="#五、文章分享" class="headerlink" title="五、文章分享"></a><strong>五、文章分享</strong></h3><p>百度分享有个 https 的坑，按网上的方法把文件放到自己的服务器是我以前在其他的网站上测试过是能使用的，但在 hexo 中却报错了，具体不清楚是什么原因，感觉可能是 hexo 版本的问题，因为有的人可以，有的人报和我一样的错误，忘记截图了。因为这个功能也没有十分需要，就不继续爬了。换了 <a href="https://github.com/overtrue/share.js" target="_blank" rel="noopener">share.js</a> 实现了同样的功能，具体可以看本文文末的效果。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>如果你感觉直接使用 github.io 的域名作为你的博客链接不够专业，不够程序员的话那么就购买一个域名解析绑定到你的博客，我也比较建议这样做。<br>我的是在阿里万网<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.17.365b4f157s4Od7" target="_blank" rel="noopener">注册</a>的，注册流程比较常规这里就不多详述了，</p><p>注册登录控制台后找到你的域名，点右侧的解析按钮进去解析列表</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011140" alt="image"><br><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011142" alt="image"></p><p>点右边的“添加记录”添加两条 CNAME 类型的记录，如上图，后面的记录值就填写你们自己的 Github 地址哈</p><p>记录添加完后就要到 <a href="https://www.github.com/" target="_blank" rel="noopener">Github</a> 设置绑定你购买的域名了，进入你的博客仓库点 Setting，然后拉到 GitHub Pages 那里填上你的申请购买的域名保存就可以了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011144" alt="image"><br><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011145" alt="image"></p><p>这里说下，当你点击保存的时候 Github Pages 会自动帮你生成一个 CNAME 的文件在根目录，里面的内容就是你绑定的域名地址</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011148" alt="image"></p><p>注意，如果是按上面的方法操作还会有一点小问题，就是当你执行 hexo d 部署你本地的文章到 Github 时，你本地的文件会全部覆盖掉你现有仓库上的所有内容，包括 Github Pages 帮你创建的那个 CNAME 文件，这样的话当你访问域名的时候又会访问不到了。所以呢，你需要自己手动在本地根目录 /source 目录下手动创建一个 CNAME 文件，内容就是你的域名地址，因为 source 目录下的文件部署的时候是不会被删除的，所以部署的时候也会一起被部署上去，最后还需要重新到你仓库 Setting，拉到 GitHub Pages 那里再一次绑定你的域名，这样以后就没问题了。</p><p>稍等一会就可以用你申请的域名就访问你的博客了！</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>接下来说下百度收录，据说 Github 屏蔽了百度的蜘蛛，也有的人说没，具体不是很清楚，Github 在2015的时候遭受了史上最大规模的DDoS攻击，有国外媒体指百度干的，具体不得而知啦，但感觉百度收录 Github 确认是比较难，时间也比较长，所以还是优化一下吧。</p><h3 id="一、代码同时部署到-coding"><a href="#一、代码同时部署到-coding" class="headerlink" title="一、代码同时部署到 coding"></a>一、代码同时部署到 coding</h3><p>那有什么方法呢？就是把博客站点同时托管在国内的 coding 平台上，这样收录就会容易很多，同时又不影响 Github 上的代码，<a href="https://coding.net/" target="_blank" rel="noopener">coding</a> 是国内的一个提供代码托管服务的平台，跟 Github 差不多。使用方法也和 Github 差不多，下面我就具体说一下怎么把代码同时部署到 coding 和 Github 上面，让百度更容易收录。</p><p><a href="https://coding.net/register" target="_blank" rel="noopener">注册</a>、<a href="https://coding.net/login" target="_blank" rel="noopener">登录</a> coding 后创建一个新的仓库，注意点就是新建项目的时候命名规则和 Github 上的一样，就是 <strong>用户名.coding.me</strong> 可以看下图，还有记得别忘了添加 SSH key</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011150" alt="image"></p><p>仓库建好后进入仓库，选左侧的 Page 服务，在设置中绑定新的域名，输入后点击绑定就可以了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011152" alt="image"></p><p>接着到你的域名解析控制台修改添加两条 CNAME 记录指向你的 Page 地址，看下图，注意看记录值哦，换成你自己的。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011155" alt="image"></p><p>最后呢修改根目录下的 _config.yml 配置文件中的部署配置，把 coding 的 git 地址添加进去就行了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011156" alt="image"></p><p>最后执行部署命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>这时就可以在 coding 仓库中看到你提交部署的代码了，同时 你的用户名.coding.me 也可以访问你的博客站点了，这里 Github 和 coding 的代码是同时更新的，互不影响。而绑定的域名解析可能需要稍等一会才会生效。</p><h3 id="二、百度提交链接"><a href="#二、百度提交链接" class="headerlink" title="二、百度提交链接"></a>二、百度提交链接</h3><p>部署到 coding 后也不是百度就可以收录的，我们还需要继续优化。如果在百度搜索输入 site:你的域名 如果出现以下的效果证明就是网站还没被百度收录的，我们现在点下面的<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">提交网址</a>，进入百度站长工具提交。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011159" alt="image"></p><h3 id="三、百度站长平台添加网站管理"><a href="#三、百度站长平台添加网站管理" class="headerlink" title="三、百度站长平台添加网站管理"></a>三、百度站长平台添加网站管理</h3><p>注册<a href="https://ziyuan.baidu.com/site/" target="_blank" rel="noopener">百度站长</a>工具，并添加网站</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011201" alt="image"></p><p>添加网站的过程有三步，主要操作集中在最后一步的网站验证方式里，我选择的是 HTML标签验证，按下面使用方法添加代码到你的网站即可</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011203" alt="image"></p><p>而使用 next 主题的同学可以直接在主题的配置文件下搜索 baidu_site_verification 后面填上第三步中 meta 标签中 content 的值就可以</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011205" alt="image"></p><p>最后点完成验证就可以通过了。</p><h3 id="四、添加sitemap站点地图"><a href="#四、添加sitemap站点地图" class="headerlink" title="四、添加sitemap站点地图"></a>四、添加sitemap站点地图</h3><p>站点地图包含了你网站上的站点链接，方便搜索引擎蜘蛛的抓取工作，搜索蜘蛛会通过网站地图中链接的深层次爬行，抓取新的内容。所以我们要生成 sitemap 文件助于网站优化，安装生成插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>接着在博客根目录下的配置文件里添加对应配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>注意缩进，要不会编译报错</p><p>还要修改一个根目录配置文件下的URL，url 一项的值改成你在百度站长平台里面添加的自己站点的地址，这样生成的 sitemap.xml 文件里的 url 才是你站点的地址，看下图</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011208" alt="image"></p><h3 id="五、添加蜘蛛协议robots-txt"><a href="#五、添加蜘蛛协议robots-txt" class="headerlink" title="五、添加蜘蛛协议robots.txt"></a>五、添加蜘蛛协议robots.txt</h3><p>增加 robots.txt 文件，就是蜘蛛协议，新建 robots.txt 文件添加以下内容，把 robots.txt 放在 /source 文件下，我们前面说过 /source 目录下的文件是会被打包上传的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;pojian.xyz&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;pojian.xyz&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow后面的就是你的menu，还有最下面的 Sitemap 地址请自行改成你们自己的地址</p><p>完成后，重启hexo，执行 hexo g -d 重新生成文件并提交后，在public目录下会生成对应的xml文件。可以通过 <a href="http://xxx.com/sitemap.xml" target="_blank" rel="noopener">http://xxx.com/sitemap.xml</a> 和 <a href="http://xxx.com/baidusitemap.xml" target="_blank" rel="noopener">http://xxx.com/baidusitemap.xml</a> 访问到 sitemap 文件，通过 <a href="http://xxx.com/robots.txt" target="_blank" rel="noopener">http://xxx.com/robots.txt</a> 访问到 robots.txt 文件。</p><p>可以到百度站长检测一下 robots.txt 文件是否生效</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011210" alt="image"></p><h3 id="六、自动推送"><a href="#六、自动推送" class="headerlink" title="六、自动推送"></a>六、自动推送</h3><p>百度有自动推送、主动推送、sitemap、手动提交几种方式。<br>自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。怎么安装呢？<br>如果你的是 next 主题，只要打开主题配置文件搜索找到 baidu_push 设置为 true 即可</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011213" alt="image"></p><p>如果你使用的不是 next 主题，也可以手动把以下代码粘贴到你的站点，一般放在 head 头部公共文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="七、主动推送"><a href="#七、主动推送" class="headerlink" title="七、主动推送"></a>七、主动推送</h3><p>这里利用一个第三方插件 <a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">hexo-baidu-url-submit</a> 进行主动推送<br>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>添加想关配置到根目录下的配置文件里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 百度链接提交-主动推送配置</span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3 ## 提交最新的一个链接</span><br><span class="line">  host: pojian.xyz ## 在百度站长平台中注册的域名</span><br><span class="line">  token: 3GIEYsuq5ZTkvDBm ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p>添加新的部署配置，注意这里跟之前有点不一样，要在 type 前添加一个破折号 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      github: https:&#x2F;&#x2F;github.com&#x2F;webw3c&#x2F;webw3c.github.io.git</span><br><span class="line">      coding: https:&#x2F;&#x2F;git.dev.tencent.com&#x2F;yusting&#x2F;yusting.coding.me.git</span><br><span class="line">  - type: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>最后，执行 hexo deploy 的时候，新的连接就会被推送了。<br><strong>实现原理</strong><br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="八、手动推送"><a href="#八、手动推送" class="headerlink" title="八、手动推送"></a>八、手动推送</h3><p>就是直接直接把你需要提交的链接直接使用手动的方式填写提交就可以。</p><p>最后你可以看到是否已经被百度成功收录了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011216" alt="image"></p><p>如果抓取成功了就证明已经被收录了，好像一般不会这么快，我的等了两天左右才抓取得到。</p><h3 id="九、添加百度统计"><a href="#九、添加百度统计" class="headerlink" title="九、添加百度统计"></a>九、添加百度统计</h3><p>添加<a href="https://tongji.baidu.com/web/homepage/index" target="_blank" rel="noopener">百度统计</a>就可以查看你网站相关的一些数据，便于你自己的站点</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011221" alt="image"></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011218" alt="image"></p><h2 id="多端同步写作"><a href="#多端同步写作" class="headerlink" title="多端同步写作"></a>多端同步写作</h2><p>原理就是利用 Git 的分支功能，比如新建立一个 blog 分支来存放 Hexo 的源文件，而 master 分支则用来放编译后的静态文件，这样在使用另外一台电脑编写的时候只要把 blog 分支拉取下来然后进行写作再 push 到分支就可以了。具体内容或者步骤后续会有更新。。。</p><h2 id="手机编写"><a href="#手机编写" class="headerlink" title="手机编写"></a>手机编写</h2><p>网上好像找不到什么资料，不过通过在手机端安装 SSH 客户端远程操作服务器端，安装配置 node / git / hexo 环境编写应该可以的，原理同多台电脑编写差不多，不过这样做不太省心，不折腾了哈。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章到这差不多啦！后续有些小点深入学习后还是会保持更新的，希望文章对曾经像我一样的小白有那么一点帮助，技术有限，难免有纰漏，欢迎指正批评和讨论，感谢阅读！:-)</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/4f8b0717.html">http://dynais.xyz/posts/4f8b0717.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000017986794&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前往原文&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。&lt;/p&gt;
&lt;p&gt;这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。&lt;/p&gt;
&lt;p&gt;下面就开始吧~&lt;/p&gt;
&lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;p&gt;准备 node 和 git 环境，&lt;br&gt;首先，安装 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NodeJS&lt;/a&gt;，因为 &lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。&lt;br&gt;然后，安装 &lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git&lt;/a&gt;，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt; 教程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/my-blog/"/>
    
    
      <category term="Hexo" scheme="http://dynais.xyz/tags/Hexo/"/>
    
      <category term="github-page" scheme="http://dynais.xyz/tags/github-page/"/>
    
  </entry>
  
  <entry>
    <title>使用差分散列的重复图片检测</title>
    <link href="http://dynais.xyz/posts/a33aff37.html"/>
    <id>http://dynais.xyz/posts/a33aff37.html</id>
    <published>2020-04-21T22:00:00.000Z</published>
    <updated>2021-02-21T10:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning"><a href="#Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning" class="headerlink" title="Detect and remove duplicate images from a dataset for deep learning"></a>Detect and remove duplicate images from a dataset for deep learning</h2><!-- toc --><blockquote><p>文章链接:</p><p><a href="https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/</a></p><p><a href="https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb" target="_blank" rel="noopener">https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb</a></p><p>前言: </p><p>为什么要删去数据集中重复的图片?</p><p><em>Having duplicate images in your dataset creates a problem for two reasons:</em></p><ol><li><em>It introduces bias into your dataset, giving your deep neural network additional opportunities to learn patterns specific to the duplicates</em></li><li><em>It hurts the ability of your model to generalize to new images outside of what it was trained on</em></li></ol><p><em>Take the time to remove duplicates from your image dataset so you don’t accidentally introduce bias or hurt the ability of your model to generalize.</em></p></blockquote><a id="more"></a><h2 id="一-关于图像散列值"><a href="#一-关于图像散列值" class="headerlink" title="一. 关于图像散列值"></a>一. 关于图像散列值</h2><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010512.png" alt="img" style="zoom: 67%;" /></p><p>关于散列(Hash), 网上的介绍有很多,这里就不费力介绍.</p><p>而对于这个具体的项目要求来说, 我们所做的只是需要把一个图像转换为一个Hash值, 然后储存到字典中. 并且有一下要求:</p><ul><li>视觉上相差不大的图片, 他们的Hash值也应该相同</li><li>这个Hash计算需要快, 因为有时候数据量会很大</li></ul><p>那么我们有以下几个Hash函数的选择:</p><ul><li><strong>差分散列(<em>difference hashing</em>)</strong></li><li><strong>md5</strong></li><li><strong>sha-1</strong></li></ul><p>最终我们选择了<strong>差分散列</strong>的方法, 有以下的原因:</p><ol><li>差分散列速度很快, 计算量小</li><li>对于肉眼相差不大的图片, 差分散列可以得出相似的值</li><li>md5 和 sha-1 只要有一点变化, 输出值就会完全改变(这本来很好, 但在这里非常不好!)</li></ol><h2 id="二-我们所需的步骤"><a href="#二-我们所需的步骤" class="headerlink" title="二. 我们所需的步骤"></a>二. 我们所需的步骤</h2><h3 id="1-Convert-to-grayscale-转灰度"><a href="#1-Convert-to-grayscale-转灰度" class="headerlink" title="1. Convert to grayscale 转灰度"></a>1. Convert to grayscale 转灰度</h3><p>在这里, 颜色信息对于判定两张图是否相同其实并不是很重要, 所以将三通道转为一个通道可以很好的减少我们的工作量</p><h3 id="2-Resize-忽略长宽比缩放"><a href="#2-Resize-忽略长宽比缩放" class="headerlink" title="2. Resize 忽略长宽比缩放"></a>2. Resize 忽略长宽比缩放</h3><p>这是为了得到一个合适的大小, 以便符合后续的Hash计算, 所有需要保证所有的图片具有相同的大小尺寸, 这牵扯到差分散列的工作原理, 这会在后面解释</p><p>在这里, 我们需要将原图缩放到只有$ 9 * 8 $大小</p><h3 id="3-Compute-the-difference-计算差分-梯度"><a href="#3-Compute-the-difference-计算差分-梯度" class="headerlink" title="3. Compute the difference 计算差分(梯度)"></a>3. Compute the difference 计算差分(梯度)</h3><p>差分散列算法, 故名思与需要计算差分信息, 在图片里, 指的就是相邻像素之间的梯度.</p><p>好了, 这就是之前我们为什么需要 $ 9 * 8 $ 像素的原因了</p><p>因为我们需要得到的是一个64位的二进制信息, 而 $8 * 8=64$ , 由于是计算差分(梯度), 所以必然需要九行</p><p><strong>需要注意:</strong> 这里虽然说是差分, 但实际上使用的是非常简化的版本: 但前一个像素大于后一个像素时, 给出一个$1$, 否则, 给出一个$0$, 也就是说, 可以看作只提取梯度的正负符号信息, 公式为 </p><p>​                                                $P[x] &gt; P[x + 1] = 1 else 0$</p><p>那么现在我们得到了一个64bit的值, 接下来就对他进行Hash计算</p><h3 id="4-Build-the-hash-计算散列值"><a href="#4-Build-the-hash-计算散列值" class="headerlink" title="4. Build the hash 计算散列值"></a>4. Build the hash 计算散列值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dhash</span><span class="params">(image, hashSize=<span class="number">8</span>)</span>:</span></span><br><span class="line"><span class="comment"># convert the image to grayscale and resize the grayscale image,</span></span><br><span class="line"><span class="comment"># adding a single column (width) so we can compute the horizontal</span></span><br><span class="line"><span class="comment"># gradient</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">resized = cv2.resize(gray, (hashSize + <span class="number">1</span>, hashSize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute the (relative) horizontal gradient between adjacent</span></span><br><span class="line"><span class="comment"># column pixels</span></span><br><span class="line">diff = resized[:, <span class="number">1</span>:] &gt; resized[:, :<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert the difference image to a hash and return it</span></span><br><span class="line"><span class="keyword">return</span> sum([<span class="number">2</span> ** i <span class="keyword">for</span> (i, v) <span class="keyword">in</span> enumerate(diff.flatten()) <span class="keyword">if</span> v])</span><br></pre></td></tr></table></figure><h3 id="5-初始化字典-寻找重复并输出"><a href="#5-初始化字典-寻找重复并输出" class="headerlink" title="5. 初始化字典, 寻找重复并输出"></a>5. 初始化字典, 寻找重复并输出</h3><p>略</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/a33aff37.html">http://dynais.xyz/posts/a33aff37.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于散列(Hash), 网上的介绍有很多,这里就不费力介绍.&lt;/p&gt;
&lt;p&gt;而对于这个具体的项目要求来说, 我们所做的只是需要把一个图像转换为一个Hash值, 然后储存到字典中. 并且有一下要求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;视觉上相差不大的图片, 他们的Hash值也应该相同&lt;/li&gt;
&lt;li&gt;这个Hash计算需要快, 因为有时候数据量会很大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么我们有以下几个Hash函数的选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;差分散列(&lt;em&gt;difference hashing&lt;/em&gt;)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;md5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sha-1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终我们选择了&lt;strong&gt;差分散列&lt;/strong&gt;的方法, 有以下的原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;差分散列速度很快, 计算量小&lt;/li&gt;
&lt;li&gt;对于肉眼相差不大的图片, 差分散列可以得出相似的值&lt;/li&gt;
&lt;li&gt;md5 和 sha-1 只要有一点变化, 输出值就会完全改变(这本来很好, 但在这里非常不好!)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>重构完成, 焕发新生</title>
    <link href="http://dynais.xyz/posts/237b1f9f.html"/>
    <id>http://dynais.xyz/posts/237b1f9f.html</id>
    <published>2020-04-18T22:00:00.000Z</published>
    <updated>2021-02-21T10:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li><p>重构了代码</p></li><li><p>修正了大部分bug</p></li></ul><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-Qtimer"><a href="#1-Qtimer" class="headerlink" title="1. Qtimer"></a>1. Qtimer</h3><blockquote><p><a href="https://blog.csdn.net/jia666666/article/details/81672344" target="_blank" rel="noopener">https://blog.csdn.net/jia666666/article/details/81672344</a></p></blockquote><p>Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式</p><h5 id="多次触发"><a href="#多次触发" class="headerlink" title="多次触发"></a>多次触发</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer.timeout.connect(function)</span><br><span class="line">...</span><br><span class="line">timer = Qtimer()</span><br><span class="line">timer.start(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这里<code>timeout</code>是Qtimer的中断信号, 这里设定<code>timer.start(1000)</code>代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块</p><a id="more"></a><p>如果要停止Qtimer,使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer.stop()</span><br></pre></td></tr></table></figure><h3 id="2-自定义信号"><a href="#2-自定义信号" class="headerlink" title="2. 自定义信号"></a>2. 自定义信号</h3><blockquote><p> <a href="https://blog.csdn.net/foreveronly/article/details/82453697" target="_blank" rel="noopener">https://blog.csdn.net/foreveronly/article/details/82453697</a></p></blockquote><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>加完Qtimer中断完全没有问题</p><h3 id="3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug"><a href="#3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug" class="headerlink" title="3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug"></a>3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug</h3><p>通过将子窗口变为主窗口类的成员, 并使用以下语句初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment">#子窗口建立</span></span><br><span class="line">        self.subBreak = BreakWindow(self)<span class="comment"># 注意这里</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreakWindow</span><span class="params">(QDialog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,parent=None)</span>:</span></span><br><span class="line">        super().__init__(parent)</span><br></pre></td></tr></table></figure><p>关键也就是加入<code>def __init__(self,parent=None)</code>, 使主从窗口关联起来(具体实现逻辑尚不清晰), 再加上合理的退出判断, 就可以实现干净的退出了</p><p>响铃bug加完Qtimer中断完后全没有问题</p><h3 id="4-占用cpu过高问题"><a href="#4-占用cpu过高问题" class="headerlink" title="4. 占用cpu过高问题"></a>4. 占用cpu过高问题</h3><p>加完Qtimer中断完全没有问题</p><h3 id="5-交互逻辑混乱问题"><a href="#5-交互逻辑混乱问题" class="headerlink" title="5. 交互逻辑混乱问题"></a>5. 交互逻辑混乱问题</h3><p>通过重构代码逻辑解决了, 现在所有的子窗口都是主窗口的成员了</p><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#1-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="1. Qt里写了中文uic()命令就无法成功执行的问题"></a>1. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>暂时没有思路</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><h3 id="1-实现使用时间的统计模块-尝试使用Mysql来储存数据"><a href="#1-实现使用时间的统计模块-尝试使用Mysql来储存数据" class="headerlink" title="1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据?"></a>1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据?</h3><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>再此理解了那句话, 不能让程序假死, 比如之前我想要time.sleep()来实现…</p><p>正确使用中断是很重要的, 这方面还要多加练习</p><p>并且另外很重要的一点就是, 使用一个库里现成的东西往往整个的整合度会更好</p><p>本来甚至都准备上多线程了…</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/237b1f9f.html">http://dynais.xyz/posts/237b1f9f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重构了代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修正了大部分bug&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-重要代码模块&quot;&gt;&lt;a href=&quot;#一-重要代码模块&quot; class=&quot;headerlink&quot; title=&quot;一. 重要代码模块&quot;&gt;&lt;/a&gt;一. 重要代码模块&lt;/h2&gt;&lt;h3 id=&quot;1-Qtimer&quot;&gt;&lt;a href=&quot;#1-Qtimer&quot; class=&quot;headerlink&quot; title=&quot;1. Qtimer&quot;&gt;&lt;/a&gt;1. Qtimer&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jia666666/article/details/81672344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jia666666/article/details/81672344&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式&lt;/p&gt;
&lt;h5 id=&quot;多次触发&quot;&gt;&lt;a href=&quot;#多次触发&quot; class=&quot;headerlink&quot; title=&quot;多次触发&quot;&gt;&lt;/a&gt;多次触发&lt;/h5&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;timer.timeout.connect(function)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer = Qtimer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer.start(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;timeout&lt;/code&gt;是Qtimer的中断信号, 这里设定&lt;code&gt;timer.start(1000)&lt;/code&gt;代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>又不是不能用, 番茄钟基本功能建设完毕</title>
    <link href="http://dynais.xyz/posts/f3590d7f.html"/>
    <id>http://dynais.xyz/posts/f3590d7f.html</id>
    <published>2020-04-11T22:00:00.000Z</published>
    <updated>2021-02-21T10:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li>加入了自己指定时间的模块</li></ul><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010843.png" alt="image-20200412153655534" style="zoom:50%;" /></p><ul><li>加入保存用户设置的文件<code>config.json</code></li><li>在倒计时结束时发出铃声通知</li><li>完善了除统计和To Do List外的Menu界面</li></ul><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010845.png" alt="image-20200412153753123" style="zoom:50%;" /></p><ul><li>修正了部分bug</li></ul><a id="more"></a><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-打包程序成exe文件"><a href="#1-打包程序成exe文件" class="headerlink" title="1. 打包程序成exe文件"></a>1. 打包程序成exe文件</h3><h5 id="pyInstaller模块"><a href="#pyInstaller模块" class="headerlink" title="pyInstaller模块"></a>pyInstaller模块</h5><p><code>pyInstaller</code>是python的一个库, 使用它可以很方便的打包文件成为exe可执行文件</p><p>要使用这个库, 首先在Pycharm里安装相应的环境, 之后新建一个.py文件, 比如我的:</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010847.png" alt="image-20200412160718129"></p><p>在里面输入代码(以这次工程为例):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> PyInstaller.__main__ <span class="keyword">import</span> run</span><br><span class="line">    opts=[<span class="string">'main.py'</span>,<span class="string">'-w'</span>,<span class="string">'-F'</span>,<span class="string">'--icon=image/tomato.ico'</span>]</span><br><span class="line">    run(opts)</span><br></pre></td></tr></table></figure><p>其中主要注意<code>opts=[&#39;main.py&#39;,&#39;-w&#39;,&#39;-F&#39;,&#39;--icon=image/tomato.ico&#39;]</code>这一句</p><p><code>main.py</code>是主文件, 是进程的入口</p><p><code>-w</code>这个参数使编译出来的文件时<code>exe</code>+<code>文件</code>的形式, 去掉这个参数编译出来是一个整体的<code>exe</code>文件</p><p><code>-F</code>参数强制编译, 也就是说本次会覆盖上次的文件, 我觉得加上比较好</p><p>最后<code>--icon=image/tomato.ico</code>是我指定的exe文件图标, 需要是一个<code>ico</code>文件</p><p>直接运行<code>.py</code>脚本就可以在<code>/dist</code>里得到编译的文件</p><h5 id="资源文件夹问题"><a href="#资源文件夹问题" class="headerlink" title="资源文件夹问题"></a>资源文件夹问题</h5><p>本次制作番茄钟使用到的资源文件, 比如配置文件, 或者是<code>.MP3</code>的铃声文件, pyInstaller在编译的时候都是不会编译的, 也就是说需要自己将文件复制到产生出来的目录下, 不然程序会报错无法运行</p><h3 id="2-读取和写入配置文件"><a href="#2-读取和写入配置文件" class="headerlink" title="2. 读取和写入配置文件"></a>2. 读取和写入配置文件</h3><h5 id="使用Json作为配置文件"><a href="#使用Json作为配置文件" class="headerlink" title="使用Json作为配置文件"></a>使用Json作为配置文件</h5><p>Json是一种常见的语言, 其中一种用法就是作为书写配置文件的语言, 虽然有人说它不适合作为配置文件语言, 但是小项目用用还是没有问题的</p><p>Json配置文件以<code>{</code>开头, 以<code>}</code>结束, 大括号在Json里代表一个对象, 具有一个键与一个值, 用<code>:</code>对应,</p><p>可以理解为Python里的字典(其实就是)</p><p>用Python的语法来看Json没有一点问题</p><p>如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"tomato"</span>: &#123;<span class="attr">"t_target"</span>: <span class="string">"00:05"</span>, <span class="attr">"t_break"</span>: <span class="string">"00:05"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是Json对语法的要求非常严格, 并且不可以有注释</p><h5 id="Python3读取Json文件"><a href="#Python3读取Json文件" class="headerlink" title="Python3读取Json文件"></a>Python3读取Json文件</h5><p>Python官方内置了Json的使用库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设config是一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Json读取</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"config.json"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> c:</span><br><span class="line">    config = json.load(c)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Json写入</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"config.json"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> c:</span><br><span class="line">    json.dump(config, c)</span><br></pre></td></tr></table></figure><p>读取文件以字典形式展现, 写入的变量也需要是一个字典</p><h3 id="3-在对象方法定义里直接调用具体的实例"><a href="#3-在对象方法定义里直接调用具体的实例" class="headerlink" title="3. 在对象方法定义里直接调用具体的实例"></a>3. 在对象方法定义里直接调用具体的实例</h3><p>发现在对象的方法定义里, 可以直接调用看起来还没有定义的实例, 比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">BreakWindow</span><span class="params">(QtWidgets.QDialog)</span>:</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_a_new_tomato</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        window.start_a_tomato()</span><br></pre></td></tr></table></figure><p>在这里我定义了<code>BreakWindow</code>类, 方法里调用了<code>window.start_a_tomato()</code>, <code>window</code>是另一个类, 并且在后文才定义(当然是在方法调用之前)</p><h3 id="4-循环不退出-使用flag标志的重要性"><a href="#4-循环不退出-使用flag标志的重要性" class="headerlink" title="4. 循环不退出? - 使用flag标志的重要性"></a>4. 循环不退出? - 使用flag标志的重要性</h3><p>因为循环不退出而产生bug已经不知道多少次了, 以后注意在书写循环的时候一定要提前想好尽可能全的情况, 并且写好flag, 循环不在该退的时候退真的很讨厌</p><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-在Python中播放声音-音乐-playsound包"><a href="#1-在Python中播放声音-音乐-playsound包" class="headerlink" title="1. 在Python中播放声音/音乐 - playsound包"></a>1. 在Python中播放声音/音乐 - playsound包</h3><p>在环境里加入playsound包</p><p>调用使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playsound <span class="keyword">import</span> playsound</span><br><span class="line"></span><br><span class="line">playsound(<span class="string">"sound/XXXX.mp3"</span>)</span><br></pre></td></tr></table></figure><p>真的是非常简单的API了</p><p>但是缺点也是太简单了, 几乎没有其他的可操作选项了, 可以看的出来作者基本也是没有什么经验的</p><p>还有一个就是响铃的速度好像不是很快</p><h3 id="2-窗口关闭事件信号-重写closeEvent-方法"><a href="#2-窗口关闭事件信号-重写closeEvent-方法" class="headerlink" title="2. 窗口关闭事件信号 - 重写closeEvent()方法"></a>2. 窗口关闭事件信号 - 重写closeEvent()方法</h3><p>在窗口关闭时, 会执行<code>.closeEvent()</code>方法, 通过重写这个方法, 可以达到检测窗口关闭的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">event.accept()</span><br></pre></td></tr></table></figure><h3 id="3-验证窗口是否在关闭-isHidden"><a href="#3-验证窗口是否在关闭-isHidden" class="headerlink" title="3. 验证窗口是否在关闭 - isHidden()"></a>3. 验证窗口是否在关闭 - isHidden()</h3><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>暂时没有思路</p><h3 id="2-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#2-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="2. Qt里写了中文uic()命令就无法成功执行的问题"></a>2. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>暂时没有思路</p><h3 id="3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug"><a href="#3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug" class="headerlink" title="3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug"></a>3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug</h3><h3 id="4-占用cpu过高问题"><a href="#4-占用cpu过高问题" class="headerlink" title="4. 占用cpu过高问题"></a>4. 占用cpu过高问题</h3><p>猜测是在循环时关闭窗口导致循环还在后台运行, 没有正常退出的问题</p><p>但怎么说这个占用也太夸张了吧就算是我有个循环</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010854.png" alt="image-20200412164033369"></p><p>你一个循环凭什么吃掉我1/4个CPU啊</p><h3 id="5-交互逻辑混乱问题"><a href="#5-交互逻辑混乱问题" class="headerlink" title="5. 交互逻辑混乱问题"></a>5. 交互逻辑混乱问题</h3><p>完全是我的锅, 因为各种小bug, 以及前期准备不足, 经验不到位, 结果使得各种循环判断, 各种地方交错调用, 命名没规范之类…</p><p>导致出现大问题无从下手, 如果要进一步给软件加入功能, 最起码的, 让他<strong>“能用”</strong>, 是肯定要重构代码的</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>虽然程序交互有很大进步, 但还是可以看出我的经验不足, 前期准备缺乏, 导致结构混乱, 后期出现Bug无从下手</p><p>经过这次教训, 我知道了前期纸上的准备和写代码同样重要, 写代码和我整理电脑一样, 都不可以把东西随意乱放, 不然图一时之快只会给以后的自己带来麻烦</p><p>虽然标题上写着<strong>“又不是不能用”</strong>, 但CPU占用如此之高, 进程无法干净退出, 无故响铃的软件, 确实就是<strong>“不能用”</strong>的</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/f3590d7f.html">http://dynais.xyz/posts/f3590d7f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;加入了自己指定时间的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010843.png&quot; alt=&quot;image-20200412153655534&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入保存用户设置的文件&lt;code&gt;config.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在倒计时结束时发出铃声通知&lt;/li&gt;
&lt;li&gt;完善了除统计和To Do List外的Menu界面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010845.png&quot; alt=&quot;image-20200412153753123&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修正了部分bug&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>番茄钟倒计时模块的基本实现</title>
    <link href="http://dynais.xyz/posts/378efd60.html"/>
    <id>http://dynais.xyz/posts/378efd60.html</id>
    <published>2020-04-09T22:00:00.000Z</published>
    <updated>2021-02-21T10:00:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li>实现了番茄钟最基本的倒计时功能</li><li>实现了按钮交互的功能</li></ul><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010712.png" alt="image-20200409231248203" style="zoom:50%;" /></p><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-显示时间与计算时间的转换"><a href="#1-显示时间与计算时间的转换" class="headerlink" title="1. 显示时间与计算时间的转换"></a>1. 显示时间与计算时间的转换</h3><a id="more"></a><p>实现倒计时时的一个问题是: 显示的时间格式需要是”XX:XX”, 但是为了方便计算, 需要把这个格式的时间转化为秒数的形式, 这就需要一个显示时间与计算时间互相转换的模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示时间转秒数 "XX:XX" -&gt; flout</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tomato2sec</span><span class="params">(tomato)</span>:</span></span><br><span class="line">    sec = int(tomato[<span class="number">3</span>:])</span><br><span class="line">    sec = sec + <span class="number">60</span> * int(tomato[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 秒数转显示时间 flout -&gt; "XX:XX"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sec2tomato</span><span class="params">(sec)</span>:</span></span><br><span class="line">    t = []</span><br><span class="line">    t.append(str(int(sec / <span class="number">60</span>)))</span><br><span class="line">    t.append(str(int(sec % <span class="number">60</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(t)):</span><br><span class="line">        <span class="keyword">if</span> len(t[i]) &lt; <span class="number">2</span>:</span><br><span class="line">            t[i] = <span class="string">"0"</span> + t[i]</span><br><span class="line"></span><br><span class="line">    tomato = <span class="string">":"</span>.join(t)</span><br><span class="line">    <span class="keyword">return</span> tomato</span><br></pre></td></tr></table></figure><h3 id="2-获取系统时间"><a href="#2-获取系统时间" class="headerlink" title="2. 获取系统时间"></a>2. 获取系统时间</h3><p>获取系统时间在python里我使用的是time包, 还有一个相似的是datetime.time包, 注意不要搞混了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure><p>倒计时的基本思路是点击开始按钮时获取一个开启的系统时间, 然后用户会有一个给定的目标时间, 然后点按钮以后会进入一个循环, 知道计时结束才会退出, 在循环里面一直获取系统时间和其实时间运算就得到了已经过了多久, 再和目标时间判断就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_start &#x3D; time.time()</span><br></pre></td></tr></table></figure><p>这个语句是获取以秒数显示的当前系统时间, 用于运算会比较方便</p><h3 id="3-页面元素的交互"><a href="#3-页面元素的交互" class="headerlink" title="3. 页面元素的交互"></a>3. 页面元素的交互</h3><p>简单的页面元素交互可以在Qt里直接实现</p><p>原理基本上是, 按下按钮之类的东西, 会发出一个信号</p><p><code>ui_window.button_start.clicked</code>这个信号就是<code>ui_window</code>这个窗口下<code>button_start</code>按钮发出的点击信号, 使用<code>connect</code>绑定一个<strong>slot</strong>之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui_window.button_start.clicked.connect(start_a_tomato)</span><br></pre></td></tr></table></figure><p>在这里的意思就是: 单击这个按钮以后执行<code>start_a_tomato</code>函数, 注意函数名在这里不带括号</p><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-倒计时使用time-sleep-效果不好的问题"><a href="#1-倒计时使用time-sleep-效果不好的问题" class="headerlink" title="1. 倒计时使用time.sleep()效果不好的问题"></a>1. 倒计时使用time.sleep()效果不好的问题</h3><p>最开始的思路里, 用户点击开始后进入一个循环, 这个循环每次执行一秒, 然后让页面更新一次, 用到的函数是这个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment">#控制系统空置一秒</span></span><br></pre></td></tr></table></figure><p>但是问题就是, 和单片机上不能乱用<code>delay()</code>一样, 使用<code>sleep()</code>会使程序整个无法响应, 导致拖拽手感奇怪, 且拖拽时倒计时直接停止</p><p>然后换了思路, 直接不断读取系统时间实时刷新, 解决了拖拽手感的问题, 但拖拽时倒计时还是会停止, 不过放下窗口后时间并不会出错, 就先不管了</p><h3 id="2-改变窗口元素但窗口显示不刷新的问题"><a href="#2-改变窗口元素但窗口显示不刷新的问题" class="headerlink" title="2. 改变窗口元素但窗口显示不刷新的问题"></a>2. 改变窗口元素但窗口显示不刷新的问题</h3><p>最开始在循环里改变了元素, 但发现直到循环退出窗口才改变了显示, 但使用print输出又没什么问题, 于是想可能是窗口刷新的问题, 最后的解决办法就一条指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QtWidgets.QApplication.processEvents()</span><br></pre></td></tr></table></figure><p>让窗口刷新</p><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>暂时没有思路</p><h3 id="2-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#2-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="2. Qt里写了中文uic()命令就无法成功执行的问题"></a>2. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>应该是编码不统一的问题, 但是改了Qt的编码几次还是不行, 暂时先用英文顶着, 看看以后有没有解决办法</p><p>暂时没有思路</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><ul><li>加入自己指定时间的模块</li><li>加入保存用户设置的文件</li><li>在倒计时结束时尝试发出通知</li></ul><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/378efd60.html">http://dynais.xyz/posts/378efd60.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实现了番茄钟最基本的倒计时功能&lt;/li&gt;
&lt;li&gt;实现了按钮交互的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010712.png&quot; alt=&quot;image-20200409231248203&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-重要代码模块&quot;&gt;&lt;a href=&quot;#一-重要代码模块&quot; class=&quot;headerlink&quot; title=&quot;一. 重要代码模块&quot;&gt;&lt;/a&gt;一. 重要代码模块&lt;/h2&gt;&lt;h3 id=&quot;1-显示时间与计算时间的转换&quot;&gt;&lt;a href=&quot;#1-显示时间与计算时间的转换&quot; class=&quot;headerlink&quot; title=&quot;1. 显示时间与计算时间的转换&quot;&gt;&lt;/a&gt;1. 显示时间与计算时间的转换&lt;/h3&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python+Qt5项目环境的搭建</title>
    <link href="http://dynais.xyz/posts/6b47c0e1.html"/>
    <id>http://dynais.xyz/posts/6b47c0e1.html</id>
    <published>2020-04-07T22:00:00.000Z</published>
    <updated>2021-02-21T10:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="一-软件"><a href="#一-软件" class="headerlink" title="一. 软件"></a>一. 软件</h2><h3 id="1-Pycharm-2019-3-3"><a href="#1-Pycharm-2019-3-3" class="headerlink" title="1. Pycharm 2019.3.3"></a>1. Pycharm 2019.3.3</h3><p>​    Pycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成</p><h3 id="2-Qt-5-12-7-Qt-Creator"><a href="#2-Qt-5-12-7-Qt-Creator" class="headerlink" title="2. Qt 5.12.7 / Qt Creator"></a>2. Qt 5.12.7 / Qt Creator</h3><p>​    Qt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版</p><h2 id="二-环境搭建-对于已有Anaconda3"><a href="#二-环境搭建-对于已有Anaconda3" class="headerlink" title="二. 环境搭建(对于已有Anaconda3)"></a>二. 环境搭建(对于已有Anaconda3)</h2><h3 id="1-Python解释器"><a href="#1-Python解释器" class="headerlink" title="1.Python解释器"></a>1.Python解释器</h3><p>由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用</p><a id="more"></a><h3 id="2-配置环境变量-对于Anaconda3"><a href="#2-配置环境变量-对于Anaconda3" class="headerlink" title="2. 配置环境变量(对于Anaconda3)"></a>2. 配置环境变量(对于Anaconda3)</h3><p>对于Anaconda3的用户, 需要再自行配置一下环境变量, 在环境变量的<code>path</code>选项卡中添加Anaconda的以下目录</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010627.png" alt="image-20200408140342164"></p><p>不然在Pycharm中搭建环境时会遇到提示pip无法成功的提示, 导致包无法安装</p><h3 id="3-在Pycharm里搭建环境-安装必要的包"><a href="#3-在Pycharm里搭建环境-安装必要的包" class="headerlink" title="3. 在Pycharm里搭建环境/安装必要的包"></a>3. 在Pycharm里搭建环境/安装必要的包</h3><p>完成以上两步准备就可以开始配置Pycharm了</p><p>首先新建一个项目</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010630.png" alt="image-20200408140546920"></p><p>有几点需要注意的地方: </p><p><strong>首先, 确保<code>New environment using</code>中是新建了一个环境,而不是使用Conda.</strong> </p><p><strong>其次, 确保<code>Base interpreter</code>中选择的是<code>pythonw</code>解释器, 而不是<code>python</code></strong></p><p><strong>最后注意, 此处不需勾选</strong></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010633.png" alt="image-20200408141111529"></p><p>然后就可以让它新建一个项目了</p><p>打开工程后进入 <strong>文件 -&gt; 设置 -&gt; 项目 -&gt; Project Interpreter</strong> 在这里管理需要用到的包文件</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010635.png" alt="image-20200408142236868" style="zoom:50%;" /></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010637.png" alt="image-20200408142313603" style="zoom:50%;" /></p><p>需要使用Qt编程的话, 必须添加<code>QtPy</code>和<code>PyQt5</code>两个包</p><p>Pycharm会自己管理, 下载好就算是配置完成了</p><h2 id="三-工作流"><a href="#三-工作流" class="headerlink" title="三. 工作流"></a>三. 工作流</h2><p>大致的思路是:</p><ul><li>使用Qt Creator创作图形界面</li><li>使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中</li><li>使用Pycharm编写整体逻辑</li></ul><h3 id="1-使用Qt-Creator创作图形界面"><a href="#1-使用Qt-Creator创作图形界面" class="headerlink" title="1. 使用Qt Creator创作图形界面"></a>1. 使用Qt Creator创作图形界面</h3><p>打开Qt Creator新建工程</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010641.png" alt="image-20200408142839431" style="zoom:50%;" /></p><p>注意创建时选择桌面图形应用, 这里不需要选Python的那个</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010643.png" alt="image-20200408143012126" style="zoom:50%;" /></p><p> 工程最好命名为<code>ui</code>, 保存在一个项目文件夹下</p><h3 id="2-使用包内置函数转化Qt的-ui文件为-py文件-作为包导入到程序中"><a href="#2-使用包内置函数转化Qt的-ui文件为-py文件-作为包导入到程序中" class="headerlink" title="2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中"></a>2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中</h3><p>在Pycharm中新建一个<code>builder.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qtpy <span class="keyword">import</span> uic</span><br><span class="line"></span><br><span class="line">uic.compileUiDir(<span class="string">"这里填入Qt工程的文件夹路径"</span>)</span><br></pre></td></tr></table></figure><p>运行便可以得到一个.py文件, 里面是应用程序外观的描述</p><p>在主程序py文件中写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> qtpy <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">from</span> ui.mainwindow <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line">app = QtWidgets.QApplication(sys.argv)<span class="comment">#设置一个App</span></span><br><span class="line"></span><br><span class="line">window = QtWidgets.QMainWindow()<span class="comment">#新建一个窗口</span></span><br><span class="line">ui_window = Ui_MainWindow()<span class="comment">#新建一个导入包中窗口的类</span></span><br><span class="line">ui_window.setupUi(window)<span class="comment">#注意自己的窗口要填入括号</span></span><br><span class="line">window.setWindowTitle(<span class="string">"Tomato Clock v0"</span>)<span class="comment">#设置标题</span></span><br><span class="line"></span><br><span class="line">window.show()<span class="comment">#显示窗口</span></span><br><span class="line"></span><br><span class="line">sys.exit(app.exec_())<span class="comment">#设置退出</span></span><br></pre></td></tr></table></figure><p>设置完成</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/6b47c0e1.html">http://dynais.xyz/posts/6b47c0e1.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;一-软件&quot;&gt;&lt;a href=&quot;#一-软件&quot; class=&quot;headerlink&quot; title=&quot;一. 软件&quot;&gt;&lt;/a&gt;一. 软件&lt;/h2&gt;&lt;h3 id=&quot;1-Pycharm-2019-3-3&quot;&gt;&lt;a href=&quot;#1-Pycharm-2019-3-3&quot; class=&quot;headerlink&quot; title=&quot;1. Pycharm 2019.3.3&quot;&gt;&lt;/a&gt;1. Pycharm 2019.3.3&lt;/h3&gt;&lt;p&gt;​    Pycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成&lt;/p&gt;
&lt;h3 id=&quot;2-Qt-5-12-7-Qt-Creator&quot;&gt;&lt;a href=&quot;#2-Qt-5-12-7-Qt-Creator&quot; class=&quot;headerlink&quot; title=&quot;2. Qt 5.12.7 / Qt Creator&quot;&gt;&lt;/a&gt;2. Qt 5.12.7 / Qt Creator&lt;/h3&gt;&lt;p&gt;​    Qt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版&lt;/p&gt;
&lt;h2 id=&quot;二-环境搭建-对于已有Anaconda3&quot;&gt;&lt;a href=&quot;#二-环境搭建-对于已有Anaconda3&quot; class=&quot;headerlink&quot; title=&quot;二. 环境搭建(对于已有Anaconda3)&quot;&gt;&lt;/a&gt;二. 环境搭建(对于已有Anaconda3)&lt;/h2&gt;&lt;h3 id=&quot;1-Python解释器&quot;&gt;&lt;a href=&quot;#1-Python解释器&quot; class=&quot;headerlink&quot; title=&quot;1.Python解释器&quot;&gt;&lt;/a&gt;1.Python解释器&lt;/h3&gt;&lt;p&gt;由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/%E9%A1%B9%E7%9B%AE/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在Markdown文件中使用Latex表示数学公式</title>
    <link href="http://dynais.xyz/posts/ae2a8b3f.html"/>
    <id>http://dynais.xyz/posts/ae2a8b3f.html</id>
    <published>2020-03-05T21:00:00.000Z</published>
    <updated>2021-04-11T13:46:07.000Z</updated>
    
    <content type="html"><![CDATA[<p> 在Markdown中插入数学公式的语法是 <code>$数学公式$</code> 和 <code>$$数学公式$$</code>.</p><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:</p><div class="table-container"><table><thead><tr><th>示例</th><th>显示</th></tr></thead><tbody><tr><td><code>$2x+3y=34$</code></td><td><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725005742.svg" alt="2x+3y=34"></td></tr><tr><td><code>2x+3y=34</code></td><td>2x+3y=34</td></tr></tbody></table></div><p>因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量<img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010108.svg" alt="x">,也要进入数学模式,使用<code>$1+1=2$</code>,<code>$x$</code>,而不是使用排版普通文字的方式</p><h2 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h2><p>独立公式单独占一行,不和其他文字混编</p><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><p>在独立公式中使用\\来换行<br> 示例:</p><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$   </span><br><span class="line"><span class="number">2</span>x+<span class="number">3</span>y=<span class="number">34</span>\\   </span><br><span class="line">x+<span class="number">4</span>y=<span class="number">25</span>  </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示:<br> <img src="https://math.jianshu.com/math?formula=2x%2B3y%3D34\\ x%2B4y%3D25" alt="2x+3y=34\\ x+4y=25"></p><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>示例</th><th>显示</th></tr></thead><tbody><tr><td>上下标</td><td><code>S=a_{1}^2+a_{2}^2+a_{3}^2$</code></td><td><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725005759.svg" alt="S=a_{1}^2+a_{2}^2+a_{3}^2"></td></tr><tr><td>括号</td><td><code>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</code></td><td><img src="https://math.jianshu.com/math?formula=f(x%2C%20y" alt="f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace">%20%3D%20100%20<em>%20%5Clbrace%5B(x%20%2B%20y)%20</em>%203%5D%20-%205%5Crbrace)</td></tr><tr><td>分数</td><td><code>$\frac{1}{3} 与 \cfrac{1}{3}$</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B3%7D%20%E4%B8%8E%20%5Ccfrac%7B1%7D%7B3%7D" alt="\frac{1}{3} 与 \cfrac{1}{3}"></td></tr><tr><td>开方</td><td><code>$\sqrt[3]{X}$</code>和<code>$\sqrt{5 - x}$</code></td><td><img src="D:\WorkSpace\.Typora Images Hub\math-1583415699231.svg" alt="\sqrt[3]{X}">和<img src="https://math.jianshu.com/math?formula=%5Csqrt%7B5%20-%20x%7D" alt="\sqrt{5 - x}"></td></tr></tbody></table></div><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\pm</td><td><img src="https://math.jianshu.com/math?formula=%5Cpm" alt="\pm"></td></tr><tr><td>\times</td><td><img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"></td></tr><tr><td>\div</td><td><img src="https://math.jianshu.com/math?formula=%5Cdiv" alt="\div"></td></tr><tr><td>\mid</td><td><img src="https://math.jianshu.com/math?formula=%5Cmid" alt="\mid"></td></tr><tr><td>\nmid</td><td><img src="https://math.jianshu.com/math?formula=%5Cnmid" alt="\nmid"></td></tr><tr><td>\cdot</td><td><img src="https://math.jianshu.com/math?formula=%5Ccdot" alt="\cdot"></td></tr><tr><td>\circ</td><td><img src="https://math.jianshu.com/math?formula=%5Ccirc" alt="\circ"></td></tr><tr><td>\ast</td><td><img src="https://math.jianshu.com/math?formula=%5Cast" alt="\ast"></td></tr><tr><td>\bigodot</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigodot" alt="\bigodot"></td></tr><tr><td>\bigotimes</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigotimes" alt="\bigotimes"></td></tr><tr><td>\bigoplus</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigoplus" alt="\bigoplus"></td></tr><tr><td>\leq</td><td><img src="https://math.jianshu.com/math?formula=%5Cleq" alt="\leq"></td></tr><tr><td>\geq</td><td><img src="https://math.jianshu.com/math?formula=%5Cgeq" alt="\geq"></td></tr><tr><td>\neq</td><td><img src="https://math.jianshu.com/math?formula=%5Cneq" alt="\neq"></td></tr><tr><td>\approx</td><td><img src="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx"></td></tr><tr><td>\equiv</td><td><img src="https://math.jianshu.com/math?formula=%5Cequiv" alt="\equiv"></td></tr><tr><td>\sum</td><td><img src="https://math.jianshu.com/math?formula=%5Csum" alt="\sum"></td></tr><tr><td>\prod</td><td><img src="https://math.jianshu.com/math?formula=%5Cprod" alt="\prod"></td></tr></tbody></table></div><h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\log</td><td><img src="https://math.jianshu.com/math?formula=%5Clog" alt="\log"></td></tr><tr><td>\lg</td><td><img src="https://math.jianshu.com/math?formula=%5Clg" alt="\lg"></td></tr><tr><td>\ln</td><td><img src="https://math.jianshu.com/math?formula=%5Cln" alt="\ln"></td></tr></tbody></table></div><h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\bot</td><td><img src="https://math.jianshu.com/math?formula=%5Cbot" alt="\bot"></td></tr><tr><td>\angle</td><td><img src="https://math.jianshu.com/math?formula=%5Cangle" alt="\angle"></td></tr><tr><td>\sin</td><td><img src="https://math.jianshu.com/math?formula=%5Csin" alt="\sin"></td></tr><tr><td>\cos</td><td><img src="https://math.jianshu.com/math?formula=%5Ccos" alt="\cos"></td></tr><tr><td>\tan</td><td><img src="https://math.jianshu.com/math?formula=%5Ctan" alt="\tan"></td></tr><tr><td>\cot</td><td><img src="https://math.jianshu.com/math?formula=%5Ccot" alt="\cot"></td></tr><tr><td>\sec</td><td><img src="https://math.jianshu.com/math?formula=%5Csec" alt="\sec"></td></tr><tr><td>\csc</td><td><img src="https://math.jianshu.com/math?formula=%5Ccsc" alt="\csc"></td></tr></tbody></table></div><h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\prime</td><td><img src="https://math.jianshu.com/math?formula=%5Cprime" alt="\prime"></td></tr><tr><td>\int</td><td><img src="https://math.jianshu.com/math?formula=%5Cint" alt="\int"></td></tr><tr><td>\iint</td><td><img src="https://math.jianshu.com/math?formula=%5Ciint" alt="\iint"></td></tr><tr><td>\iiint</td><td><img src="https://math.jianshu.com/math?formula=%5Ciiint" alt="\iiint"></td></tr><tr><td>\oint</td><td><img src="https://math.jianshu.com/math?formula=%5Coint" alt="\oint"></td></tr><tr><td>\lim</td><td><img src="https://math.jianshu.com/math?formula=%5Clim" alt="\lim"></td></tr><tr><td>\infty</td><td><img src="https://math.jianshu.com/math?formula=%5Cinfty" alt="\infty"></td></tr><tr><td>\nabla</td><td><img src="https://math.jianshu.com/math?formula=%5Cnabla" alt="\nabla"></td></tr><tr><td>\mathrm{d}</td><td><img src="https://math.jianshu.com/math?formula=%5Cmathrm%7Bd%7D" alt="\mathrm{d}"></td></tr></tbody></table></div><h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\emptyset</td><td><img src="https://math.jianshu.com/math?formula=%5Cemptyset" alt="\emptyset"></td></tr><tr><td>\in</td><td><img src="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td></tr><tr><td>\notin</td><td><img src="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td></tr><tr><td>\subset</td><td><img src="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td></tr><tr><td>\subseteq</td><td><img src="https://math.jianshu.com/math?formula=%5Csubseteq" alt="\subseteq"></td></tr><tr><td>\supseteq</td><td><img src="https://math.jianshu.com/math?formula=%5Csupseteq" alt="\supseteq"></td></tr><tr><td>\bigcap</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcap" alt="\bigcap"></td></tr><tr><td>\bigcup</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcup" alt="\bigcup"></td></tr><tr><td>\bigvee</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigvee" alt="\bigvee"></td></tr><tr><td>\bigwedge</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigwedge" alt="\bigwedge"></td></tr><tr><td>\biguplus</td><td><img src="https://math.jianshu.com/math?formula=%5Cbiguplus" alt="\biguplus"></td></tr><tr><td>\bigsqcup</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigsqcup" alt="\bigsqcup"></td></tr></tbody></table></div><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container"><table><thead><tr><th>代码</th><th>大写</th><th>代码</th><th>小写</th></tr></thead><tbody><tr><td>A</td><td><img src="https://math.jianshu.com/math?formula=A" alt="A"></td><td>\alpha</td><td><img src="https://math.jianshu.com/math?formula=%5Calpha" alt="\alpha"></td></tr><tr><td>B</td><td><img src="https://math.jianshu.com/math?formula=B" alt="B"></td><td>\beta</td><td><img src="https://math.jianshu.com/math?formula=%5Cbeta" alt="\beta"></td></tr><tr><td>\Gamma</td><td><img src="https://math.jianshu.com/math?formula=%5CGamma" alt="\Gamma"></td><td>\gamma</td><td><img src="https://math.jianshu.com/math?formula=%5Cgamma" alt="\gamma"></td></tr><tr><td>\Delta</td><td><img src="https://math.jianshu.com/math?formula=%5CDelta" alt="\Delta"></td><td>\delta</td><td><img src="https://math.jianshu.com/math?formula=%5Cdelta" alt="\delta"></td></tr><tr><td>E</td><td><img src="https://math.jianshu.com/math?formula=E" alt="E"></td><td>\epsilon</td><td><img src="https://math.jianshu.com/math?formula=%5Cepsilon" alt="\epsilon"></td></tr><tr><td>Z</td><td><img src="https://math.jianshu.com/math?formula=Z" alt="Z"></td><td>\zeta</td><td><img src="https://math.jianshu.com/math?formula=%5Czeta" alt="\zeta"></td></tr><tr><td>H</td><td><img src="https://math.jianshu.com/math?formula=H" alt="H"></td><td>\eta</td><td><img src="https://math.jianshu.com/math?formula=%5Ceta" alt="\eta"></td></tr><tr><td>\Theta</td><td><img src="https://math.jianshu.com/math?formula=%5CTheta" alt="\Theta"></td><td>\theta</td><td><img src="https://math.jianshu.com/math?formula=%5Ctheta" alt="\theta"></td></tr><tr><td>I</td><td><img src="https://math.jianshu.com/math?formula=I" alt="I"></td><td>\iota</td><td><img src="https://math.jianshu.com/math?formula=%5Ciota" alt="\iota"></td></tr><tr><td>K</td><td><img src="https://math.jianshu.com/math?formula=K" alt="K"></td><td>\kappa</td><td><img src="https://math.jianshu.com/math?formula=%5Ckappa" alt="\kappa"></td></tr><tr><td>\Lambda</td><td><img src="https://math.jianshu.com/math?formula=%5CLambda" alt="\Lambda"></td><td>\lambda</td><td><img src="https://math.jianshu.com/math?formula=%5Clambda" alt="\lambda"></td></tr><tr><td>M</td><td><img src="https://math.jianshu.com/math?formula=M" alt="M"></td><td>\mu</td><td><img src="https://math.jianshu.com/math?formula=%5Cmu" alt="\mu"></td></tr><tr><td>N</td><td><img src="https://math.jianshu.com/math?formula=N" alt="N"></td><td>\nu</td><td><img src="https://math.jianshu.com/math?formula=%5Cnu" alt="\nu"></td></tr><tr><td>Xi</td><td><img src="https://math.jianshu.com/math?formula=Xi" alt="Xi"></td><td>\xi</td><td><img src="https://math.jianshu.com/math?formula=%5Cxi" alt="\xi"></td></tr><tr><td>O</td><td><img src="https://math.jianshu.com/math?formula=O" alt="O"></td><td>\omicron</td><td><img src="https://math.jianshu.com/math?formula=%5Comicron" alt="\omicron"></td></tr><tr><td>\Pi</td><td><img src="https://math.jianshu.com/math?formula=%5CPi" alt="\Pi"></td><td>\pi</td><td><img src="https://math.jianshu.com/math?formula=%5Cpi" alt="\pi"></td></tr><tr><td>P</td><td><img src="https://math.jianshu.com/math?formula=P" alt="P"></td><td>\rho</td><td><img src="https://math.jianshu.com/math?formula=%5Crho" alt="\rho"></td></tr><tr><td>\Sigma</td><td><img src="https://math.jianshu.com/math?formula=%5CSigma" alt="\Sigma"></td><td>\sigma</td><td><img src="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma"></td></tr><tr><td>T</td><td><img src="https://math.jianshu.com/math?formula=T" alt="T"></td><td>\tau</td><td><img src="https://math.jianshu.com/math?formula=%5Ctau" alt="\tau"></td></tr><tr><td>\Upsilon</td><td><img src="https://math.jianshu.com/math?formula=%5CUpsilon" alt="\Upsilon"></td><td>\upsilon</td><td><img src="https://math.jianshu.com/math?formula=%5Cupsilon" alt="\upsilon"></td></tr><tr><td>\Phi</td><td><img src="https://math.jianshu.com/math?formula=%5CPhi" alt="\Phi"></td><td>\phi</td><td><img src="https://math.jianshu.com/math?formula=%5Cphi" alt="\phi"></td></tr><tr><td>X</td><td><img src="https://math.jianshu.com/math?formula=X" alt="X"></td><td>\chi</td><td><img src="https://math.jianshu.com/math?formula=%5Cchi" alt="\chi"></td></tr><tr><td>\Psi</td><td><img src="https://math.jianshu.com/math?formula=%5CPsi" alt="\Psi"></td><td>\psi</td><td><img src="https://math.jianshu.com/math?formula=%5Cpsi" alt="\psi"></td></tr><tr><td>\Omega</td><td><img src="https://math.jianshu.com/math?formula=%5COmega" alt="\Omega"></td><td>\omega</td><td><img src="https://math.jianshu.com/math?formula=%5Comega" alt="\omega"></td></tr></tbody></table></div><ul><li><p>需要大写希腊字母，将命令首字母大写即可。<br>\Gamma呈现为</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210317223633.webp" alt="img"></p></li><li><p>若需要斜体希腊字母，将命令前加上var前缀即可。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210317223637.png" alt="img"></p></li></ul><h2 id="向量和复数"><a href="#向量和复数" class="headerlink" title="向量和复数"></a>向量和复数</h2><p>普通的变量x:<code>x</code>:$x$</p><p>粗体1：使用<code>\boldsymbol{}</code>进行加粗，如：<code>\boldsymbol{x}</code>:$\boldsymbol{x}$</p><p>粗体2：使用<code>\mathbf{}</code>进行加粗，如：<code>\mathbf{x}</code>:$\mathbf{x}$</p><p>带箭头的向量：使用<code>\vec{}</code>使向量带箭头，如<code>\vec{x}</code>:$\vec{x}$</p><p>复数表示: <code>\underline{}</code> 表示为 $\underline{U}$ </p><h2 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h2><p>使用<code>\vert</code>:$\vert U \vert$</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><img src="https:////upload-images.jianshu.io/upload_images/436556-45c8673c41af7c42.png?imageMogr2/auto-orient/strip|imageView2/2/w/446/format/webp" alt="img"></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p><img src="https:////upload-images.jianshu.io/upload_images/436556-434dd3242e693d70.png?imageMogr2/auto-orient/strip|imageView2/2/w/375/format/webp" alt="img"></p><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p><img src="https:////upload-images.jianshu.io/upload_images/436556-6ef5dd4fd56680f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp" alt="img"></p><h2 id="求和、极限与积分"><a href="#求和、极限与积分" class="headerlink" title="求和、极限与积分"></a>求和、极限与积分</h2><p><img src="https:////upload-images.jianshu.io/upload_images/436556-fb2604765d03c8d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp" alt="img"></p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p><img src="https:////upload-images.jianshu.io/upload_images/436556-f9b9a026db748466.png?imageMogr2/auto-orient/strip|imageView2/2/w/264/format/webp" alt="img"></p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>起始标记<code>\begin{matrix}</code>，结束标记<code>\end{matrix}</code><br>每一行末尾标记<code>\\\</code>，行间元素之间以<code>&amp;</code>分隔<br>举例:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">0</span>&amp;<span class="number">0</span>\\</span><br><span class="line"><span class="number">0</span>&amp;<span class="number">1</span>&amp;<span class="number">0</span>\\</span><br><span class="line"><span class="number">0</span>&amp;<span class="number">0</span>&amp;<span class="number">1</span>\\</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;$$</span><br></pre></td></tr></table></figure><p>呈现为：</p><p><img src="https:////upload-images.jianshu.io/upload_images/436556-1548fa2d1079ef70.png?imageMogr2/auto-orient/strip|imageView2/2/w/113/format/webp" alt="img"></p><h3 id="矩阵边框"><a href="#矩阵边框" class="headerlink" title="矩阵边框"></a>矩阵边框</h3><ul><li>在起始、结束标记处用下列词替换 <code>matrix</code></li><li><code>pmatrix</code> ：小括号边框</li><li><code>bmatrix</code> ：中括号边框</li><li><code>Bmatrix</code> ：大括号边框</li><li><code>vmatrix</code> ：单竖线边框</li><li><code>Vmatrix</code> ：双竖线边框</li></ul><h3 id="省略元素"><a href="#省略元素" class="headerlink" title="省略元素"></a>省略元素</h3><ul><li>横省略号：<code>\cdots</code></li><li>竖省略号：<code>\vdots</code></li><li>斜省略号：<code>\ddots</code></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$\<span class="keyword">begin</span>&#123;bmatrix&#125;</span><br><span class="line">&#123;a<span class="number">_</span>&#123;<span class="number">11</span>&#125;&#125;&amp;&#123;a<span class="number">_</span>&#123;<span class="number">12</span>&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a<span class="number">_</span>&#123;<span class="number">1</span>n&#125;&#125;\\</span><br><span class="line">&#123;a<span class="number">_</span>&#123;<span class="number">21</span>&#125;&#125;&amp;&#123;a<span class="number">_</span>&#123;<span class="number">22</span>&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a<span class="number">_</span>&#123;<span class="number">2</span>n&#125;&#125;\\</span><br><span class="line">&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\</span><br><span class="line">&#123;a<span class="number">_</span>&#123;m1&#125;&#125;&amp;&#123;a<span class="number">_</span>&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a<span class="number">_</span>&#123;mn&#125;&#125;\\</span><br><span class="line">\<span class="keyword">end</span>&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>呈现为：</p><p><img src="https:////upload-images.jianshu.io/upload_images/436556-72c03690ce9e63b8.png?imageMogr2/auto-orient/strip|imageView2/2/w/235/format/webp" alt="img"></p><h3 id="阵列"><a href="#阵列" class="headerlink" title="阵列"></a>阵列</h3><p><img src="https:////upload-images.jianshu.io/upload_images/436556-19f8205a2b599b86.png?imageMogr2/auto-orient/strip|imageView2/2/w/384/format/webp" alt="img"></p><p>举例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;<span class="built_in">c</span>|lll&#125;</span><br><span class="line">&#123;↓&#125;&amp;&#123;a&#125;&amp;&#123;b&#125;&amp;&#123;<span class="built_in">c</span>&#125;\\</span><br><span class="line">\hline</span><br><span class="line">&#123;<span class="type">R_1</span>&#125;&amp;&#123;<span class="built_in">c</span>&#125;&amp;&#123;b&#125;&amp;&#123;a&#125;\\</span><br><span class="line">&#123;<span class="type">R_2</span>&#125;&amp;&#123;b&#125;&amp;&#123;<span class="built_in">c</span>&#125;&amp;&#123;<span class="built_in">c</span>&#125;\\</span><br><span class="line">\end&#123;array&#125;$$</span><br></pre></td></tr></table></figure><p>呈现为</p><p><img src="https:////upload-images.jianshu.io/upload_images/436556-84dac3a98e0e44a9.png?imageMogr2/auto-orient/strip|imageView2/2/w/154/format/webp" alt="img"></p><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><ul><li>需要cases环境：起始、结束处以{cases}声明</li></ul><p>举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;cases&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1\\</span><br><span class="line">a_2x+b_2y+c_2z=d_2\\</span><br><span class="line">a_3x+b_3y+c_3z=d_3\\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>呈现为</p><p><img src="https:////upload-images.jianshu.io/upload_images/436556-8e608fa9d8906bf1.png?imageMogr2/auto-orient/strip|imageView2/2/w/250/format/webp" alt="img"></p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/ae2a8b3f.html">http://dynais.xyz/posts/ae2a8b3f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在Markdown中插入数学公式的语法是 &lt;code&gt;$数学公式$&lt;/code&gt; 和 &lt;code&gt;$$数学公式$$&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;行内公式&quot;&gt;&lt;a href=&quot;#行内公式&quot; class=&quot;headerlink&quot; title=&quot;行内公式&quot;&gt;&lt;/a&gt;行内公式&lt;/h2&gt;&lt;p&gt;行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$2x+3y=34$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725005742.svg&quot; alt=&quot;2x+3y=34&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2x+3y=34&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2x+3y=34&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010108.svg&quot; alt=&quot;x&quot;&gt;,也要进入数学模式,使用&lt;code&gt;$1+1=2$&lt;/code&gt;,&lt;code&gt;$x$&lt;/code&gt;,而不是使用排版普通文字的方式&lt;/p&gt;
&lt;h2 id=&quot;独立公式&quot;&gt;&lt;a href=&quot;#独立公式&quot; class=&quot;headerlink&quot; title=&quot;独立公式&quot;&gt;&lt;/a&gt;独立公式&lt;/h2&gt;&lt;p&gt;独立公式单独占一行,不和其他文字混编&lt;/p&gt;
&lt;h2 id=&quot;多行公式&quot;&gt;&lt;a href=&quot;#多行公式&quot; class=&quot;headerlink&quot; title=&quot;多行公式&quot;&gt;&lt;/a&gt;多行公式&lt;/h2&gt;&lt;p&gt;在独立公式中使用\\来换行&lt;br&gt; 示例:&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Latex" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/Latex/"/>
    
    
      <category term="Latex" scheme="http://dynais.xyz/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记12-模板匹配</title>
    <link href="http://dynais.xyz/posts/63d72132.html"/>
    <id>http://dynais.xyz/posts/63d72132.html</id>
    <published>2020-02-19T23:00:00.000Z</published>
    <updated>2021-02-21T09:52:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matchTemplate();<span class="comment">//模式查找,API比较简单</span></span><br><span class="line">minMaxLoc();<span class="comment">//用于在模式查找的输出图像中找到极值点,也就是匹配点</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>模板匹配(Templet Match)</p><p>相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.</p></li></ul><ul><li><p>注意输出图像的大小</p><p>在API中需要提供一个储存输出结果的Mat, 他的大小是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size(src.cols-templ.cols+1, src.rows-templ.rows+1)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>OpenCV的查找模式</p><p>OpenCV提供了很多种方法,在官网上都有介绍,大部分都是取用了最大值作为最匹配</p><p>根据最小值匹配的只有 <strong>TM_SQDIFF</strong> 和 <strong>MT_SQDIFF_NORMED</strong></p><p><em>For the first two methods ( TM_SQDIFF and MT_SQDIFF_NORMED ) the best match are the lowest values.</em></p></li></ul><ul><li><p>OpenCV中32位的图像</p><p>每个数值是一个位于[0,1]间的小数,相当于8位的[0,255]</p></li></ul><hr><h3 id="源-API实现模式查找"><a href="#源-API实现模式查找" class="headerlink" title="源//API实现模式查找"></a>源//API实现模式查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat src, dst, temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">temp = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Lena.jpg"</span>);</span><br><span class="line">src = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Day1.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试尺度不变性</span></span><br><span class="line"><span class="comment">//pyrDown(temp, temp, Size(temp.cols / 2, temp.rows / 2));</span></span><br><span class="line">pyrUp(temp, temp, Size(temp.cols * <span class="number">2</span>, temp.rows * <span class="number">2</span>));</span><br><span class="line"><span class="comment">//pyrUp(temp, temp, Size(temp.cols * 2, temp.rows * 2));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp.empty() || src.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG... Check again!"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat result = Mat_&lt;<span class="keyword">float</span>&gt;::zeros(src.cols - temp.cols + <span class="number">1</span>, src.rows - temp.rows + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">matchTemplate(src, temp, result, TM_CCOEFF_NORMED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; result;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> minVal; <span class="keyword">double</span> maxVal; Point minLoc; Point maxLoc;</span><br><span class="line">Point matchLoc;</span><br><span class="line">minMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, Mat());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minVal &lt;&lt; <span class="built_in">endl</span> &lt;&lt; maxVal &lt;&lt; <span class="built_in">endl</span> &lt;&lt; minLoc &lt;&lt; <span class="built_in">endl</span> &lt;&lt; maxLoc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">rectangle(src, maxLoc, Point(maxLoc.x + temp.cols, maxLoc.y + temp.rows), Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">rectangle(result, Point(maxLoc.x - temp.cols/<span class="number">2</span>, maxLoc.y - temp.rows/<span class="number">2</span>), Point(maxLoc.x + temp.cols/<span class="number">2</span>, maxLoc.y + temp.rows/<span class="number">2</span>), Scalar::all(<span class="number">1</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">namedWindow(<span class="string">"src"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">pyrDown(src, src, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(src, src, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line">namedWindow(<span class="string">"result"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">pyrDown(result, result, Size(result.cols / <span class="number">2</span>, result.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(result, result, Size(result.cols / <span class="number">2</span>, result.rows / <span class="number">2</span>));</span><br><span class="line">imshow(<span class="string">"result"</span>, result);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/63d72132.html">http://dynais.xyz/posts/63d72132.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;matchTemplate();&lt;span class=&quot;comment&quot;&gt;//模式查找,API比较简单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minMaxLoc();&lt;span class=&quot;comment&quot;&gt;//用于在模式查找的输出图像中找到极值点,也就是匹配点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模板匹配(Templet Match)&lt;/p&gt;
&lt;p&gt;相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意输出图像的大小&lt;/p&gt;
&lt;p&gt;在API中需要提供一个储存输出结果的Mat, 他的大小是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Size(src.cols-templ.cols+1, src.rows-templ.rows+1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记11-直方图均衡化-直方图比较-反向投影</title>
    <link href="http://dynais.xyz/posts/81b2be88.html"/>
    <id>http://dynais.xyz/posts/81b2be88.html</id>
    <published>2020-02-18T23:00:00.000Z</published>
    <updated>2021-02-21T09:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- equalizeHist();<span class="comment">//直方图均衡化</span></span><br><span class="line">- split();<span class="comment">//分离通道</span></span><br><span class="line">- calcHist();<span class="comment">//参数dims,bin,range</span></span><br><span class="line">- waitkey();</span><br><span class="line"></span><br><span class="line">- mixChannels<span class="comment">//分离通道, 与split小有差别,建议看官方文档</span></span><br><span class="line">- cvtColer<span class="comment">//使用此api转换到hsv色彩空间</span></span><br><span class="line">- calcHist<span class="comment">//接受单通道图像计算直方图, 参数略微复杂</span></span><br><span class="line">- normalize<span class="comment">//归一化,常用</span></span><br><span class="line">- compareHist<span class="comment">//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感</span></span><br><span class="line">- backProject();<span class="comment">//直方图反向投影</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><em>这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档</em></p><a id="more"></a><ul><li><strong>直方图均衡化</strong></li></ul><p>好像在人脸识别的项目总结里写过了, API并不难理解</p><ul><li><strong>HSV模型</strong></li></ul><p>HSV是一种比较直观的颜色模型，所以在许多图像编辑工具中应用比较广泛，这个模型中颜色的参数分别是：色调（H, Hue），饱和度（S,Saturation），明度（V, Value）</p><ul><li><strong>直方图比较</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareHist();</span><br></pre></td></tr></table></figure><p>API比较方便,输入两个直方图,比较他们的相似程度</p><p><strong>这两个直方图通常会是图像的HS直方图</strong>(虽然我现在还不太懂HS为什么可以变成一张直方图,到时候要用再看原理好了),用HS猜测是要降低算法对光线的敏感度?(实测好像对光线还是很敏感)</p><p>OpenCV提供了一共四种方法</p><ul><li>相关性计算:{-1, 1}  //1最强</li><li>卡方计算:{0, ∞}  //0最强</li><li>十字交叉</li><li>巴氏距离计算:{0, 1}  //0最强</li></ul><p>其中比较推荐的是相关性计算和巴氏距离计算(不需要归一化了hhhhhhhhh)</p><p>数学公式不列出了(反正我又不会去看)</p><ul><li><strong>直方图反向投影</strong></li></ul><blockquote id="fn_0"><sup>0</sup>. 论文:《Indexing Via Color Histograms》<a href="#reffn_0" title="Jump back to footnote [0] in the text."> &#8617;</a></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixChannels();</span><br><span class="line">backProject();</span><br></pre></td></tr></table></figure><p>直方图反向投影是一种基于色彩的对象识别技术,通过该方法可以定位图像中已知物体的位置,反应直方图在目标图像中的分布</p><p>主要思路是提取已知图像的Hue(色相)空间,做出直方图,再反向找到这些色相在目标图片中的分布,已知图像中越多的色相,在backProject中就会(看起来)更亮,利用这点加上一些二值化,就可以得到一张目标物体的掩膜,覆盖到目标图片上就可以得到完成的图像了,如下</p><hr><h3 id="源-读取TIM图标-在桌面截图上找到他"><a href="#源-读取TIM图标-在桌面截图上找到他" class="headerlink" title="源//读取TIM图标, 在桌面截图上找到他"></a>源//读取TIM图标, 在桌面截图上找到他</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Mat hue;</span><br><span class="line">Mat target_hue;</span><br><span class="line"><span class="keyword">int</span> bins = <span class="number">25</span>;</span><br><span class="line">Mat src_mask_globle;</span><br><span class="line">Mat target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读入src</span></span><br><span class="line">    <span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">"&#123;@input |D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Tim.png  | input image&#125;"</span>)</span></span>;</span><br><span class="line">    Mat src = imread(parser.<span class="built_in">get</span>&lt;<span class="keyword">String</span>&gt;(<span class="string">"@input"</span>));</span><br><span class="line">    <span class="keyword">if</span> (src.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open or find the image!\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" &lt;Input image&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    target = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/屏幕.png"</span>);</span><br><span class="line">    pyrDown(target, target, Size(target.cols / <span class="number">2</span>, target.rows / <span class="number">2</span>));</span><br><span class="line">    pyrDown(target, target, Size(target.cols / <span class="number">2</span>, target.rows / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//pyrDown(src, src, Size(src.cols / 2, src.rows / 2));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二值化取覆膜</span></span><br><span class="line">    Mat src_gray;</span><br><span class="line">    cvtColor(src, src_gray, COLOR_BGR2GRAY);</span><br><span class="line">    Mat src_mask;</span><br><span class="line">    threshold(src_gray, src_mask, <span class="number">0</span>, <span class="number">255</span>, THRESH_TRIANGLE);</span><br><span class="line">    src_mask_globle = src_mask;</span><br><span class="line">    imshow(<span class="string">"BinMask"</span>, src_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//色彩空间转换</span></span><br><span class="line">    <span class="comment">//src = Mat(src.size(), src.type(), Scalar(255, 0, 0));</span></span><br><span class="line">    Mat hsv;</span><br><span class="line">    cvtColor(src, hsv, COLOR_BGR2HSV);</span><br><span class="line">    Mat target_hsv;</span><br><span class="line">    cvtColor(target, target_hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Hue空间通道图像</span></span><br><span class="line">    hue.create(hsv.<span class="built_in">size</span>(), hsv.depth());</span><br><span class="line">    target_hue.create(target_hsv.<span class="built_in">size</span>(), target_hsv.depth());</span><br><span class="line">    <span class="keyword">int</span> ch[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    mixChannels(&amp;hsv, <span class="number">1</span>, &amp;hue, <span class="number">1</span>, ch, <span class="number">1</span>);</span><br><span class="line">    mixChannels(&amp;target_hsv, <span class="number">1</span>, &amp;target_hue, <span class="number">1</span>, ch, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; hue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建滑块并BackProjection</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* window_image = <span class="string">"Source image"</span>;</span><br><span class="line">    namedWindow(window_image);</span><br><span class="line">    createTrackbar(<span class="string">"* Hue  bins: "</span>, window_image, &amp;bins, <span class="number">180</span>, Hist_and_Backproj);</span><br><span class="line">    Hist_and_Backproj(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    imshow(window_image, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until user exits the program</span></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//防止bins太小</span></span><br><span class="line">    <span class="keyword">int</span> histSize = MAX(bins, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算Hue空间直方图</span></span><br><span class="line">    <span class="keyword">float</span> hue_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>* ranges = &#123; hue_range &#125;;</span><br><span class="line">    Mat hist;</span><br><span class="line">    calcHist(&amp;hue, <span class="number">1</span>, <span class="number">0</span>, src_mask_globle, hist, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX, <span class="number">-1</span>, Mat());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BackProjection</span></span><br><span class="line">    Mat backproj;</span><br><span class="line">    calcBackProject(&amp;target_hue, <span class="number">1</span>, <span class="number">0</span>, hist, backproj, &amp;ranges, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    threshold(backproj, backproj, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    imshow(<span class="string">"BackProj"</span>, backproj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制直方图</span></span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">400</span>, h = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">int</span> bin_w = cvRound((<span class="keyword">double</span>)w / histSize);</span><br><span class="line">    Mat histImg = Mat::zeros(h, w, CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rectangle(histImg, Point(i * bin_w, h), Point((i + <span class="number">1</span>) * bin_w, h - cvRound(hist.at&lt;<span class="keyword">float</span>&gt;(i) * h / <span class="number">255.0</span>)),</span><br><span class="line">            Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Histogram"</span>, histImg);</span><br><span class="line"></span><br><span class="line">    Mat focus;</span><br><span class="line">    target.copyTo(focus, backproj);</span><br><span class="line">    imshow(<span class="string">"focus"</span>, focus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/81b2be88.html">http://dynais.xyz/posts/81b2be88.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- equalizeHist();&lt;span class=&quot;comment&quot;&gt;//直方图均衡化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- split();&lt;span class=&quot;comment&quot;&gt;//分离通道&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- calcHist();&lt;span class=&quot;comment&quot;&gt;//参数dims,bin,range&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- waitkey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- mixChannels&lt;span class=&quot;comment&quot;&gt;//分离通道, 与split小有差别,建议看官方文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- cvtColer&lt;span class=&quot;comment&quot;&gt;//使用此api转换到hsv色彩空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- calcHist&lt;span class=&quot;comment&quot;&gt;//接受单通道图像计算直方图, 参数略微复杂&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- normalize&lt;span class=&quot;comment&quot;&gt;//归一化,常用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- compareHist&lt;span class=&quot;comment&quot;&gt;//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- backProject();&lt;span class=&quot;comment&quot;&gt;//直方图反向投影&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记10-霍夫线和圆检测</title>
    <link href="http://dynais.xyz/posts/e1955f21.html"/>
    <id>http://dynais.xyz/posts/e1955f21.html</id>
    <published>2020-02-16T21:00:00.000Z</published>
    <updated>2021-02-21T09:52:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*霍夫线检测 输入图像要先Canny过 参数为</span></span><br><span class="line"><span class="comment">- 输入图像</span></span><br><span class="line"><span class="comment">- 输出向量数组,数据类型为Vec4i(就是两个点)</span></span><br><span class="line"><span class="comment">- 默认1</span></span><br><span class="line"><span class="comment">- 默认CV_PI / 180, 转角步长</span></span><br><span class="line"><span class="comment">- 阈值(我设了100)</span></span><br><span class="line"><span class="comment">- 最小线长</span></span><br><span class="line"><span class="comment">- 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HoughLinesP</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArray lines,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> rho, <span class="keyword">double</span> theta, <span class="keyword">int</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> minLineLength = <span class="number">0</span>, <span class="keyword">double</span> maxLineGap = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*霍夫圆检测 参数从前往后分别是</span></span><br><span class="line"><span class="comment">- 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测)</span></span><br><span class="line"><span class="comment">- 输出向量数组,数据类型位Vec3f</span></span><br><span class="line"><span class="comment">- HOUGH_GRADIENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 图像缩放,默认1</span></span><br><span class="line"><span class="comment">- 圆心最小距离, 小于会认为是同心圆?</span></span><br><span class="line"><span class="comment">- Canny检测的大阈值,小的=大的除二计算</span></span><br><span class="line"><span class="comment">- 点重叠n个以上判定为圆,越小检出越多圆</span></span><br><span class="line"><span class="comment">- 最小圆半径</span></span><br><span class="line"><span class="comment">- 最大圆半径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HoughCircles</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArray circles,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> method, <span class="keyword">double</span> dp, <span class="keyword">double</span> minDist,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> param1 = <span class="number">100</span>, <span class="keyword">double</span> param2 = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> minRadius = <span class="number">0</span>, <span class="keyword">int</span> maxRadius = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>圆检测对噪声敏感, 需要先中值滤波</li><li>太难了,建议看下面的博客,线检测还好,圆检测真的看不懂</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><h3 id="源-检出NXP赛道上的几何图"><a href="#源-检出NXP赛道上的几何图" class="headerlink" title="源//检出NXP赛道上的几何图"></a>源//检出NXP赛道上的几何图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/直道进圆环.jpg"</span>, IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; imgIn;</span></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="keyword">double</span> tCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> tSum = <span class="number">0</span>;</span><br><span class="line">tCount = getTickCount();</span><br><span class="line"></span><br><span class="line">cvtColor(imgIn, imgIn, COLOR_BGR2GRAY);</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line"><span class="comment">//GaussianBlur(imgOut, imgOut, Size(3, 3), 1.4);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//霍夫圆检测</span></span><br><span class="line">imgOut = Mat::zeros(imgIn.<span class="built_in">size</span>(), imgIn.type());</span><br><span class="line"><span class="built_in">vector</span>&lt;Vec3f&gt; circles;</span><br><span class="line">HoughCircles(imgIn, circles, HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">50</span>, <span class="number">125</span>, <span class="number">30</span>);<span class="comment">//参数很难试</span></span><br><span class="line">Vec3f aCircle;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; circles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">aCircle = circles[i];</span><br><span class="line"><span class="built_in">circle</span>(imgOut, Point(aCircle[<span class="number">0</span>],aCircle[<span class="number">1</span>]), aCircle[<span class="number">2</span>], Scalar(<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//霍夫直线检测</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Vec4i&gt; lines;</span><br><span class="line">Canny(imgIn, imgIn, <span class="number">50</span>, <span class="number">125</span>, <span class="number">3</span>);</span><br><span class="line">HoughLinesP(imgIn, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">60</span>, <span class="number">0.0</span>, <span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">Vec4i aLine;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">aLine = lines[i];</span><br><span class="line"><span class="built_in">line</span>(imgOut, Point(aLine[<span class="number">0</span>], aLine[<span class="number">1</span>]), Point(aLine[<span class="number">2</span>], aLine[<span class="number">3</span>]) ,Scalar(<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tSum = (getTickCount() - tCount) / getTickFrequency();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time consume %.4f\n\n"</span>, tSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/e1955f21.html">http://dynais.xyz/posts/e1955f21.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*霍夫线检测 输入图像要先Canny过 参数为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输入图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输出向量数组,数据类型为Vec4i(就是两个点)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 默认1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 默认CV_PI / 180, 转角步长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 阈值(我设了100)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最小线长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HoughLinesP&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, OutputArray lines,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; rho, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; theta, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minLineLength = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; maxLineGap = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*霍夫圆检测 参数从前往后分别是&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输出向量数组,数据类型位Vec3f&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- HOUGH_GRADIENT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 图像缩放,默认1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 圆心最小距离, 小于会认为是同心圆?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- Canny检测的大阈值,小的=大的除二计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 点重叠n个以上判定为圆,越小检出越多圆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最小圆半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最大圆半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HoughCircles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, OutputArray circles,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; method, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dp, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minDist,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; param1 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; param2 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minRadius = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxRadius = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记09-Canny边缘检测算法</title>
    <link href="http://dynais.xyz/posts/80e5fe0.html"/>
    <id>http://dynais.xyz/posts/80e5fe0.html</id>
    <published>2020-02-16T19:00:00.000Z</published>
    <updated>2021-02-21T09:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Canny();<span class="comment">//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p><strong>Canny边缘检测算法可以分为以下5个步骤：</strong></p><ul><li><p>使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)</p></li><li><p>计算图像中每个像素点的梯度强度和方向。</p></li><li><p>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</p></li><li><p>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</p></li><li><p>通过抑制孤立的弱边缘最终完成边缘检测。</p></li></ul></li></ul><ul><li><strong>非极大值抑制:</strong></li></ul><p>细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.</p><a id="more"></a><ul><li><strong>关于几种边缘检测方法:</strong></li></ul><p>Laplance, Canny 和 Sobel 都是边缘检测的方法, Canny是包含了Sobel算子的边缘检测, 所以可以说是Sobel的实际应用, Laplance的检测效果并不好, 但是有其他的用途, 总的来说Canny能应对大多数的场景</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><p>《A Computational Approach to Edge Detection》</p></li><li><p>[1]: <a href="https://www.cnblogs.com/techyan1990/p/7291771.html" target="_blank" rel="noopener">https://www.cnblogs.com/techyan1990/p/7291771.html</a>    “边缘检测之Canny”</p></li></ul><h3 id="源-对NXP赛道进行下采样和边缘检测"><a href="#源-对NXP赛道进行下采样和边缘检测" class="headerlink" title="源//对NXP赛道进行下采样和边缘检测"></a>源//对NXP赛道进行下采样和边缘检测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/直道进圆环.jpg"</span>, IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; imgIn;</span></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="keyword">double</span> tCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> tSum = <span class="number">0</span>;</span><br><span class="line">tCount = getTickCount();</span><br><span class="line"></span><br><span class="line">cvtColor(imgIn, imgOut, COLOR_BGR2GRAY);<span class="comment">//Canny只接受8位深度的灰度图</span></span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));<span class="comment">//下采样</span></span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));</span><br><span class="line"><span class="comment">//GaussianBlur(imgOut, imgOut, Size(3, 3), 1.4);</span></span><br><span class="line"></span><br><span class="line">Canny(imgOut, imgOut, <span class="number">50</span>, <span class="number">125</span>, <span class="number">3</span>);<span class="comment">//第三,四个参数代表上下阈值, 第五个是Sobel算子的大小, 一般取3</span></span><br><span class="line"></span><br><span class="line">tSum = (getTickCount() - tCount) / getTickFrequency();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time consume %.4f\n\n"</span>, tSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/80e5fe0.html">http://dynais.xyz/posts/80e5fe0.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Canny();	&lt;span class=&quot;comment&quot;&gt;//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Canny边缘检测算法可以分为以下5个步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算图像中每个像素点的梯度强度和方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过抑制孤立的弱边缘最终完成边缘检测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非极大值抑制:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记08-Sobel算子</title>
    <link href="http://dynais.xyz/posts/87b7dd44.html"/>
    <id>http://dynais.xyz/posts/87b7dd44.html</id>
    <published>2020-02-15T19:48:00.000Z</published>
    <updated>2021-02-21T09:51:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sobel();<span class="comment">//索贝尔算子</span></span><br><span class="line">Scharr();<span class="comment">//Sobel的加强</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p><strong>Sobel:</strong> <a href="https://www.jianshu.com/p/2a06c68f6c14" target="_blank" rel="noopener">边缘检测算法及各自的优缺点</a></p><p>Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺</p></li></ul><ul><li><p><strong>使用加减来简化计算机的负担:</strong> <a href="https://blog.csdn.net/qq_37124237/article/details/82183177" target="_blank" rel="noopener">sobel算子的原理与实现</a></p><p>乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想</p></li></ul><ul><li><p><strong>整个流程:</strong></p><p> 高斯-&gt;转灰度-&gt;求梯度x与y-&gt;混合</p> <a id="more"></a></li></ul><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/87b7dd44.html">http://dynais.xyz/posts/87b7dd44.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关API&quot;&gt;&lt;a href=&quot;#相关API&quot; class=&quot;headerlink&quot; title=&quot;相关API&quot;&gt;&lt;/a&gt;相关API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Sobel();&lt;span class=&quot;comment&quot;&gt;//索贝尔算子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Scharr();&lt;span class=&quot;comment&quot;&gt;//Sobel的加强&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sobel:&lt;/strong&gt; &lt;a href=&quot;https://www.jianshu.com/p/2a06c68f6c14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;边缘检测算法及各自的优缺点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用加减来简化计算机的负担:&lt;/strong&gt; &lt;a href=&quot;https://blog.csdn.net/qq_37124237/article/details/82183177&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sobel算子的原理与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;整个流程:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 高斯-&amp;gt;转灰度-&amp;gt;求梯度x与y-&amp;gt;混合&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记07-上下采样-高斯不同(DOG)</title>
    <link href="http://dynais.xyz/posts/45be0b87.html"/>
    <id>http://dynais.xyz/posts/45be0b87.html</id>
    <published>2020-02-15T19:39:00.000Z</published>
    <updated>2021-02-21T09:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- pyrUp();<span class="comment">//上采样</span></span><br><span class="line">- pyrDown();<span class="comment">//下采样</span></span><br><span class="line">- subtract();<span class="comment">//图像减法</span></span><br><span class="line"></span><br><span class="line">- threshold()<span class="comment">//二值化</span></span><br><span class="line">- binarythreshold()<span class="comment">//还是二值化</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><strong>高斯金字塔:</strong><br>涉及到上采样和下采样的概念<br>实现步骤是:   1.高斯模糊    2.删除当前层偶数行列</li></ul><ul><li><strong>高斯不同(DOG):</strong><br>同图像在不同参数下做高斯模糊然后结果相减, 最后记得归一化, 不然图很淡</li></ul><a id="more"></a><ul><li><p><strong>上/下采样对比几个像素求平均合成的优势:</strong></p><p>最大的好处就是变快了, 在人脸识别那个项目里我自己写了压缩算法,但是速度和这个相差了一倍(在720p下)</p><p>但是也发现这个算法有局限, 首先图像会便模糊, 其次只能实现2的次方倍的缩放(至少根据OpenCV里的API来看)</p></li></ul><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/45be0b87.html">http://dynais.xyz/posts/45be0b87.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- pyrUp();&lt;span class=&quot;comment&quot;&gt;//上采样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- pyrDown();&lt;span class=&quot;comment&quot;&gt;//下采样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- subtract();&lt;span class=&quot;comment&quot;&gt;//图像减法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- threshold()&lt;span class=&quot;comment&quot;&gt;//二值化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- binarythreshold()&lt;span class=&quot;comment&quot;&gt;//还是二值化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯金字塔:&lt;/strong&gt;&lt;br&gt;涉及到上采样和下采样的概念&lt;br&gt;实现步骤是:   1.高斯模糊    2.删除当前层偶数行列&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯不同(DOG):&lt;/strong&gt;&lt;br&gt;同图像在不同参数下做高斯模糊然后结果相减, 最后记得归一化, 不然图很淡&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OpenCV" scheme="http://dynais.xyz/categories/%E7%AC%94%E8%AE%B0/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://dynais.xyz/tags/OpenCV/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
