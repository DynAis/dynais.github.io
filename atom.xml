<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>想成为魔法师的D·y·n·A·i·s</title>
  
  <subtitle>DynAis&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dynais.xyz/"/>
  <updated>2020-07-23T10:34:21.799Z</updated>
  <id>http://dynais.xyz/</id>
  
  <author>
    <name>DynAis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欢迎! Willkommen!</title>
    <link href="http://dynais.xyz/2030/01/01/Willkommen/"/>
    <id>http://dynais.xyz/2030/01/01/Willkommen/</id>
    <published>2029-12-31T16:00:00.000Z</published>
    <updated>2020-07-23T10:34:21.799Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎来到我的个人博客，这是我的第二次尝试，我会尝试持续更新的😉</strong><br><strong>Willkommen zum meinem persönlichen Blog, eigentlich ist das mein zweiter Versuch und ich werde versuchen, der Blog ständig zu aktualisieren😉</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;欢迎来到我的个人博客，这是我的第二次尝试，我会尝试持续更新的😉&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Willkommen zum meinem persönlichen Blog, eigentlich ist das mein zweiter Ver
      
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/project/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>[转载]Hexo+Github Page搭建博客教程</title>
    <link href="http://dynais.xyz/2020/07/23/NT-WEB-%E8%BD%AC%E8%BD%BD-Hexo-Github-Page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>http://dynais.xyz/2020/07/23/NT-WEB-%E8%BD%AC%E8%BD%BD-Hexo-Github-Page%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</id>
    <published>2020-07-23T02:40:06.000Z</published>
    <updated>2020-07-23T09:11:46.605Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">前往原文</a></strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。</p><p>这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p><p>下面就开始吧~</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>准备 node 和 git 环境，<br>首先，安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a>，因为 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。<br>然后，安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git</a> 教程。</p><a id="more"></a><p>两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。<br>在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990237" alt="image"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 的详细文档。<br>在命令行输入执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds # 模版文件夹</span><br><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br><span class="line">|   ├── _drafts # 草稿文件</span><br><span class="line">|   └── _posts # 文章Markdowm文件 </span><br><span class="line">└── themes  # 主题文件夹</span><br></pre></td></tr></table></figure><p>好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:4000 回车就可以预览效果了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990238" alt="image"></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。</p><h2 id="注册-Github"><a href="#注册-Github" class="headerlink" title="注册 Github"></a>注册 Github</h2><p>首先如果你还没有 Github 账号的先<a href="https://github.com/" target="_blank" rel="noopener">注册</a>一个，具体过程如下</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990239" alt="image"></p><p>点击 Start project 或者下面的 new repository 创建一个新的仓库</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990240" alt="image"></p><p>注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990241" alt="image"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World.</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990242" alt="image"><br><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990243" alt="image"></p><p>这个时候打开 <a href="http://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">http://你的用户名.github.io</a> 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 <a href="http://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">http://你的用户名.github.io</a> 看到你自己的博客啦！ 比如我的就是 <a href="http://webw3c.github.io/" target="_blank" rel="noopener">http://webw3c.github.io</a> 了。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990244" alt="image"></p><h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p><p>打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990245" alt="image"></p><p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>然后开始生成密钥 SSH key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;上面的邮箱&#39;</span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/20200723111827.png" alt=""></p><p>（此图引用自码云）</p><p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/20200723111957.png" alt=""></p><p>到这还没完，还要登录 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上添加刚刚生成的SSH key，按以下步骤添加：</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990248" alt="image"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990249" alt="image"></p><h2 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h2><p>此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">部署</a>教程。<br>先不着急，部署之前还需要修改配置和安装部署插件。<br>第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990250" alt="image"></p><p>第二：要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <a href="https://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">https://你的用户名.github.io</a> 就会看到你的博客啦！！</p><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> 官网。<br>新建文章，输入以下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span><br></pre></td></tr></table></figure><p>执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。</p><p>在 Markdown 文章里面输入你的文章内容</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990251" alt="image"></p><p>再执行一下以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以看到你的文章在博客显示了，以下就是刚刚</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/20200723112131.png" alt=""></p><p>最后，只要部署到你的 Github 上就可以了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="静态图床"><a href="#静态图床" class="headerlink" title="静态图床"></a>静态图床</h2><p>文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是<a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules" target="_blank" rel="noopener">测试域名</a>不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。</p><p>可以去chrome网上应用商店下载一个叫<a href="https://chrome.google.com/webstore/detail/微博图床/pinjkilghdfhnkibhcangnpmcpdpmehk?hl=zh-CN" target="_blank" rel="noopener">微博图床</a>的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990253" alt="image"></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题页</a>或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官网使用文档</a>说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。</p><h3 id="一、添加评论系统"><a href="#一、添加评论系统" class="headerlink" title="一、添加评论系统"></a><strong>一、添加评论系统</strong></h3><p><strong><em>注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置\</em></strong></p><p>添加 <a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a> 评论系统，打开 /themes/next/_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990254" alt="image"></p><p>然后到 leanCloud <a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">登录</a>或者<a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册</a> 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990255" alt="image"></p><h3 id="二、配置腾讯公益404页面"><a href="#二、配置腾讯公益404页面" class="headerlink" title="二、配置腾讯公益404页面"></a><strong>二、配置腾讯公益404页面</strong></h3><ol><li>在博客根目录 /source 文件夹下创建404.html（具体内容见下图及代码）；</li><li>在 html 上方加入上面3行代码；</li></ol><p>腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990256" alt="image"></p><p>上图最前面的那几行也要加进去哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">title: &quot;404&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这里放一下上面用到的几个js链接，来自腾讯公益404官方<a href="https://www.qq.com/404/" target="_blank" rel="noopener">接入文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;plain&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;https:&#x2F;&#x2F;pojian.xyz&quot; homePageName&#x3D;&quot;回到我的博客主页&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;data.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;page.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>你也可以直接复制我 Github 上的<a href="https://github.com/webw3c/webw3c.github.io/blob/master/404.html" target="_blank" rel="noopener">404页面代码</a>，以下是我博客的预览效果。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990257" alt="image"></p><p>另外如果需要自定义个性化404页面的只要删除相应腾讯的JS，直接修改上面的 404.html 文件就可以了。</p><h3 id="三、添加字数统计和阅读时长"><a href="#三、添加字数统计和阅读时长" class="headerlink" title="三、添加字数统计和阅读时长"></a><strong>三、添加字数统计和阅读时长</strong></h3><p>首先安装一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>接着博客根目录下的配置文件里添加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文章字数统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure><p>最后到 next 主题的配置文件下开启 symbols_count_time 字段</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990258" alt="image"></p><p>重启一下 hexo 就可以看到效果啦</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990259" alt="image"></p><h3 id="四、开启fancybox"><a href="#四、开启fancybox" class="headerlink" title="四、开启fancybox"></a><strong>四、开启fancybox</strong></h3><p>打开主题配置文件搜索 fancybox 设置为 true，另外，vendors 填上对应 CDN 地址即可开启</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990260" alt="image"></p><h3 id="五、文章分享"><a href="#五、文章分享" class="headerlink" title="五、文章分享"></a><strong>五、文章分享</strong></h3><p>百度分享有个 https 的坑，按网上的方法把文件放到自己的服务器是我以前在其他的网站上测试过是能使用的，但在 hexo 中却报错了，具体不清楚是什么原因，感觉可能是 hexo 版本的问题，因为有的人可以，有的人报和我一样的错误，忘记截图了。因为这个功能也没有十分需要，就不继续爬了。换了 <a href="https://github.com/overtrue/share.js" target="_blank" rel="noopener">share.js</a> 实现了同样的功能，具体可以看本文文末的效果。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>如果你感觉直接使用 github.io 的域名作为你的博客链接不够专业，不够程序员的话那么就购买一个域名解析绑定到你的博客，我也比较建议这样做。<br>我的是在阿里万网<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.17.365b4f157s4Od7" target="_blank" rel="noopener">注册</a>的，注册流程比较常规这里就不多详述了，</p><p>注册登录控制台后找到你的域名，点右侧的解析按钮进去解析列表</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990261" alt="image"><br><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990262" alt="image"></p><p>点右边的“添加记录”添加两条 CNAME 类型的记录，如上图，后面的记录值就填写你们自己的 Github 地址哈</p><p>记录添加完后就要到 <a href="https://www.github.com/" target="_blank" rel="noopener">Github</a> 设置绑定你购买的域名了，进入你的博客仓库点 Setting，然后拉到 GitHub Pages 那里填上你的申请购买的域名保存就可以了</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990263" alt="image"><br><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990264" alt="image"></p><p>这里说下，当你点击保存的时候 Github Pages 会自动帮你生成一个 CNAME 的文件在根目录，里面的内容就是你绑定的域名地址</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990265" alt="image"></p><p>注意，如果是按上面的方法操作还会有一点小问题，就是当你执行 hexo d 部署你本地的文章到 Github 时，你本地的文件会全部覆盖掉你现有仓库上的所有内容，包括 Github Pages 帮你创建的那个 CNAME 文件，这样的话当你访问域名的时候又会访问不到了。所以呢，你需要自己手动在本地根目录 /source 目录下手动创建一个 CNAME 文件，内容就是你的域名地址，因为 source 目录下的文件部署的时候是不会被删除的，所以部署的时候也会一起被部署上去，最后还需要重新到你仓库 Setting，拉到 GitHub Pages 那里再一次绑定你的域名，这样以后就没问题了。</p><p>稍等一会就可以用你申请的域名就访问你的博客了！</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>接下来说下百度收录，据说 Github 屏蔽了百度的蜘蛛，也有的人说没，具体不是很清楚，Github 在2015的时候遭受了史上最大规模的DDoS攻击，有国外媒体指百度干的，具体不得而知啦，但感觉百度收录 Github 确认是比较难，时间也比较长，所以还是优化一下吧。</p><h3 id="一、代码同时部署到-coding"><a href="#一、代码同时部署到-coding" class="headerlink" title="一、代码同时部署到 coding"></a>一、代码同时部署到 coding</h3><p>那有什么方法呢？就是把博客站点同时托管在国内的 coding 平台上，这样收录就会容易很多，同时又不影响 Github 上的代码，<a href="https://coding.net/" target="_blank" rel="noopener">coding</a> 是国内的一个提供代码托管服务的平台，跟 Github 差不多。使用方法也和 Github 差不多，下面我就具体说一下怎么把代码同时部署到 coding 和 Github 上面，让百度更容易收录。</p><p><a href="https://coding.net/register" target="_blank" rel="noopener">注册</a>、<a href="https://coding.net/login" target="_blank" rel="noopener">登录</a> coding 后创建一个新的仓库，注意点就是新建项目的时候命名规则和 Github 上的一样，就是 <strong>用户名.coding.me</strong> 可以看下图，还有记得别忘了添加 SSH key</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990266" alt="image"></p><p>仓库建好后进入仓库，选左侧的 Page 服务，在设置中绑定新的域名，输入后点击绑定就可以了</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990267" alt="image"></p><p>接着到你的域名解析控制台修改添加两条 CNAME 记录指向你的 Page 地址，看下图，注意看记录值哦，换成你自己的。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990268" alt="image"></p><p>最后呢修改根目录下的 _config.yml 配置文件中的部署配置，把 coding 的 git 地址添加进去就行了</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990269" alt="image"></p><p>最后执行部署命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>这时就可以在 coding 仓库中看到你提交部署的代码了，同时 你的用户名.coding.me 也可以访问你的博客站点了，这里 Github 和 coding 的代码是同时更新的，互不影响。而绑定的域名解析可能需要稍等一会才会生效。</p><h3 id="二、百度提交链接"><a href="#二、百度提交链接" class="headerlink" title="二、百度提交链接"></a>二、百度提交链接</h3><p>部署到 coding 后也不是百度就可以收录的，我们还需要继续优化。如果在百度搜索输入 site:你的域名 如果出现以下的效果证明就是网站还没被百度收录的，我们现在点下面的<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">提交网址</a>，进入百度站长工具提交。</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990270" alt="image"></p><h3 id="三、百度站长平台添加网站管理"><a href="#三、百度站长平台添加网站管理" class="headerlink" title="三、百度站长平台添加网站管理"></a>三、百度站长平台添加网站管理</h3><p>注册<a href="https://ziyuan.baidu.com/site/" target="_blank" rel="noopener">百度站长</a>工具，并添加网站</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990271" alt="image"></p><p>添加网站的过程有三步，主要操作集中在最后一步的网站验证方式里，我选择的是 HTML标签验证，按下面使用方法添加代码到你的网站即可</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990272" alt="image"></p><p>而使用 next 主题的同学可以直接在主题的配置文件下搜索 baidu_site_verification 后面填上第三步中 meta 标签中 content 的值就可以</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990273" alt="image"></p><p>最后点完成验证就可以通过了。</p><h3 id="四、添加sitemap站点地图"><a href="#四、添加sitemap站点地图" class="headerlink" title="四、添加sitemap站点地图"></a>四、添加sitemap站点地图</h3><p>站点地图包含了你网站上的站点链接，方便搜索引擎蜘蛛的抓取工作，搜索蜘蛛会通过网站地图中链接的深层次爬行，抓取新的内容。所以我们要生成 sitemap 文件助于网站优化，安装生成插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>接着在博客根目录下的配置文件里添加对应配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>注意缩进，要不会编译报错</p><p>还要修改一个根目录配置文件下的URL，url 一项的值改成你在百度站长平台里面添加的自己站点的地址，这样生成的 sitemap.xml 文件里的 url 才是你站点的地址，看下图</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990274" alt="image"></p><h3 id="五、添加蜘蛛协议robots-txt"><a href="#五、添加蜘蛛协议robots-txt" class="headerlink" title="五、添加蜘蛛协议robots.txt"></a>五、添加蜘蛛协议robots.txt</h3><p>增加 robots.txt 文件，就是蜘蛛协议，新建 robots.txt 文件添加以下内容，把 robots.txt 放在 /source 文件下，我们前面说过 /source 目录下的文件是会被打包上传的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;pojian.xyz&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;pojian.xyz&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow后面的就是你的menu，还有最下面的 Sitemap 地址请自行改成你们自己的地址</p><p>完成后，重启hexo，执行 hexo g -d 重新生成文件并提交后，在public目录下会生成对应的xml文件。可以通过 <a href="http://xxx.com/sitemap.xml" target="_blank" rel="noopener">http://xxx.com/sitemap.xml</a> 和 <a href="http://xxx.com/baidusitemap.xml" target="_blank" rel="noopener">http://xxx.com/baidusitemap.xml</a> 访问到 sitemap 文件，通过 <a href="http://xxx.com/robots.txt" target="_blank" rel="noopener">http://xxx.com/robots.txt</a> 访问到 robots.txt 文件。</p><p>可以到百度站长检测一下 robots.txt 文件是否生效</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990275" alt="image"></p><h3 id="六、自动推送"><a href="#六、自动推送" class="headerlink" title="六、自动推送"></a>六、自动推送</h3><p>百度有自动推送、主动推送、sitemap、手动提交几种方式。<br>自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。怎么安装呢？<br>如果你的是 next 主题，只要打开主题配置文件搜索找到 baidu_push 设置为 true 即可</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990276" alt="image"></p><p>如果你使用的不是 next 主题，也可以手动把以下代码粘贴到你的站点，一般放在 head 头部公共文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="七、主动推送"><a href="#七、主动推送" class="headerlink" title="七、主动推送"></a>七、主动推送</h3><p>这里利用一个第三方插件 <a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">hexo-baidu-url-submit</a> 进行主动推送<br>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>添加想关配置到根目录下的配置文件里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 百度链接提交-主动推送配置</span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3 ## 提交最新的一个链接</span><br><span class="line">  host: pojian.xyz ## 在百度站长平台中注册的域名</span><br><span class="line">  token: 3GIEYsuq5ZTkvDBm ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p>添加新的部署配置，注意这里跟之前有点不一样，要在 type 前添加一个破折号 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      github: https:&#x2F;&#x2F;github.com&#x2F;webw3c&#x2F;webw3c.github.io.git</span><br><span class="line">      coding: https:&#x2F;&#x2F;git.dev.tencent.com&#x2F;yusting&#x2F;yusting.coding.me.git</span><br><span class="line">  - type: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>最后，执行 hexo deploy 的时候，新的连接就会被推送了。<br><strong>实现原理</strong><br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="八、手动推送"><a href="#八、手动推送" class="headerlink" title="八、手动推送"></a>八、手动推送</h3><p>就是直接直接把你需要提交的链接直接使用手动的方式填写提交就可以。</p><p>最后你可以看到是否已经被百度成功收录了</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990277" alt="image"></p><p>如果抓取成功了就证明已经被收录了，好像一般不会这么快，我的等了两天左右才抓取得到。</p><h3 id="九、添加百度统计"><a href="#九、添加百度统计" class="headerlink" title="九、添加百度统计"></a>九、添加百度统计</h3><p>添加<a href="https://tongji.baidu.com/web/homepage/index" target="_blank" rel="noopener">百度统计</a>就可以查看你网站相关的一些数据，便于你自己的站点</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990278" alt="image"></p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/1460000017990279" alt="image"></p><h2 id="多端同步写作"><a href="#多端同步写作" class="headerlink" title="多端同步写作"></a>多端同步写作</h2><p>原理就是利用 Git 的分支功能，比如新建立一个 blog 分支来存放 Hexo 的源文件，而 master 分支则用来放编译后的静态文件，这样在使用另外一台电脑编写的时候只要把 blog 分支拉取下来然后进行写作再 push 到分支就可以了。具体内容或者步骤后续会有更新。。。</p><h2 id="手机编写"><a href="#手机编写" class="headerlink" title="手机编写"></a>手机编写</h2><p>网上好像找不到什么资料，不过通过在手机端安装 SSH 客户端远程操作服务器端，安装配置 node / git / hexo 环境编写应该可以的，原理同多台电脑编写差不多，不过这样做不太省心，不折腾了哈。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章到这差不多啦！后续有些小点深入学习后还是会保持更新的，希望文章对曾经像我一样的小白有那么一点帮助，技术有限，难免有纰漏，欢迎指正批评和讨论，感谢阅读！:-)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000017986794&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前往原文&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。&lt;/p&gt;
&lt;p&gt;这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。&lt;/p&gt;
&lt;p&gt;下面就开始吧~&lt;/p&gt;
&lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;p&gt;准备 node 和 git 环境，&lt;br&gt;首先，安装 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NodeJS&lt;/a&gt;，因为 &lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。&lt;br&gt;然后，安装 &lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git&lt;/a&gt;，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt; 教程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/project/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
      <category term="hexo" scheme="http://dynais.xyz/tags/hexo/"/>
    
      <category term="github-page" scheme="http://dynais.xyz/tags/github-page/"/>
    
  </entry>
  
  <entry>
    <title>Hallo-World</title>
    <link href="http://dynais.xyz/2020/07/21/HalloWorld/"/>
    <id>http://dynais.xyz/2020/07/21/HalloWorld/</id>
    <published>2020-07-21T09:36:35.000Z</published>
    <updated>2020-07-23T09:36:20.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是一篇测试文档"><a href="#这是一篇测试文档" class="headerlink" title="这是一篇测试文档"></a>这是一篇测试文档</h2><h3 id="这是一篇测试文档-1"><a href="#这是一篇测试文档-1" class="headerlink" title="这是一篇测试文档"></a>这是一篇测试文档</h3><h4 id="这是一篇测试文档-2"><a href="#这是一篇测试文档-2" class="headerlink" title="这是一篇测试文档"></a>这是一篇测试文档</h4><h5 id="这是一篇测试文档-3"><a href="#这是一篇测试文档-3" class="headerlink" title="这是一篇测试文档"></a>这是一篇测试文档</h5><hr><p>这是一篇测试文档</p><p><strong>这是一篇测试文档</strong></p><p><em>这是一篇测试文档</em></p><p><code>这是一篇测试文档</code></p><blockquote><p>这是一篇测试文档</p></blockquote><a id="more"></a><p><blockquote><p>这是一篇测试文档</p></blockquote></p><p><div class="alert danger info"><p>这是一篇测试文档</p></div></p><p><span class="highlight-text blue">这是一篇测试文档</span></p><script type="math/tex; mode=display">\lim_{x}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"this is a test file"</span>)</span><br></pre></td></tr></table></figure><p><div class="figure center" style="width:;"><a class="fancybox" href="Lena.jpg" title="this is a test img" data-caption="this is a test img" data-fancybox="test"><img class="fig-img" src="Lena.jpg" alt="this is a test img"></a><span class="caption">this is a test img</span></div><div style="clear:both;"></div></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=73527536&bvid=BV1CE411a7WH&cid=125771837&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这是一篇测试文档&quot;&gt;&lt;a href=&quot;#这是一篇测试文档&quot; class=&quot;headerlink&quot; title=&quot;这是一篇测试文档&quot;&gt;&lt;/a&gt;这是一篇测试文档&lt;/h2&gt;&lt;h3 id=&quot;这是一篇测试文档-1&quot;&gt;&lt;a href=&quot;#这是一篇测试文档-1&quot; class=&quot;headerlink&quot; title=&quot;这是一篇测试文档&quot;&gt;&lt;/a&gt;这是一篇测试文档&lt;/h3&gt;&lt;h4 id=&quot;这是一篇测试文档-2&quot;&gt;&lt;a href=&quot;#这是一篇测试文档-2&quot; class=&quot;headerlink&quot; title=&quot;这是一篇测试文档&quot;&gt;&lt;/a&gt;这是一篇测试文档&lt;/h4&gt;&lt;h5 id=&quot;这是一篇测试文档-3&quot;&gt;&lt;a href=&quot;#这是一篇测试文档-3&quot; class=&quot;headerlink&quot; title=&quot;这是一篇测试文档&quot;&gt;&lt;/a&gt;这是一篇测试文档&lt;/h5&gt;&lt;hr&gt;
&lt;p&gt;这是一篇测试文档&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是一篇测试文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这是一篇测试文档&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;这是一篇测试文档&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一篇测试文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/project/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>读后感-&lt;如何学习&gt;</title>
    <link href="http://dynais.xyz/2020/06/17/NT-NR-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://dynais.xyz/2020/06/17/NT-NR-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-07-23T10:39:47.699Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="第一部分-搜集"><a href="#第一部分-搜集" class="headerlink" title="第一部分 搜集"></a>第一部分 搜集</h2><ul><li><p>使用番茄工作法, <strong>降低时间到25分钟</strong>, 并且保证25点一到<strong>马上停止</strong>,保证<strong>更多次的打断工作</strong></p></li><li><p>大脑喜欢随机的正向刺激, 每个番茄结束后<strong>设立随机奖励机制</strong></p></li><li><p>更多的学习场景有助于记忆和学习, <strong>不必特意限制自己的学习时间段</strong></p></li><li>拉开时间间隔, 保持学习顺序的随机性, <strong>同一块内容可以不一定要连在一起学</strong>, 穿插其他的内容也有助于学习, 不必局限</li></ul><h2 id="第二部分-内化"><a href="#第二部分-内化" class="headerlink" title="第二部分 内化"></a>第二部分 内化</h2><ul><li>如果有一个感觉<strong>困难或者很大的项目</strong>, <strong>尽早开始</strong>, 未完成的项目会调动大脑的敏锐度, 产生更多的思路, 也有助于在生活中进行”渗滤”<a id="more"></a></li><li><p><strong>预考</strong>能提升对知识的敏感度, 有条件就可以预考, 形式最好为单选题</p></li><li><p><strong>自测</strong>能相当程度上得提升学习的效率, 同时也是一种复习的手段, 自测的方式可以多样, 能够结合学过的知识更好, 同时, <strong>写项目笔记同样是一种自测, 并且还能同时进行反思</strong></p></li><li><p>在<strong>黔驴技穷的时候放下工作</strong>, 去干其他的事或者休息, 大脑会处于敏锐期, 有助于产生新的点子或思路</p></li><li><p>睡眠有助于链接知识, 对于我来说,最重要的是保证更多次的快速眼动睡眠阶段, <strong>午睡一小时</strong>刚好可以出发第一次快速眼动, 而<strong>早上不必特意醒得很早</strong>, 因为那里有较多的快速眼动期</p></li></ul><h2 id="第三部分-复习"><a href="#第三部分-复习" class="headerlink" title="第三部分 复习"></a>第三部分 复习</h2><ul><li>复习遵守时间间隔原则, 第二天, 一星期, 一个月… 可以借助 <strong>Anki</strong> 和 <strong>Marginnote</strong> 的卡片功能进行<strong>日期规划</strong>, 记住, 过早或过晚的复习都不好, 在尽可能大的时间间隔而又可以大致记得内容的时间下复习是最好的</li><li><p><strong>不要害怕遗忘</strong>, 遗忘后重拾的记忆会更加牢固</p></li><li><p>复习时<strong>避免产生”熟练度”错觉</strong>, 也就是<strong>避免直白的看笔记或者在书上划线</strong>之类, 会造成”我很强”的错觉, 消除它的有效办法就是自测</p></li></ul><h2 id="第-X-部分-知觉学习"><a href="#第-X-部分-知觉学习" class="headerlink" title="第$X$部分 知觉学习"></a>第$X$部分 知觉学习</h2><p>这是一个特殊的学习, 用于<strong>对符号元素的快速辨认</strong>, 包括但不限于画作的画派或者单词之类. 知觉训练是一种感觉的训练, 使人快速拥有有”我知道他是这个,但我说不清楚为什么”的感觉</p><p>方法是<strong>制作一堆单选题</strong>, 以观察物作为题目, 状态作为答案进行自测, 题量不能太小, 同时需要<strong>作答时的解题速度比较快</strong>, 最好限定在几秒之内, 做完后可以进行自测, 但需要另一组没有出现在训练中的题目</p><p>可以尝试编程自动生成题目</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;第一部分-搜集&quot;&gt;&lt;a href=&quot;#第一部分-搜集&quot; class=&quot;headerlink&quot; title=&quot;第一部分 搜集&quot;&gt;&lt;/a&gt;第一部分 搜集&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用番茄工作法, &lt;strong&gt;降低时间到25分钟&lt;/strong&gt;, 并且保证25点一到&lt;strong&gt;马上停止&lt;/strong&gt;,保证&lt;strong&gt;更多次的打断工作&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大脑喜欢随机的正向刺激, 每个番茄结束后&lt;strong&gt;设立随机奖励机制&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更多的学习场景有助于记忆和学习, &lt;strong&gt;不必特意限制自己的学习时间段&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;拉开时间间隔, 保持学习顺序的随机性, &lt;strong&gt;同一块内容可以不一定要连在一起学&lt;/strong&gt;, 穿插其他的内容也有助于学习, 不必局限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第二部分-内化&quot;&gt;&lt;a href=&quot;#第二部分-内化&quot; class=&quot;headerlink&quot; title=&quot;第二部分 内化&quot;&gt;&lt;/a&gt;第二部分 内化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果有一个感觉&lt;strong&gt;困难或者很大的项目&lt;/strong&gt;, &lt;strong&gt;尽早开始&lt;/strong&gt;, 未完成的项目会调动大脑的敏锐度, 产生更多的思路, 也有助于在生活中进行”渗滤”
    
    </summary>
    
    
      <category term="live" scheme="http://dynais.xyz/categories/live/"/>
    
      <category term="有感而发" scheme="http://dynais.xyz/categories/live/%E6%9C%89%E6%84%9F%E8%80%8C%E5%8F%91/"/>
    
    
      <category term="读后感" scheme="http://dynais.xyz/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
      <category term="日常" scheme="http://dynais.xyz/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>计算机语言学习大纲</title>
    <link href="http://dynais.xyz/2020/06/07/NT-CS-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://dynais.xyz/2020/06/07/NT-CS-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-07-23T09:11:05.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法部分"><a href="#基础语法部分" class="headerlink" title="基础语法部分"></a>基础语法部分</h2><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><ul><li>数据类型</li><li><p>作用域</p></li><li><p>逻辑/算术操作</p></li></ul><h5 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h5><ul><li>循环</li><li>选择</li></ul><h5 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h5><ul><li><p>数据结构的实现与基本操作</p><ul><li>列表</li><li><p>队列</p><a id="more"></a></li><li><p>优先队列</p></li><li>链表</li><li>集合</li></ul></li><li><p>字典</p><ul><li>堆</li><li>栈</li></ul></li><li><p>算法的实现</p><ul><li>排序</li></ul></li></ul><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><ul><li>字符串数字转换</li><li>字符串反转</li><li>字符串截取</li><li>字符串单位操作</li><li>字符替换</li><li>字符查找</li></ul><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul><li>函数的定义</li><li>变量的传递<ul><li>传递的形式</li><li>特殊数据结构的传递</li><li>不定变量个数的传递</li></ul></li><li>函数的返回</li><li>函数重载</li><li>匿名函数</li><li>内置函数<ul><li>随机</li><li>系统时间获取</li></ul></li></ul><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><ul><li>类的定义</li><li>继承</li><li>函数重写</li><li>枚举</li></ul><h5 id="I-O操作-文件读写"><a href="#I-O操作-文件读写" class="headerlink" title="I/O操作, 文件读写"></a>I/O操作, 文件读写</h5><ul><li>命令行输入输出</li><li>文件读写<ul><li>打开和关闭文件</li><li>文件指针控制</li></ul></li></ul><h5 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h5><ul><li>函数引入</li><li>数据储存</li></ul><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ul><li>处理异常</li><li>定义异常</li><li>抛出异常</li></ul><h5 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h5><ul><li>命令行应用<ul><li>命令行参数的传入</li></ul></li></ul><h2 id="功能库部分"><a href="#功能库部分" class="headerlink" title="功能库部分"></a>功能库部分</h2><h5 id="桌面可视化可交互应用库"><a href="#桌面可视化可交互应用库" class="headerlink" title="桌面可视化可交互应用库"></a>桌面可视化可交互应用库</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础语法部分&quot;&gt;&lt;a href=&quot;#基础语法部分&quot; class=&quot;headerlink&quot; title=&quot;基础语法部分&quot;&gt;&lt;/a&gt;基础语法部分&lt;/h2&gt;&lt;h5 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作用域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑/算术操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;控制流程&quot;&gt;&lt;a href=&quot;#控制流程&quot; class=&quot;headerlink&quot; title=&quot;控制流程&quot;&gt;&lt;/a&gt;控制流程&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;循环&lt;/li&gt;
&lt;li&gt;选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据结构的实现与基本操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表&lt;/li&gt;
&lt;li&gt;&lt;p&gt;队列&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="计算机科学" scheme="http://dynais.xyz/categories/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="计算机科学" scheme="http://dynais.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用差分散列的重复图片检测</title>
    <link href="http://dynais.xyz/2020/04/22/NT-OCPY-%E4%BD%BF%E7%94%A8%E5%B7%AE%E5%88%86%E6%95%A3%E5%88%97%E6%A3%80%E6%B5%8B%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"/>
    <id>http://dynais.xyz/2020/04/22/NT-OCPY-%E4%BD%BF%E7%94%A8%E5%B7%AE%E5%88%86%E6%95%A3%E5%88%97%E6%A3%80%E6%B5%8B%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-07-23T09:43:40.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning"><a href="#Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning" class="headerlink" title="Detect and remove duplicate images from a dataset for deep learning"></a>Detect and remove duplicate images from a dataset for deep learning</h2><!-- toc --><blockquote><p>文章链接:</p><p><a href="https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/</a></p><p><a href="https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb" target="_blank" rel="noopener">https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb</a></p><p>前言: </p><p>为什么要删去数据集中重复的图片?</p><p><em>Having duplicate images in your dataset creates a problem for two reasons:</em></p><ol><li><em>It introduces bias into your dataset, giving your deep neural network additional opportunities to learn patterns specific to the duplicates</em></li><li><em>It hurts the ability of your model to generalize to new images outside of what it was trained on</em></li></ol><p><em>Take the time to remove duplicates from your image dataset so you don’t accidentally introduce bias or hurt the ability of your model to generalize.</em></p></blockquote><a id="more"></a><h2 id="一-关于图像散列值"><a href="#一-关于图像散列值" class="headerlink" title="一. 关于图像散列值"></a>一. 关于图像散列值</h2><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image_hashing_header.png" alt="img" style="zoom: 67%;" /></p><p>关于散列(Hash), 网上的介绍有很多,这里就不费力介绍.</p><p>而对于这个具体的项目要求来说, 我们所做的只是需要把一个图像转换为一个Hash值, 然后储存到字典中. 并且有一下要求:</p><ul><li>视觉上相差不大的图片, 他们的Hash值也应该相同</li><li>这个Hash计算需要快, 因为有时候数据量会很大</li></ul><p>那么我们有以下几个Hash函数的选择:</p><ul><li><strong>差分散列(<em>difference hashing</em>)</strong></li><li><strong>md5</strong></li><li><strong>sha-1</strong></li></ul><p>最终我们选择了<strong>差分散列</strong>的方法, 有以下的原因:</p><ol><li>差分散列速度很快, 计算量小</li><li>对于肉眼相差不大的图片, 差分散列可以得出相似的值</li><li>md5 和 sha-1 只要有一点变化, 输出值就会完全改变(这本来很好, 但在这里非常不好!)</li></ol><h2 id="二-我们所需的步骤"><a href="#二-我们所需的步骤" class="headerlink" title="二. 我们所需的步骤"></a>二. 我们所需的步骤</h2><h3 id="1-Convert-to-grayscale-转灰度"><a href="#1-Convert-to-grayscale-转灰度" class="headerlink" title="1. Convert to grayscale 转灰度"></a>1. Convert to grayscale 转灰度</h3><p>在这里, 颜色信息对于判定两张图是否相同其实并不是很重要, 所以将三通道转为一个通道可以很好的减少我们的工作量</p><h3 id="2-Resize-忽略长宽比缩放"><a href="#2-Resize-忽略长宽比缩放" class="headerlink" title="2. Resize 忽略长宽比缩放"></a>2. Resize 忽略长宽比缩放</h3><p>这是为了得到一个合适的大小, 以便符合后续的Hash计算, 所有需要保证所有的图片具有相同的大小尺寸, 这牵扯到差分散列的工作原理, 这会在后面解释</p><p>在这里, 我们需要将原图缩放到只有$9*8$大小</p><h3 id="3-Compute-the-difference-计算差分-梯度"><a href="#3-Compute-the-difference-计算差分-梯度" class="headerlink" title="3. Compute the difference 计算差分(梯度)"></a>3. Compute the difference 计算差分(梯度)</h3><p>差分散列算法, 故名思与需要计算差分信息, 在图片里, 指的就是相邻像素之间的梯度.</p><p>好了, 这就是之前我们为什么需要$9<em>8$像素的原因了, 因为我们需要得到的是一个64位的二进制信息, 而$8</em>8=64$, 由于是计算差分(梯度), 所以必然需要九行</p><p><strong>需要注意:</strong> 这里虽然说是差分, 但实际上使用的是非常简化的版本: 但前一个像素大于后一个像素时, 给出一个$1$, 否则, 给出一个$0$, 也就是说, 可以看作只提取梯度的正负符号信息, 公式为 </p><p>​                                                $P[x] &gt; P[x + 1] = 1 else 0$</p><p>那么现在我们得到了一个64bit的值, 接下来就对他进行Hash计算</p><h3 id="4-Build-the-hash-计算散列值"><a href="#4-Build-the-hash-计算散列值" class="headerlink" title="4. Build the hash 计算散列值"></a>4. Build the hash 计算散列值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dhash</span><span class="params">(image, hashSize=<span class="number">8</span>)</span>:</span></span><br><span class="line"><span class="comment"># convert the image to grayscale and resize the grayscale image,</span></span><br><span class="line"><span class="comment"># adding a single column (width) so we can compute the horizontal</span></span><br><span class="line"><span class="comment"># gradient</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">resized = cv2.resize(gray, (hashSize + <span class="number">1</span>, hashSize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute the (relative) horizontal gradient between adjacent</span></span><br><span class="line"><span class="comment"># column pixels</span></span><br><span class="line">diff = resized[:, <span class="number">1</span>:] &gt; resized[:, :<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert the difference image to a hash and return it</span></span><br><span class="line"><span class="keyword">return</span> sum([<span class="number">2</span> ** i <span class="keyword">for</span> (i, v) <span class="keyword">in</span> enumerate(diff.flatten()) <span class="keyword">if</span> v])</span><br></pre></td></tr></table></figure><p>我看不懂</p><h3 id="5-初始化字典-寻找重复并输出"><a href="#5-初始化字典-寻找重复并输出" class="headerlink" title="5. 初始化字典, 寻找重复并输出"></a>5. 初始化字典, 寻找重复并输出</h3><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning&quot;&gt;&lt;a href=&quot;#Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning&quot; class=&quot;headerlink&quot; title=&quot;Detect and remove duplicate images from a dataset for deep learning&quot;&gt;&lt;/a&gt;Detect and remove duplicate images from a dataset for deep learning&lt;/h2&gt;&lt;!-- toc --&gt;
&lt;blockquote&gt;
&lt;p&gt;文章链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言: &lt;/p&gt;
&lt;p&gt;为什么要删去数据集中重复的图片?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Having duplicate images in your dataset creates a problem for two reasons:&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;It introduces bias into your dataset, giving your deep neural network additional opportunities to learn patterns specific to the duplicates&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;It hurts the ability of your model to generalize to new images outside of what it was trained on&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Take the time to remove duplicates from your image dataset so you don’t accidentally introduce bias or hurt the ability of your model to generalize.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv-py" scheme="http://dynais.xyz/categories/note/open-cv-py/"/>
    
    
      <category term="python" scheme="http://dynais.xyz/tags/python/"/>
    
      <category term="open-cv-py" scheme="http://dynais.xyz/tags/open-cv-py/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>重构完成, 焕发新生</title>
    <link href="http://dynais.xyz/2020/04/19/PJ-TC04-QT-%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90,%20%E7%84%95%E5%8F%91%E6%96%B0%E7%94%9F/"/>
    <id>http://dynais.xyz/2020/04/19/PJ-TC04-QT-%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90,%20%E7%84%95%E5%8F%91%E6%96%B0%E7%94%9F/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-07-23T09:12:26.961Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li><p>重构了代码</p></li><li><p>修正了大部分bug</p></li></ul><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-Qtimer"><a href="#1-Qtimer" class="headerlink" title="1. Qtimer"></a>1. Qtimer</h3><blockquote><p><a href="https://blog.csdn.net/jia666666/article/details/81672344" target="_blank" rel="noopener">https://blog.csdn.net/jia666666/article/details/81672344</a></p></blockquote><p>Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式</p><h5 id="多次触发"><a href="#多次触发" class="headerlink" title="多次触发"></a>多次触发</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer.timeout.connect(function)</span><br><span class="line">...</span><br><span class="line">timer = Qtimer()</span><br><span class="line">timer.start(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这里<code>timeout</code>是Qtimer的中断信号, 这里设定<code>timer.start(1000)</code>代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块</p><a id="more"></a><p>如果要停止Qtimer,使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer.stop()</span><br></pre></td></tr></table></figure><h3 id="2-自定义信号"><a href="#2-自定义信号" class="headerlink" title="2. 自定义信号"></a>2. 自定义信号</h3><blockquote><p> <a href="https://blog.csdn.net/foreveronly/article/details/82453697" target="_blank" rel="noopener">https://blog.csdn.net/foreveronly/article/details/82453697</a></p></blockquote><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>加完Qtimer中断完全没有问题</p><h3 id="3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug"><a href="#3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug" class="headerlink" title="3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug"></a>3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug</h3><p>通过将子窗口变为主窗口类的成员, 并使用以下语句初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment">#子窗口建立</span></span><br><span class="line">        self.subBreak = BreakWindow(self)<span class="comment"># 注意这里</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreakWindow</span><span class="params">(QDialog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,parent=None)</span>:</span></span><br><span class="line">        super().__init__(parent)</span><br></pre></td></tr></table></figure><p>关键也就是加入<code>def __init__(self,parent=None)</code>, 使主从窗口关联起来(具体实现逻辑尚不清晰), 再加上合理的退出判断, 就可以实现干净的退出了</p><p>响铃bug加完Qtimer中断完后全没有问题</p><h3 id="4-占用cpu过高问题"><a href="#4-占用cpu过高问题" class="headerlink" title="4. 占用cpu过高问题"></a>4. 占用cpu过高问题</h3><p>加完Qtimer中断完全没有问题</p><h3 id="5-交互逻辑混乱问题"><a href="#5-交互逻辑混乱问题" class="headerlink" title="5. 交互逻辑混乱问题"></a>5. 交互逻辑混乱问题</h3><p>通过重构代码逻辑解决了, 现在所有的子窗口都是主窗口的成员了</p><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#1-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="1. Qt里写了中文uic()命令就无法成功执行的问题"></a>1. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>暂时没有思路</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><h3 id="1-实现使用时间的统计模块-尝试使用Mysql来储存数据"><a href="#1-实现使用时间的统计模块-尝试使用Mysql来储存数据" class="headerlink" title="1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据?"></a>1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据?</h3><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>再此理解了那句话, 不能让程序假死, 比如之前我想要time.sleep()来实现…</p><p>正确使用中断是很重要的, 这方面还要多加练习</p><p>并且另外很重要的一点就是, 使用一个库里现成的东西往往整个的整合度会更好</p><p>本来甚至都准备上多线程了…</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重构了代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修正了大部分bug&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-重要代码模块&quot;&gt;&lt;a href=&quot;#一-重要代码模块&quot; class=&quot;headerlink&quot; title=&quot;一. 重要代码模块&quot;&gt;&lt;/a&gt;一. 重要代码模块&lt;/h2&gt;&lt;h3 id=&quot;1-Qtimer&quot;&gt;&lt;a href=&quot;#1-Qtimer&quot; class=&quot;headerlink&quot; title=&quot;1. Qtimer&quot;&gt;&lt;/a&gt;1. Qtimer&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jia666666/article/details/81672344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jia666666/article/details/81672344&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式&lt;/p&gt;
&lt;h5 id=&quot;多次触发&quot;&gt;&lt;a href=&quot;#多次触发&quot; class=&quot;headerlink&quot; title=&quot;多次触发&quot;&gt;&lt;/a&gt;多次触发&lt;/h5&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;timer.timeout.connect(function)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer = Qtimer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer.start(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;timeout&lt;/code&gt;是Qtimer的中断信号, 这里设定&lt;code&gt;timer.start(1000)&lt;/code&gt;代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>又不是不能用, 番茄钟基本功能建设完毕</title>
    <link href="http://dynais.xyz/2020/04/12/PJ-TC03-QT-%E5%8F%88%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E7%94%A8,%20%E7%95%AA%E8%8C%84%E9%92%9F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%BB%BA%E8%AE%BE%E5%AE%8C%E6%AF%95/"/>
    <id>http://dynais.xyz/2020/04/12/PJ-TC03-QT-%E5%8F%88%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E7%94%A8,%20%E7%95%AA%E8%8C%84%E9%92%9F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%BB%BA%E8%AE%BE%E5%AE%8C%E6%AF%95/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-07-23T09:12:22.501Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li>加入了自己指定时间的模块</li></ul><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200412153655534.png" alt="image-20200412153655534" style="zoom:50%;" /></p><ul><li>加入保存用户设置的文件<code>config.json</code></li><li>在倒计时结束时发出铃声通知</li><li>完善了除统计和To Do List外的Menu界面</li></ul><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200412153753123.png" alt="image-20200412153753123" style="zoom:50%;" /></p><ul><li>修正了部分bug</li></ul><a id="more"></a><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-打包程序成exe文件"><a href="#1-打包程序成exe文件" class="headerlink" title="1. 打包程序成exe文件"></a>1. 打包程序成exe文件</h3><h5 id="pyInstaller模块"><a href="#pyInstaller模块" class="headerlink" title="pyInstaller模块"></a>pyInstaller模块</h5><p><code>pyInstaller</code>是python的一个库, 使用它可以很方便的打包文件成为exe可执行文件</p><p>要使用这个库, 首先在Pycharm里安装相应的环境, 之后新建一个.py文件, 比如我的:</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200412160718129.png" alt="image-20200412160718129"></p><p>在里面输入代码(以这次工程为例):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> PyInstaller.__main__ <span class="keyword">import</span> run</span><br><span class="line">    opts=[<span class="string">'main.py'</span>,<span class="string">'-w'</span>,<span class="string">'-F'</span>,<span class="string">'--icon=image/tomato.ico'</span>]</span><br><span class="line">    run(opts)</span><br></pre></td></tr></table></figure><p>其中主要注意<code>opts=[&#39;main.py&#39;,&#39;-w&#39;,&#39;-F&#39;,&#39;--icon=image/tomato.ico&#39;]</code>这一句</p><p><code>main.py</code>是主文件, 是进程的入口</p><p><code>-w</code>这个参数使编译出来的文件时<code>exe</code>+<code>文件</code>的形式, 去掉这个参数编译出来是一个整体的<code>exe</code>文件</p><p><code>-F</code>参数强制编译, 也就是说本次会覆盖上次的文件, 我觉得加上比较好</p><p>最后<code>--icon=image/tomato.ico</code>是我指定的exe文件图标, 需要是一个<code>ico</code>文件</p><p>直接运行<code>.py</code>脚本就可以在<code>/dist</code>里得到编译的文件</p><h5 id="资源文件夹问题"><a href="#资源文件夹问题" class="headerlink" title="资源文件夹问题"></a>资源文件夹问题</h5><p>本次制作番茄钟使用到的资源文件, 比如配置文件, 或者是<code>.MP3</code>的铃声文件, pyInstaller在编译的时候都是不会编译的, 也就是说需要自己将文件复制到产生出来的目录下, 不然程序会报错无法运行</p><h3 id="2-读取和写入配置文件"><a href="#2-读取和写入配置文件" class="headerlink" title="2. 读取和写入配置文件"></a>2. 读取和写入配置文件</h3><h5 id="使用Json作为配置文件"><a href="#使用Json作为配置文件" class="headerlink" title="使用Json作为配置文件"></a>使用Json作为配置文件</h5><p>Json是一种常见的语言, 其中一种用法就是作为书写配置文件的语言, 虽然有人说它不适合作为配置文件语言, 但是小项目用用还是没有问题的</p><p>Json配置文件以<code>{</code>开头, 以<code>}</code>结束, 大括号在Json里代表一个对象, 具有一个键与一个值, 用<code>:</code>对应,</p><p>可以理解为Python里的字典(其实就是)</p><p>用Python的语法来看Json没有一点问题</p><p>如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"tomato"</span>: &#123;<span class="attr">"t_target"</span>: <span class="string">"00:05"</span>, <span class="attr">"t_break"</span>: <span class="string">"00:05"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是Json对语法的要求非常严格, 并且不可以有注释</p><h5 id="Python3读取Json文件"><a href="#Python3读取Json文件" class="headerlink" title="Python3读取Json文件"></a>Python3读取Json文件</h5><p>Python官方内置了Json的使用库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设config是一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Json读取</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"config.json"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> c:</span><br><span class="line">    config = json.load(c)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Json写入</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"config.json"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> c:</span><br><span class="line">    json.dump(config, c)</span><br></pre></td></tr></table></figure><p>读取文件以字典形式展现, 写入的变量也需要是一个字典</p><h3 id="3-在对象方法定义里直接调用具体的实例"><a href="#3-在对象方法定义里直接调用具体的实例" class="headerlink" title="3. 在对象方法定义里直接调用具体的实例"></a>3. 在对象方法定义里直接调用具体的实例</h3><p>发现在对象的方法定义里, 可以直接调用看起来还没有定义的实例, 比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">BreakWindow</span><span class="params">(QtWidgets.QDialog)</span>:</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_a_new_tomato</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        window.start_a_tomato()</span><br></pre></td></tr></table></figure><p>在这里我定义了<code>BreakWindow</code>类, 方法里调用了<code>window.start_a_tomato()</code>, <code>window</code>是另一个类, 并且在后文才定义(当然是在方法调用之前)</p><h3 id="4-循环不退出-使用flag标志的重要性"><a href="#4-循环不退出-使用flag标志的重要性" class="headerlink" title="4. 循环不退出? - 使用flag标志的重要性"></a>4. 循环不退出? - 使用flag标志的重要性</h3><p>因为循环不退出而产生bug已经不知道多少次了, 以后注意在书写循环的时候一定要提前想好尽可能全的情况, 并且写好flag, 循环不在该退的时候退真的很讨厌</p><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-在Python中播放声音-音乐-playsound包"><a href="#1-在Python中播放声音-音乐-playsound包" class="headerlink" title="1. 在Python中播放声音/音乐 - playsound包"></a>1. 在Python中播放声音/音乐 - playsound包</h3><p>在环境里加入playsound包</p><p>调用使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playsound <span class="keyword">import</span> playsound</span><br><span class="line"></span><br><span class="line">playsound(<span class="string">"sound/XXXX.mp3"</span>)</span><br></pre></td></tr></table></figure><p>真的是非常简单的API了</p><p>但是缺点也是太简单了, 几乎没有其他的可操作选项了, 可以看的出来作者基本也是没有什么经验的</p><p>还有一个就是响铃的速度好像不是很快</p><h3 id="2-窗口关闭事件信号-重写closeEvent-方法"><a href="#2-窗口关闭事件信号-重写closeEvent-方法" class="headerlink" title="2. 窗口关闭事件信号 - 重写closeEvent()方法"></a>2. 窗口关闭事件信号 - 重写closeEvent()方法</h3><p>在窗口关闭时, 会执行<code>.closeEvent()</code>方法, 通过重写这个方法, 可以达到检测窗口关闭的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">event.accept()</span><br></pre></td></tr></table></figure><h3 id="3-验证窗口是否在关闭-isHidden"><a href="#3-验证窗口是否在关闭-isHidden" class="headerlink" title="3. 验证窗口是否在关闭 - isHidden()"></a>3. 验证窗口是否在关闭 - isHidden()</h3><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>暂时没有思路</p><h3 id="2-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#2-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="2. Qt里写了中文uic()命令就无法成功执行的问题"></a>2. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>暂时没有思路</p><h3 id="3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug"><a href="#3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug" class="headerlink" title="3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug"></a>3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug</h3><h3 id="4-占用cpu过高问题"><a href="#4-占用cpu过高问题" class="headerlink" title="4. 占用cpu过高问题"></a>4. 占用cpu过高问题</h3><p>猜测是在循环时关闭窗口导致循环还在后台运行, 没有正常退出的问题</p><p>但怎么说这个占用也太夸张了吧就算是我有个循环</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200412164033369.png" alt="image-20200412164033369"></p><p>你一个循环凭什么吃掉我1/4个CPU啊</p><h3 id="5-交互逻辑混乱问题"><a href="#5-交互逻辑混乱问题" class="headerlink" title="5. 交互逻辑混乱问题"></a>5. 交互逻辑混乱问题</h3><p>完全是我的锅, 因为各种小bug, 以及前期准备不足, 经验不到位, 结果使得各种循环判断, 各种地方交错调用, 命名没规范之类…</p><p>导致出现大问题无从下手, 如果要进一步给软件加入功能, 最起码的, 让他<strong>“能用”</strong>, 是肯定要重构代码的</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>虽然程序交互有很大进步, 但还是可以看出我的经验不足, 前期准备缺乏, 导致结构混乱, 后期出现Bug无从下手</p><p>经过这次教训, 我知道了前期纸上的准备和写代码同样重要, 写代码和我整理电脑一样, 都不可以把东西随意乱放, 不然图一时之快只会给以后的自己带来麻烦</p><p>虽然标题上写着<strong>“又不是不能用”</strong>, 但CPU占用如此之高, 进程无法干净退出, 无故响铃的软件, 确实就是<strong>“不能用”</strong>的</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;加入了自己指定时间的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200412153655534.png&quot; alt=&quot;image-20200412153655534&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入保存用户设置的文件&lt;code&gt;config.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在倒计时结束时发出铃声通知&lt;/li&gt;
&lt;li&gt;完善了除统计和To Do List外的Menu界面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200412153753123.png&quot; alt=&quot;image-20200412153753123&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修正了部分bug&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>番茄钟倒计时模块的基本实现</title>
    <link href="http://dynais.xyz/2020/04/10/PJ-TC02-QT-%E7%95%AA%E8%8C%84%E9%92%9F%E5%80%92%E8%AE%A1%E6%97%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://dynais.xyz/2020/04/10/PJ-TC02-QT-%E7%95%AA%E8%8C%84%E9%92%9F%E5%80%92%E8%AE%A1%E6%97%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2020-07-23T09:12:17.462Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li>实现了番茄钟最基本的倒计时功能</li><li>实现了按钮交互的功能</li></ul><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200409231248203.png" alt="image-20200409231248203" style="zoom:50%;" /></p><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-显示时间与计算时间的转换"><a href="#1-显示时间与计算时间的转换" class="headerlink" title="1. 显示时间与计算时间的转换"></a>1. 显示时间与计算时间的转换</h3><a id="more"></a><p>实现倒计时时的一个问题是: 显示的时间格式需要是”XX:XX”, 但是为了方便计算, 需要把这个格式的时间转化为秒数的形式, 这就需要一个显示时间与计算时间互相转换的模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示时间转秒数 "XX:XX" -&gt; flout</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tomato2sec</span><span class="params">(tomato)</span>:</span></span><br><span class="line">    sec = int(tomato[<span class="number">3</span>:])</span><br><span class="line">    sec = sec + <span class="number">60</span> * int(tomato[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 秒数转显示时间 flout -&gt; "XX:XX"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sec2tomato</span><span class="params">(sec)</span>:</span></span><br><span class="line">    t = []</span><br><span class="line">    t.append(str(int(sec / <span class="number">60</span>)))</span><br><span class="line">    t.append(str(int(sec % <span class="number">60</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(t)):</span><br><span class="line">        <span class="keyword">if</span> len(t[i]) &lt; <span class="number">2</span>:</span><br><span class="line">            t[i] = <span class="string">"0"</span> + t[i]</span><br><span class="line"></span><br><span class="line">    tomato = <span class="string">":"</span>.join(t)</span><br><span class="line">    <span class="keyword">return</span> tomato</span><br></pre></td></tr></table></figure><h3 id="2-获取系统时间"><a href="#2-获取系统时间" class="headerlink" title="2. 获取系统时间"></a>2. 获取系统时间</h3><p>获取系统时间在python里我使用的是time包, 还有一个相似的是datetime.time包, 注意不要搞混了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure><p>倒计时的基本思路是点击开始按钮时获取一个开启的系统时间, 然后用户会有一个给定的目标时间, 然后点按钮以后会进入一个循环, 知道计时结束才会退出, 在循环里面一直获取系统时间和其实时间运算就得到了已经过了多久, 再和目标时间判断就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_start &#x3D; time.time()</span><br></pre></td></tr></table></figure><p>这个语句是获取以秒数显示的当前系统时间, 用于运算会比较方便</p><h3 id="3-页面元素的交互"><a href="#3-页面元素的交互" class="headerlink" title="3. 页面元素的交互"></a>3. 页面元素的交互</h3><p>简单的页面元素交互可以在Qt里直接实现</p><p>原理基本上是, 按下按钮之类的东西, 会发出一个信号</p><p><code>ui_window.button_start.clicked</code>这个信号就是<code>ui_window</code>这个窗口下<code>button_start</code>按钮发出的点击信号, 使用<code>connect</code>绑定一个<strong>slot</strong>之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui_window.button_start.clicked.connect(start_a_tomato)</span><br></pre></td></tr></table></figure><p>在这里的意思就是: 单击这个按钮以后执行<code>start_a_tomato</code>函数, 注意函数名在这里不带括号</p><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-倒计时使用time-sleep-效果不好的问题"><a href="#1-倒计时使用time-sleep-效果不好的问题" class="headerlink" title="1. 倒计时使用time.sleep()效果不好的问题"></a>1. 倒计时使用time.sleep()效果不好的问题</h3><p>最开始的思路里, 用户点击开始后进入一个循环, 这个循环每次执行一秒, 然后让页面更新一次, 用到的函数是这个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment">#控制系统空置一秒</span></span><br></pre></td></tr></table></figure><p>但是问题就是, 和单片机上不能乱用<code>delay()</code>一样, 使用<code>sleep()</code>会使程序整个无法响应, 导致拖拽手感奇怪, 且拖拽时倒计时直接停止</p><p>然后换了思路, 直接不断读取系统时间实时刷新, 解决了拖拽手感的问题, 但拖拽时倒计时还是会停止, 不过放下窗口后时间并不会出错, 就先不管了</p><h3 id="2-改变窗口元素但窗口显示不刷新的问题"><a href="#2-改变窗口元素但窗口显示不刷新的问题" class="headerlink" title="2. 改变窗口元素但窗口显示不刷新的问题"></a>2. 改变窗口元素但窗口显示不刷新的问题</h3><p>最开始在循环里改变了元素, 但发现直到循环退出窗口才改变了显示, 但使用print输出又没什么问题, 于是想可能是窗口刷新的问题, 最后的解决办法就一条指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QtWidgets.QApplication.processEvents()</span><br></pre></td></tr></table></figure><p>让窗口刷新</p><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>暂时没有思路</p><h3 id="2-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#2-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="2. Qt里写了中文uic()命令就无法成功执行的问题"></a>2. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>应该是编码不统一的问题, 但是改了Qt的编码几次还是不行, 暂时先用英文顶着, 看看以后有没有解决办法</p><p>暂时没有思路</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><ul><li>加入自己指定时间的模块</li><li>加入保存用户设置的文件</li><li>在倒计时结束时尝试发出通知</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实现了番茄钟最基本的倒计时功能&lt;/li&gt;
&lt;li&gt;实现了按钮交互的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200409231248203.png&quot; alt=&quot;image-20200409231248203&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-重要代码模块&quot;&gt;&lt;a href=&quot;#一-重要代码模块&quot; class=&quot;headerlink&quot; title=&quot;一. 重要代码模块&quot;&gt;&lt;/a&gt;一. 重要代码模块&lt;/h2&gt;&lt;h3 id=&quot;1-显示时间与计算时间的转换&quot;&gt;&lt;a href=&quot;#1-显示时间与计算时间的转换&quot; class=&quot;headerlink&quot; title=&quot;1. 显示时间与计算时间的转换&quot;&gt;&lt;/a&gt;1. 显示时间与计算时间的转换&lt;/h3&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python+Qt5项目环境的搭建</title>
    <link href="http://dynais.xyz/2020/04/08/PJ-TC01-QT-Python+Qt5%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://dynais.xyz/2020/04/08/PJ-TC01-QT-Python+Qt5%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-07-23T09:12:13.193Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="一-软件"><a href="#一-软件" class="headerlink" title="一. 软件"></a>一. 软件</h2><h3 id="1-Pycharm-2019-3-3"><a href="#1-Pycharm-2019-3-3" class="headerlink" title="1. Pycharm 2019.3.3"></a>1. Pycharm 2019.3.3</h3><p>​    Pycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成</p><h3 id="2-Qt-5-12-7-Qt-Creator"><a href="#2-Qt-5-12-7-Qt-Creator" class="headerlink" title="2. Qt 5.12.7 / Qt Creator"></a>2. Qt 5.12.7 / Qt Creator</h3><p>​    Qt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版</p><h2 id="二-环境搭建-对于已有Anaconda3"><a href="#二-环境搭建-对于已有Anaconda3" class="headerlink" title="二. 环境搭建(对于已有Anaconda3)"></a>二. 环境搭建(对于已有Anaconda3)</h2><h3 id="1-Python解释器"><a href="#1-Python解释器" class="headerlink" title="1.Python解释器"></a>1.Python解释器</h3><p>由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用</p><a id="more"></a><h3 id="2-配置环境变量-对于Anaconda3"><a href="#2-配置环境变量-对于Anaconda3" class="headerlink" title="2. 配置环境变量(对于Anaconda3)"></a>2. 配置环境变量(对于Anaconda3)</h3><p>对于Anaconda3的用户, 需要再自行配置一下环境变量, 在环境变量的<code>path</code>选项卡中添加Anaconda的以下目录</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408140342164.png" alt="image-20200408140342164"></p><p>不然在Pycharm中搭建环境时会遇到提示pip无法成功的提示, 导致包无法安装</p><h3 id="3-在Pycharm里搭建环境-安装必要的包"><a href="#3-在Pycharm里搭建环境-安装必要的包" class="headerlink" title="3. 在Pycharm里搭建环境/安装必要的包"></a>3. 在Pycharm里搭建环境/安装必要的包</h3><p>完成以上两步准备就可以开始配置Pycharm了</p><p>首先新建一个项目</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408140546920.png" alt="image-20200408140546920"></p><p>有几点需要注意的地方: </p><p><strong>首先, 确保<code>New environment using</code>中是新建了一个环境,而不是使用Conda.</strong> </p><p><strong>其次, 确保<code>Base interpreter</code>中选择的是<code>pythonw</code>解释器, 而不是<code>python</code></strong></p><p><strong>最后注意, 此处不需勾选</strong></p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408141111529.png" alt="image-20200408141111529"></p><p>然后就可以让它新建一个项目了</p><p>打开工程后进入 <strong>文件 -&gt; 设置 -&gt; 项目 -&gt; Project Interpreter</strong> 在这里管理需要用到的包文件</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408142236868.png" alt="image-20200408142236868" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408142313603.png" alt="image-20200408142313603" style="zoom:50%;" /></p><p>需要使用Qt编程的话, 必须添加<code>QtPy</code>和<code>PyQt5</code>两个包</p><p>Pycharm会自己管理, 下载好就算是配置完成了</p><h2 id="三-工作流"><a href="#三-工作流" class="headerlink" title="三. 工作流"></a>三. 工作流</h2><p>大致的思路是:</p><ul><li>使用Qt Creator创作图形界面</li><li>使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中</li><li>使用Pycharm编写整体逻辑</li></ul><h3 id="1-使用Qt-Creator创作图形界面"><a href="#1-使用Qt-Creator创作图形界面" class="headerlink" title="1. 使用Qt Creator创作图形界面"></a>1. 使用Qt Creator创作图形界面</h3><p>打开Qt Creator新建工程</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408142839431.png" alt="image-20200408142839431" style="zoom:50%;" /></p><p>注意创建时选择桌面图形应用, 这里不需要选Python的那个</p><p><img src="https://raw.githubusercontent.com/DynAis/img-hub/master/img/image-20200408143012126.png" alt="image-20200408143012126" style="zoom:50%;" /></p><p> 工程最好命名为<code>ui</code>, 保存在一个项目文件夹下</p><h3 id="2-使用包内置函数转化Qt的-ui文件为-py文件-作为包导入到程序中"><a href="#2-使用包内置函数转化Qt的-ui文件为-py文件-作为包导入到程序中" class="headerlink" title="2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中"></a>2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中</h3><p>在Pycharm中新建一个<code>builder.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qtpy <span class="keyword">import</span> uic</span><br><span class="line"></span><br><span class="line">uic.compileUiDir(<span class="string">"这里填入Qt工程的文件夹路径"</span>)</span><br></pre></td></tr></table></figure><p>运行便可以得到一个.py文件, 里面是应用程序外观的描述</p><p>在主程序py文件中写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> qtpy <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">from</span> ui.mainwindow <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line">app = QtWidgets.QApplication(sys.argv)<span class="comment">#设置一个App</span></span><br><span class="line"></span><br><span class="line">window = QtWidgets.QMainWindow()<span class="comment">#新建一个窗口</span></span><br><span class="line">ui_window = Ui_MainWindow()<span class="comment">#新建一个导入包中窗口的类</span></span><br><span class="line">ui_window.setupUi(window)<span class="comment">#注意自己的窗口要填入括号</span></span><br><span class="line">window.setWindowTitle(<span class="string">"Tomato Clock v0"</span>)<span class="comment">#设置标题</span></span><br><span class="line"></span><br><span class="line">window.show()<span class="comment">#显示窗口</span></span><br><span class="line"></span><br><span class="line">sys.exit(app.exec_())<span class="comment">#设置退出</span></span><br></pre></td></tr></table></figure><p>设置完成</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;一-软件&quot;&gt;&lt;a href=&quot;#一-软件&quot; class=&quot;headerlink&quot; title=&quot;一. 软件&quot;&gt;&lt;/a&gt;一. 软件&lt;/h2&gt;&lt;h3 id=&quot;1-Pycharm-2019-3-3&quot;&gt;&lt;a href=&quot;#1-Pycharm-2019-3-3&quot; class=&quot;headerlink&quot; title=&quot;1. Pycharm 2019.3.3&quot;&gt;&lt;/a&gt;1. Pycharm 2019.3.3&lt;/h3&gt;&lt;p&gt;​    Pycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成&lt;/p&gt;
&lt;h3 id=&quot;2-Qt-5-12-7-Qt-Creator&quot;&gt;&lt;a href=&quot;#2-Qt-5-12-7-Qt-Creator&quot; class=&quot;headerlink&quot; title=&quot;2. Qt 5.12.7 / Qt Creator&quot;&gt;&lt;/a&gt;2. Qt 5.12.7 / Qt Creator&lt;/h3&gt;&lt;p&gt;​    Qt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版&lt;/p&gt;
&lt;h2 id=&quot;二-环境搭建-对于已有Anaconda3&quot;&gt;&lt;a href=&quot;#二-环境搭建-对于已有Anaconda3&quot; class=&quot;headerlink&quot; title=&quot;二. 环境搭建(对于已有Anaconda3)&quot;&gt;&lt;/a&gt;二. 环境搭建(对于已有Anaconda3)&lt;/h2&gt;&lt;h3 id=&quot;1-Python解释器&quot;&gt;&lt;a href=&quot;#1-Python解释器&quot; class=&quot;headerlink&quot; title=&quot;1.Python解释器&quot;&gt;&lt;/a&gt;1.Python解释器&lt;/h3&gt;&lt;p&gt;由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在Markdown中用Latex插入数学公式</title>
    <link href="http://dynais.xyz/2020/03/05/NT-TEX-Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>http://dynais.xyz/2020/03/05/NT-TEX-Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2020-07-23T09:36:49.146Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FLaTeX" target="_blank" rel="noopener">LaTeX</a>是一种基于<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FTeX" target="_blank" rel="noopener">TeX</a>的文档排版系统,把大片排版的格式细节隐藏在若干样式之后，以内容的逻辑结构统帅纷繁的格式，遂成为现在最流行的科技写作——尤其是数学写作的工具之一.<br> 在Markdown中插入数学公式的语法是 <code>$数学公式$</code> 和 <code>$$数学公式$$</code>.</p><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:</p><div class="table-container"><table><thead><tr><th>示例</th><th>显示</th></tr></thead><tbody><tr><td><code>$2x+3y=34$</code></td><td><img src="https://math.jianshu.com/math?formula=2x%2B3y%3D34" alt="2x+3y=34"></td></tr><tr><td><code>2x+3y=34</code></td><td>2x+3y=34</td></tr></tbody></table></div><p>因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量<img src="https://math.jianshu.com/math?formula=x" alt="x">,也要进入数学模式,使用<code>$1+1=2$</code>,<code>$x$</code>,而不是使用排版普通文字的方式</p><h2 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h2><p>独立公式单独占一行,不和其他文字混编<br> 示例: <script type="math/tex">c=2πr</script></p><a id="more"></a><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><p>在独立公式中使用\\来换行<br> 示例:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$   </span><br><span class="line"><span class="number">2</span>x+<span class="number">3</span>y=<span class="number">34</span>\\   </span><br><span class="line">x+<span class="number">4</span>y=<span class="number">25</span>  </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示:<br> <img src="https://math.jianshu.com/math?formula=2x%2B3y%3D34%5C%5C%20x%2B4y%3D25" alt="2x+3y=34\\ x+4y=25"></p><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>示例</th><th>显示</th></tr></thead><tbody><tr><td>上下标</td><td><code>S=a_{1}^2+a_{2}^2+a_{3}^2$</code></td><td><img src="https://math.jianshu.com/math?formula=S%3Da_%7B1%7D%5E2%2Ba_%7B2%7D%5E2%2Ba_%7B3%7D%5E2" alt="S=a_{1}^2+a_{2}^2+a_{3}^2"></td></tr><tr><td>括号</td><td><code>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</code></td><td><img src="https://math.jianshu.com/math?formula=f(x%2C%20y" alt="f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace">%20%3D%20100%20<em>%20%5Clbrace%5B(x%20%2B%20y)%20</em>%203%5D%20-%205%5Crbrace)</td></tr><tr><td>分数</td><td><code>$\frac{1}{3} 与 \cfrac{1}{3}$</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B3%7D%20%E4%B8%8E%20%5Ccfrac%7B1%7D%7B3%7D" alt="\frac{1}{3} 与 \cfrac{1}{3}"></td></tr><tr><td>开方</td><td><code>$\sqrt[3]{X}$</code>和<code>$\sqrt{5 - x}$</code></td><td><img src="https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7BX%7D" alt="\sqrt[3]{X}">和<img src="https://math.jianshu.com/math?formula=%5Csqrt%7B5%20-%20x%7D" alt="\sqrt{5 - x}"></td></tr></tbody></table></div><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\pm</td><td><img src="https://math.jianshu.com/math?formula=%5Cpm" alt="\pm"></td></tr><tr><td>\times</td><td><img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"></td></tr><tr><td>\div</td><td><img src="https://math.jianshu.com/math?formula=%5Cdiv" alt="\div"></td></tr><tr><td>\mid</td><td><img src="https://math.jianshu.com/math?formula=%5Cmid" alt="\mid"></td></tr><tr><td>\nmid</td><td><img src="https://math.jianshu.com/math?formula=%5Cnmid" alt="\nmid"></td></tr><tr><td>\cdot</td><td><img src="https://math.jianshu.com/math?formula=%5Ccdot" alt="\cdot"></td></tr><tr><td>\circ</td><td><img src="https://math.jianshu.com/math?formula=%5Ccirc" alt="\circ"></td></tr><tr><td>\ast</td><td><img src="https://math.jianshu.com/math?formula=%5Cast" alt="\ast"></td></tr><tr><td>\bigodot</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigodot" alt="\bigodot"></td></tr><tr><td>\bigotimes</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigotimes" alt="\bigotimes"></td></tr><tr><td>\bigoplus</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigoplus" alt="\bigoplus"></td></tr><tr><td>\leq</td><td><img src="https://math.jianshu.com/math?formula=%5Cleq" alt="\leq"></td></tr><tr><td>\geq</td><td><img src="https://math.jianshu.com/math?formula=%5Cgeq" alt="\geq"></td></tr><tr><td>\neq</td><td><img src="https://math.jianshu.com/math?formula=%5Cneq" alt="\neq"></td></tr><tr><td>\approx</td><td><img src="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx"></td></tr><tr><td>\equiv</td><td><img src="https://math.jianshu.com/math?formula=%5Cequiv" alt="\equiv"></td></tr><tr><td>\sum</td><td><img src="https://math.jianshu.com/math?formula=%5Csum" alt="\sum"></td></tr><tr><td>\prod</td><td><img src="https://math.jianshu.com/math?formula=%5Cprod" alt="\prod"></td></tr></tbody></table></div><h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\log</td><td><img src="https://math.jianshu.com/math?formula=%5Clog" alt="\log"></td></tr><tr><td>\lg</td><td><img src="https://math.jianshu.com/math?formula=%5Clg" alt="\lg"></td></tr><tr><td>\ln</td><td><img src="https://math.jianshu.com/math?formula=%5Cln" alt="\ln"></td></tr></tbody></table></div><h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\bot</td><td><img src="https://math.jianshu.com/math?formula=%5Cbot" alt="\bot"></td></tr><tr><td>\angle</td><td><img src="https://math.jianshu.com/math?formula=%5Cangle" alt="\angle"></td></tr><tr><td>\sin</td><td><img src="https://math.jianshu.com/math?formula=%5Csin" alt="\sin"></td></tr><tr><td>\cos</td><td><img src="https://math.jianshu.com/math?formula=%5Ccos" alt="\cos"></td></tr><tr><td>\tan</td><td><img src="https://math.jianshu.com/math?formula=%5Ctan" alt="\tan"></td></tr><tr><td>\cot</td><td><img src="https://math.jianshu.com/math?formula=%5Ccot" alt="\cot"></td></tr><tr><td>\sec</td><td><img src="https://math.jianshu.com/math?formula=%5Csec" alt="\sec"></td></tr><tr><td>\csc</td><td><img src="https://math.jianshu.com/math?formula=%5Ccsc" alt="\csc"></td></tr></tbody></table></div><h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\prime</td><td><img src="https://math.jianshu.com/math?formula=%5Cprime" alt="\prime"></td></tr><tr><td>\int</td><td><img src="https://math.jianshu.com/math?formula=%5Cint" alt="\int"></td></tr><tr><td>\iint</td><td><img src="https://math.jianshu.com/math?formula=%5Ciint" alt="\iint"></td></tr><tr><td>\iiint</td><td><img src="https://math.jianshu.com/math?formula=%5Ciiint" alt="\iiint"></td></tr><tr><td>\oint</td><td><img src="https://math.jianshu.com/math?formula=%5Coint" alt="\oint"></td></tr><tr><td>\lim</td><td><img src="https://math.jianshu.com/math?formula=%5Clim" alt="\lim"></td></tr><tr><td>\infty</td><td><img src="https://math.jianshu.com/math?formula=%5Cinfty" alt="\infty"></td></tr><tr><td>\nabla</td><td><img src="https://math.jianshu.com/math?formula=%5Cnabla" alt="\nabla"></td></tr><tr><td>\mathrm{d}</td><td><img src="https://math.jianshu.com/math?formula=%5Cmathrm%7Bd%7D" alt="\mathrm{d}"></td></tr></tbody></table></div><h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\emptyset</td><td><img src="https://math.jianshu.com/math?formula=%5Cemptyset" alt="\emptyset"></td></tr><tr><td>\in</td><td><img src="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td></tr><tr><td>\notin</td><td><img src="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td></tr><tr><td>\subset</td><td><img src="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td></tr><tr><td>\subseteq</td><td><img src="https://math.jianshu.com/math?formula=%5Csubseteq" alt="\subseteq"></td></tr><tr><td>\supseteq</td><td><img src="https://math.jianshu.com/math?formula=%5Csupseteq" alt="\supseteq"></td></tr><tr><td>\bigcap</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcap" alt="\bigcap"></td></tr><tr><td>\bigcup</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcup" alt="\bigcup"></td></tr><tr><td>\bigvee</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigvee" alt="\bigvee"></td></tr><tr><td>\bigwedge</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigwedge" alt="\bigwedge"></td></tr><tr><td>\biguplus</td><td><img src="https://math.jianshu.com/math?formula=%5Cbiguplus" alt="\biguplus"></td></tr><tr><td>\bigsqcup</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigsqcup" alt="\bigsqcup"></td></tr></tbody></table></div><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container"><table><thead><tr><th>代码</th><th>大写</th><th>代码</th><th>小写</th></tr></thead><tbody><tr><td>A</td><td><img src="https://math.jianshu.com/math?formula=A" alt="A"></td><td>\alpha</td><td><img src="https://math.jianshu.com/math?formula=%5Calpha" alt="\alpha"></td></tr><tr><td>B</td><td><img src="https://math.jianshu.com/math?formula=B" alt="B"></td><td>\beta</td><td><img src="https://math.jianshu.com/math?formula=%5Cbeta" alt="\beta"></td></tr><tr><td>\Gamma</td><td><img src="https://math.jianshu.com/math?formula=%5CGamma" alt="\Gamma"></td><td>\gamma</td><td><img src="https://math.jianshu.com/math?formula=%5Cgamma" alt="\gamma"></td></tr><tr><td>\Delta</td><td><img src="https://math.jianshu.com/math?formula=%5CDelta" alt="\Delta"></td><td>\delta</td><td><img src="https://math.jianshu.com/math?formula=%5Cdelta" alt="\delta"></td></tr><tr><td>E</td><td><img src="https://math.jianshu.com/math?formula=E" alt="E"></td><td>\epsilon</td><td><img src="https://math.jianshu.com/math?formula=%5Cepsilon" alt="\epsilon"></td></tr><tr><td>Z</td><td><img src="https://math.jianshu.com/math?formula=Z" alt="Z"></td><td>\zeta</td><td><img src="https://math.jianshu.com/math?formula=%5Czeta" alt="\zeta"></td></tr><tr><td>H</td><td><img src="https://math.jianshu.com/math?formula=H" alt="H"></td><td>\eta</td><td><img src="https://math.jianshu.com/math?formula=%5Ceta" alt="\eta"></td></tr><tr><td>\Theta</td><td><img src="https://math.jianshu.com/math?formula=%5CTheta" alt="\Theta"></td><td>\theta</td><td><img src="https://math.jianshu.com/math?formula=%5Ctheta" alt="\theta"></td></tr><tr><td>I</td><td><img src="https://math.jianshu.com/math?formula=I" alt="I"></td><td>\iota</td><td><img src="https://math.jianshu.com/math?formula=%5Ciota" alt="\iota"></td></tr><tr><td>K</td><td><img src="https://math.jianshu.com/math?formula=K" alt="K"></td><td>\kappa</td><td><img src="https://math.jianshu.com/math?formula=%5Ckappa" alt="\kappa"></td></tr><tr><td>Lambda</td><td><img src="https://math.jianshu.com/math?formula=%5CLambda" alt="\Lambda"></td><td>\lambda</td><td><img src="https://math.jianshu.com/math?formula=%5Clambda" alt="\lambda"></td></tr><tr><td>M</td><td><img src="https://math.jianshu.com/math?formula=M" alt="M"></td><td>\mu</td><td><img src="https://math.jianshu.com/math?formula=%5Cmu" alt="\mu"></td></tr><tr><td>N</td><td><img src="https://math.jianshu.com/math?formula=N" alt="N"></td><td>\nu</td><td><img src="https://math.jianshu.com/math?formula=%5Cnu" alt="\nu"></td></tr><tr><td>Xi</td><td><img src="https://math.jianshu.com/math?formula=Xi" alt="Xi"></td><td>\xi</td><td><img src="https://math.jianshu.com/math?formula=%5Cxi" alt="\xi"></td></tr><tr><td>O</td><td><img src="https://math.jianshu.com/math?formula=O" alt="O"></td><td>\omicron</td><td><img src="https://math.jianshu.com/math?formula=%5Comicron" alt="\omicron"></td></tr><tr><td>\Pi</td><td><img src="https://math.jianshu.com/math?formula=%5CPi" alt="\Pi"></td><td>\pi</td><td><img src="https://math.jianshu.com/math?formula=%5Cpi" alt="\pi"></td></tr><tr><td>P</td><td><img src="https://math.jianshu.com/math?formula=P" alt="P"></td><td>\rho</td><td><img src="https://math.jianshu.com/math?formula=%5Crho" alt="\rho"></td></tr><tr><td>\Sigma</td><td><img src="https://math.jianshu.com/math?formula=%5CSigma" alt="\Sigma"></td><td>\sigma</td><td><img src="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma"></td></tr><tr><td>T</td><td><img src="https://math.jianshu.com/math?formula=T" alt="T"></td><td>\tau</td><td><img src="https://math.jianshu.com/math?formula=%5Ctau" alt="\tau"></td></tr><tr><td>\Upsilon</td><td><img src="https://math.jianshu.com/math?formula=%5CUpsilon" alt="\Upsilon"></td><td>\upsilon</td><td><img src="https://math.jianshu.com/math?formula=%5Cupsilon" alt="\upsilon"></td></tr><tr><td>\Phi</td><td><img src="https://math.jianshu.com/math?formula=%5CPhi" alt="\Phi"></td><td>\phi</td><td><img src="https://math.jianshu.com/math?formula=%5Cphi" alt="\phi"></td></tr><tr><td>X</td><td><img src="https://math.jianshu.com/math?formula=X" alt="X"></td><td>\chi</td><td><img src="https://math.jianshu.com/math?formula=%5Cchi" alt="\chi"></td></tr><tr><td>\Psi</td><td><img src="https://math.jianshu.com/math?formula=%5CPsi" alt="\Psi"></td><td>\psi</td><td><img src="https://math.jianshu.com/math?formula=%5Cpsi" alt="\psi"></td></tr><tr><td>\Omega</td><td><img src="https://math.jianshu.com/math?formula=%5COmega" alt="\Omega"></td><td>\omega</td><td><img src="https://math.jianshu.com/math?formula=%5Comega" alt="\omega"></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FLaTeX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LaTeX&lt;/a&gt;是一种基于&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FTeX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TeX&lt;/a&gt;的文档排版系统,把大片排版的格式细节隐藏在若干样式之后，以内容的逻辑结构统帅纷繁的格式，遂成为现在最流行的科技写作——尤其是数学写作的工具之一.&lt;br&gt; 在Markdown中插入数学公式的语法是 &lt;code&gt;$数学公式$&lt;/code&gt; 和 &lt;code&gt;$$数学公式$$&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;行内公式&quot;&gt;&lt;a href=&quot;#行内公式&quot; class=&quot;headerlink&quot; title=&quot;行内公式&quot;&gt;&lt;/a&gt;行内公式&lt;/h2&gt;&lt;p&gt;行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$2x+3y=34$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://math.jianshu.com/math?formula=2x%2B3y%3D34&quot; alt=&quot;2x+3y=34&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2x+3y=34&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2x+3y=34&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量&lt;img src=&quot;https://math.jianshu.com/math?formula=x&quot; alt=&quot;x&quot;&gt;,也要进入数学模式,使用&lt;code&gt;$1+1=2$&lt;/code&gt;,&lt;code&gt;$x$&lt;/code&gt;,而不是使用排版普通文字的方式&lt;/p&gt;
&lt;h2 id=&quot;独立公式&quot;&gt;&lt;a href=&quot;#独立公式&quot; class=&quot;headerlink&quot; title=&quot;独立公式&quot;&gt;&lt;/a&gt;独立公式&lt;/h2&gt;&lt;p&gt;独立公式单独占一行,不和其他文字混编&lt;br&gt; 示例: &lt;script type=&quot;math/tex&quot;&gt;c=2πr&lt;/script&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="latex" scheme="http://dynais.xyz/categories/note/latex/"/>
    
    
      <category term="latex" scheme="http://dynais.xyz/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记12-模板匹配</title>
    <link href="http://dynais.xyz/2020/02/20/NT-OC-A12_%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
    <id>http://dynais.xyz/2020/02/20/NT-OC-A12_%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/</id>
    <published>2020-02-19T16:00:00.000Z</published>
    <updated>2020-07-23T10:09:50.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matchTemplate();<span class="comment">//模式查找,API比较简单</span></span><br><span class="line">minMaxLoc();<span class="comment">//用于在模式查找的输出图像中找到极值点,也就是匹配点</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>模板匹配(Templet Match)</p><p>相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.</p></li></ul><ul><li><p>注意输出图像的大小</p><p>在API中需要提供一个储存输出结果的Mat, 他的大小是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size(src.cols-templ.cols+1, src.rows-templ.rows+1)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>OpenCV的查找模式</p><p>OpenCV提供了很多种方法,在官网上都有介绍,大部分都是取用了最大值作为最匹配</p><p>根据最小值匹配的只有 <strong>TM_SQDIFF</strong> 和 <strong>MT_SQDIFF_NORMED</strong></p><p><em>For the first two methods ( TM_SQDIFF and MT_SQDIFF_NORMED ) the best match are the lowest values.</em></p></li></ul><ul><li><p>OpenCV中32位的图像</p><p>每个数值是一个位于[0,1]间的小数,相当于8位的[0,255]</p></li></ul><hr><h3 id="源-API实现模式查找"><a href="#源-API实现模式查找" class="headerlink" title="源//API实现模式查找"></a>源//API实现模式查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat src, dst, temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">temp = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Lena.jpg"</span>);</span><br><span class="line">src = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Day1.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试尺度不变性</span></span><br><span class="line"><span class="comment">//pyrDown(temp, temp, Size(temp.cols / 2, temp.rows / 2));</span></span><br><span class="line">pyrUp(temp, temp, Size(temp.cols * <span class="number">2</span>, temp.rows * <span class="number">2</span>));</span><br><span class="line"><span class="comment">//pyrUp(temp, temp, Size(temp.cols * 2, temp.rows * 2));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp.empty() || src.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG... Check again!"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat result = Mat_&lt;<span class="keyword">float</span>&gt;::zeros(src.cols - temp.cols + <span class="number">1</span>, src.rows - temp.rows + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">matchTemplate(src, temp, result, TM_CCOEFF_NORMED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; result;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> minVal; <span class="keyword">double</span> maxVal; Point minLoc; Point maxLoc;</span><br><span class="line">Point matchLoc;</span><br><span class="line">minMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, Mat());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minVal &lt;&lt; <span class="built_in">endl</span> &lt;&lt; maxVal &lt;&lt; <span class="built_in">endl</span> &lt;&lt; minLoc &lt;&lt; <span class="built_in">endl</span> &lt;&lt; maxLoc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">rectangle(src, maxLoc, Point(maxLoc.x + temp.cols, maxLoc.y + temp.rows), Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">rectangle(result, Point(maxLoc.x - temp.cols/<span class="number">2</span>, maxLoc.y - temp.rows/<span class="number">2</span>), Point(maxLoc.x + temp.cols/<span class="number">2</span>, maxLoc.y + temp.rows/<span class="number">2</span>), Scalar::all(<span class="number">1</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">namedWindow(<span class="string">"src"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">pyrDown(src, src, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(src, src, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line">namedWindow(<span class="string">"result"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">pyrDown(result, result, Size(result.cols / <span class="number">2</span>, result.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(result, result, Size(result.cols / <span class="number">2</span>, result.rows / <span class="number">2</span>));</span><br><span class="line">imshow(<span class="string">"result"</span>, result);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;matchTemplate();&lt;span class=&quot;comment&quot;&gt;//模式查找,API比较简单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minMaxLoc();&lt;span class=&quot;comment&quot;&gt;//用于在模式查找的输出图像中找到极值点,也就是匹配点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模板匹配(Templet Match)&lt;/p&gt;
&lt;p&gt;相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意输出图像的大小&lt;/p&gt;
&lt;p&gt;在API中需要提供一个储存输出结果的Mat, 他的大小是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Size(src.cols-templ.cols+1, src.rows-templ.rows+1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记11-直方图均衡化-直方图比较-反向投影</title>
    <link href="http://dynais.xyz/2020/02/19/NT-OC-A11_%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96_%E6%AF%94%E8%BE%83_%E5%8F%8D%E5%90%91%E6%8A%95%E5%BD%B1/"/>
    <id>http://dynais.xyz/2020/02/19/NT-OC-A11_%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96_%E6%AF%94%E8%BE%83_%E5%8F%8D%E5%90%91%E6%8A%95%E5%BD%B1/</id>
    <published>2020-02-18T16:00:00.000Z</published>
    <updated>2020-07-23T10:09:00.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- equalizeHist();<span class="comment">//直方图均衡化</span></span><br><span class="line">- split();<span class="comment">//分离通道</span></span><br><span class="line">- calcHist();<span class="comment">//参数dims,bin,range</span></span><br><span class="line">- waitkey();</span><br><span class="line"></span><br><span class="line">- mixChannels<span class="comment">//分离通道, 与split小有差别,建议看官方文档</span></span><br><span class="line">- cvtColer<span class="comment">//使用此api转换到hsv色彩空间</span></span><br><span class="line">- calcHist<span class="comment">//接受单通道图像计算直方图, 参数略微复杂</span></span><br><span class="line">- normalize<span class="comment">//归一化,常用</span></span><br><span class="line">- compareHist<span class="comment">//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感</span></span><br><span class="line">- backProject();<span class="comment">//直方图反向投影</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><em>这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档</em></p><a id="more"></a><ul><li><strong>直方图均衡化</strong></li></ul><p>好像在人脸识别的项目总结里写过了, API并不难理解</p><ul><li><strong>HSV模型</strong></li></ul><p>HSV是一种比较直观的颜色模型，所以在许多图像编辑工具中应用比较广泛，这个模型中颜色的参数分别是：色调（H, Hue），饱和度（S,Saturation），明度（V, Value）</p><ul><li><strong>直方图比较</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareHist();</span><br></pre></td></tr></table></figure><p>API比较方便,输入两个直方图,比较他们的相似程度</p><p><strong>这两个直方图通常会是图像的HS直方图</strong>(虽然我现在还不太懂HS为什么可以变成一张直方图,到时候要用再看原理好了),用HS猜测是要降低算法对光线的敏感度?(实测好像对光线还是很敏感)</p><p>OpenCV提供了一共四种方法</p><ul><li>相关性计算:{-1, 1}  //1最强</li><li>卡方计算:{0, ∞}  //0最强</li><li>十字交叉</li><li>巴氏距离计算:{0, 1}  //0最强</li></ul><p>其中比较推荐的是相关性计算和巴氏距离计算(不需要归一化了hhhhhhhhh)</p><p>数学公式不列出了(反正我又不会去看)</p><ul><li><strong>直方图反向投影</strong></li></ul><blockquote id="fn_0"><sup>0</sup>. 论文:《Indexing Via Color Histograms》<a href="#reffn_0" title="Jump back to footnote [0] in the text."> &#8617;</a></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixChannels();</span><br><span class="line">backProject();</span><br></pre></td></tr></table></figure><p>直方图反向投影是一种基于色彩的对象识别技术,通过该方法可以定位图像中已知物体的位置,反应直方图在目标图像中的分布</p><p>主要思路是提取已知图像的Hue(色相)空间,做出直方图,再反向找到这些色相在目标图片中的分布,已知图像中越多的色相,在backProject中就会(看起来)更亮,利用这点加上一些二值化,就可以得到一张目标物体的掩膜,覆盖到目标图片上就可以得到完成的图像了,如下</p><hr><h3 id="源-读取TIM图标-在桌面截图上找到他"><a href="#源-读取TIM图标-在桌面截图上找到他" class="headerlink" title="源//读取TIM图标, 在桌面截图上找到他"></a>源//读取TIM图标, 在桌面截图上找到他</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Mat hue;</span><br><span class="line">Mat target_hue;</span><br><span class="line"><span class="keyword">int</span> bins = <span class="number">25</span>;</span><br><span class="line">Mat src_mask_globle;</span><br><span class="line">Mat target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读入src</span></span><br><span class="line">    <span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">"&#123;@input |D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Tim.png  | input image&#125;"</span>)</span></span>;</span><br><span class="line">    Mat src = imread(parser.<span class="built_in">get</span>&lt;<span class="keyword">String</span>&gt;(<span class="string">"@input"</span>));</span><br><span class="line">    <span class="keyword">if</span> (src.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open or find the image!\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" &lt;Input image&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    target = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/屏幕.png"</span>);</span><br><span class="line">    pyrDown(target, target, Size(target.cols / <span class="number">2</span>, target.rows / <span class="number">2</span>));</span><br><span class="line">    pyrDown(target, target, Size(target.cols / <span class="number">2</span>, target.rows / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//pyrDown(src, src, Size(src.cols / 2, src.rows / 2));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二值化取覆膜</span></span><br><span class="line">    Mat src_gray;</span><br><span class="line">    cvtColor(src, src_gray, COLOR_BGR2GRAY);</span><br><span class="line">    Mat src_mask;</span><br><span class="line">    threshold(src_gray, src_mask, <span class="number">0</span>, <span class="number">255</span>, THRESH_TRIANGLE);</span><br><span class="line">    src_mask_globle = src_mask;</span><br><span class="line">    imshow(<span class="string">"BinMask"</span>, src_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//色彩空间转换</span></span><br><span class="line">    <span class="comment">//src = Mat(src.size(), src.type(), Scalar(255, 0, 0));</span></span><br><span class="line">    Mat hsv;</span><br><span class="line">    cvtColor(src, hsv, COLOR_BGR2HSV);</span><br><span class="line">    Mat target_hsv;</span><br><span class="line">    cvtColor(target, target_hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Hue空间通道图像</span></span><br><span class="line">    hue.create(hsv.<span class="built_in">size</span>(), hsv.depth());</span><br><span class="line">    target_hue.create(target_hsv.<span class="built_in">size</span>(), target_hsv.depth());</span><br><span class="line">    <span class="keyword">int</span> ch[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    mixChannels(&amp;hsv, <span class="number">1</span>, &amp;hue, <span class="number">1</span>, ch, <span class="number">1</span>);</span><br><span class="line">    mixChannels(&amp;target_hsv, <span class="number">1</span>, &amp;target_hue, <span class="number">1</span>, ch, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; hue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建滑块并BackProjection</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* window_image = <span class="string">"Source image"</span>;</span><br><span class="line">    namedWindow(window_image);</span><br><span class="line">    createTrackbar(<span class="string">"* Hue  bins: "</span>, window_image, &amp;bins, <span class="number">180</span>, Hist_and_Backproj);</span><br><span class="line">    Hist_and_Backproj(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    imshow(window_image, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until user exits the program</span></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//防止bins太小</span></span><br><span class="line">    <span class="keyword">int</span> histSize = MAX(bins, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算Hue空间直方图</span></span><br><span class="line">    <span class="keyword">float</span> hue_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>* ranges = &#123; hue_range &#125;;</span><br><span class="line">    Mat hist;</span><br><span class="line">    calcHist(&amp;hue, <span class="number">1</span>, <span class="number">0</span>, src_mask_globle, hist, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX, <span class="number">-1</span>, Mat());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BackProjection</span></span><br><span class="line">    Mat backproj;</span><br><span class="line">    calcBackProject(&amp;target_hue, <span class="number">1</span>, <span class="number">0</span>, hist, backproj, &amp;ranges, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    threshold(backproj, backproj, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    imshow(<span class="string">"BackProj"</span>, backproj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制直方图</span></span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">400</span>, h = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">int</span> bin_w = cvRound((<span class="keyword">double</span>)w / histSize);</span><br><span class="line">    Mat histImg = Mat::zeros(h, w, CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rectangle(histImg, Point(i * bin_w, h), Point((i + <span class="number">1</span>) * bin_w, h - cvRound(hist.at&lt;<span class="keyword">float</span>&gt;(i) * h / <span class="number">255.0</span>)),</span><br><span class="line">            Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Histogram"</span>, histImg);</span><br><span class="line"></span><br><span class="line">    Mat focus;</span><br><span class="line">    target.copyTo(focus, backproj);</span><br><span class="line">    imshow(<span class="string">"focus"</span>, focus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- equalizeHist();&lt;span class=&quot;comment&quot;&gt;//直方图均衡化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- split();&lt;span class=&quot;comment&quot;&gt;//分离通道&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- calcHist();&lt;span class=&quot;comment&quot;&gt;//参数dims,bin,range&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- waitkey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- mixChannels&lt;span class=&quot;comment&quot;&gt;//分离通道, 与split小有差别,建议看官方文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- cvtColer&lt;span class=&quot;comment&quot;&gt;//使用此api转换到hsv色彩空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- calcHist&lt;span class=&quot;comment&quot;&gt;//接受单通道图像计算直方图, 参数略微复杂&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- normalize&lt;span class=&quot;comment&quot;&gt;//归一化,常用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- compareHist&lt;span class=&quot;comment&quot;&gt;//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- backProject();&lt;span class=&quot;comment&quot;&gt;//直方图反向投影&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记10-霍夫线和圆检测</title>
    <link href="http://dynais.xyz/2020/02/16/NT-OC-A10_%E9%9C%8D%E5%A4%AB%E7%BA%BF%E5%92%8C%E5%9C%86%E6%A3%80%E6%B5%8B/"/>
    <id>http://dynais.xyz/2020/02/16/NT-OC-A10_%E9%9C%8D%E5%A4%AB%E7%BA%BF%E5%92%8C%E5%9C%86%E6%A3%80%E6%B5%8B/</id>
    <published>2020-02-16T14:00:00.000Z</published>
    <updated>2020-07-23T10:12:41.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*霍夫线检测 输入图像要先Canny过 参数为</span></span><br><span class="line"><span class="comment">- 输入图像</span></span><br><span class="line"><span class="comment">- 输出向量数组,数据类型为Vec4i(就是两个点)</span></span><br><span class="line"><span class="comment">- 默认1</span></span><br><span class="line"><span class="comment">- 默认CV_PI / 180, 转角步长</span></span><br><span class="line"><span class="comment">- 阈值(我设了100)</span></span><br><span class="line"><span class="comment">- 最小线长</span></span><br><span class="line"><span class="comment">- 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HoughLinesP</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArray lines,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> rho, <span class="keyword">double</span> theta, <span class="keyword">int</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> minLineLength = <span class="number">0</span>, <span class="keyword">double</span> maxLineGap = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*霍夫圆检测 参数从前往后分别是</span></span><br><span class="line"><span class="comment">- 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测)</span></span><br><span class="line"><span class="comment">- 输出向量数组,数据类型位Vec3f</span></span><br><span class="line"><span class="comment">- HOUGH_GRADIENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 图像缩放,默认1</span></span><br><span class="line"><span class="comment">- 圆心最小距离, 小于会认为是同心圆?</span></span><br><span class="line"><span class="comment">- Canny检测的大阈值,小的=大的除二计算</span></span><br><span class="line"><span class="comment">- 点重叠n个以上判定为圆,越小检出越多圆</span></span><br><span class="line"><span class="comment">- 最小圆半径</span></span><br><span class="line"><span class="comment">- 最大圆半径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HoughCircles</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArray circles,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> method, <span class="keyword">double</span> dp, <span class="keyword">double</span> minDist,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> param1 = <span class="number">100</span>, <span class="keyword">double</span> param2 = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> minRadius = <span class="number">0</span>, <span class="keyword">int</span> maxRadius = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>圆检测对噪声敏感, 需要先中值滤波</li><li>太难了,建议看下面的博客,线检测还好,圆检测真的看不懂</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><h3 id="源-检出NXP赛道上的几何图"><a href="#源-检出NXP赛道上的几何图" class="headerlink" title="源//检出NXP赛道上的几何图"></a>源//检出NXP赛道上的几何图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/直道进圆环.jpg"</span>, IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; imgIn;</span></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="keyword">double</span> tCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> tSum = <span class="number">0</span>;</span><br><span class="line">tCount = getTickCount();</span><br><span class="line"></span><br><span class="line">cvtColor(imgIn, imgIn, COLOR_BGR2GRAY);</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line"><span class="comment">//GaussianBlur(imgOut, imgOut, Size(3, 3), 1.4);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//霍夫圆检测</span></span><br><span class="line">imgOut = Mat::zeros(imgIn.<span class="built_in">size</span>(), imgIn.type());</span><br><span class="line"><span class="built_in">vector</span>&lt;Vec3f&gt; circles;</span><br><span class="line">HoughCircles(imgIn, circles, HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">50</span>, <span class="number">125</span>, <span class="number">30</span>);<span class="comment">//参数很难试</span></span><br><span class="line">Vec3f aCircle;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; circles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">aCircle = circles[i];</span><br><span class="line"><span class="built_in">circle</span>(imgOut, Point(aCircle[<span class="number">0</span>],aCircle[<span class="number">1</span>]), aCircle[<span class="number">2</span>], Scalar(<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//霍夫直线检测</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Vec4i&gt; lines;</span><br><span class="line">Canny(imgIn, imgIn, <span class="number">50</span>, <span class="number">125</span>, <span class="number">3</span>);</span><br><span class="line">HoughLinesP(imgIn, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">60</span>, <span class="number">0.0</span>, <span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">Vec4i aLine;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">aLine = lines[i];</span><br><span class="line"><span class="built_in">line</span>(imgOut, Point(aLine[<span class="number">0</span>], aLine[<span class="number">1</span>]), Point(aLine[<span class="number">2</span>], aLine[<span class="number">3</span>]) ,Scalar(<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tSum = (getTickCount() - tCount) / getTickFrequency();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time consume %.4f\n\n"</span>, tSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*霍夫线检测 输入图像要先Canny过 参数为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输入图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输出向量数组,数据类型为Vec4i(就是两个点)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 默认1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 默认CV_PI / 180, 转角步长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 阈值(我设了100)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最小线长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HoughLinesP&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, OutputArray lines,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; rho, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; theta, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minLineLength = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; maxLineGap = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*霍夫圆检测 参数从前往后分别是&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输出向量数组,数据类型位Vec3f&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- HOUGH_GRADIENT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 图像缩放,默认1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 圆心最小距离, 小于会认为是同心圆?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- Canny检测的大阈值,小的=大的除二计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 点重叠n个以上判定为圆,越小检出越多圆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最小圆半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最大圆半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HoughCircles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, OutputArray circles,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; method, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dp, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minDist,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; param1 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; param2 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minRadius = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxRadius = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记09-Canny边缘检测算法</title>
    <link href="http://dynais.xyz/2020/02/16/NT-OC-A09_Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://dynais.xyz/2020/02/16/NT-OC-A09_Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-16T12:00:00.000Z</published>
    <updated>2020-07-23T10:06:50.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Canny();<span class="comment">//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p><strong>Canny边缘检测算法可以分为以下5个步骤：</strong></p><ul><li><p>使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)</p></li><li><p>计算图像中每个像素点的梯度强度和方向。</p></li><li><p>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</p></li><li><p>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</p></li><li><p>通过抑制孤立的弱边缘最终完成边缘检测。</p></li></ul></li></ul><ul><li><strong>非极大值抑制:</strong></li></ul><p>细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.</p><a id="more"></a><ul><li><strong>关于几种边缘检测方法:</strong></li></ul><p>Laplance, Canny 和 Sobel 都是边缘检测的方法, Canny是包含了Sobel算子的边缘检测, 所以可以说是Sobel的实际应用, Laplance的检测效果并不好, 但是有其他的用途, 总的来说Canny能应对大多数的场景</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><p>《A Computational Approach to Edge Detection》</p></li><li><p>[1]: <a href="https://www.cnblogs.com/techyan1990/p/7291771.html" target="_blank" rel="noopener">https://www.cnblogs.com/techyan1990/p/7291771.html</a>    “边缘检测之Canny”</p></li></ul><h3 id="源-对NXP赛道进行下采样和边缘检测"><a href="#源-对NXP赛道进行下采样和边缘检测" class="headerlink" title="源//对NXP赛道进行下采样和边缘检测"></a>源//对NXP赛道进行下采样和边缘检测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/直道进圆环.jpg"</span>, IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; imgIn;</span></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="keyword">double</span> tCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> tSum = <span class="number">0</span>;</span><br><span class="line">tCount = getTickCount();</span><br><span class="line"></span><br><span class="line">cvtColor(imgIn, imgOut, COLOR_BGR2GRAY);<span class="comment">//Canny只接受8位深度的灰度图</span></span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));<span class="comment">//下采样</span></span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));</span><br><span class="line"><span class="comment">//GaussianBlur(imgOut, imgOut, Size(3, 3), 1.4);</span></span><br><span class="line"></span><br><span class="line">Canny(imgOut, imgOut, <span class="number">50</span>, <span class="number">125</span>, <span class="number">3</span>);<span class="comment">//第三,四个参数代表上下阈值, 第五个是Sobel算子的大小, 一般取3</span></span><br><span class="line"></span><br><span class="line">tSum = (getTickCount() - tCount) / getTickFrequency();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time consume %.4f\n\n"</span>, tSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Canny();	&lt;span class=&quot;comment&quot;&gt;//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Canny边缘检测算法可以分为以下5个步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算图像中每个像素点的梯度强度和方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过抑制孤立的弱边缘最终完成边缘检测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非极大值抑制:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记08-Sobel算子</title>
    <link href="http://dynais.xyz/2020/02/15/NT-OC-A08_Sobel%E7%AE%97%E5%AD%90/"/>
    <id>http://dynais.xyz/2020/02/15/NT-OC-A08_Sobel%E7%AE%97%E5%AD%90/</id>
    <published>2020-02-15T12:48:00.000Z</published>
    <updated>2020-07-23T10:05:06.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sobel();<span class="comment">//索贝尔算子</span></span><br><span class="line">Scharr();<span class="comment">//Sobel的加强</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p><strong>Sobel:</strong> <a href="https://www.jianshu.com/p/2a06c68f6c14" target="_blank" rel="noopener">边缘检测算法及各自的优缺点</a></p><p>Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺</p></li></ul><ul><li><p><strong>使用加减来简化计算机的负担:</strong> <a href="https://blog.csdn.net/qq_37124237/article/details/82183177" target="_blank" rel="noopener">sobel算子的原理与实现</a></p><p>乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想</p></li></ul><ul><li><p><strong>整个流程:</strong></p><p> 高斯-&gt;转灰度-&gt;求梯度x与y-&gt;混合</p> <a id="more"></a></li></ul><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关API&quot;&gt;&lt;a href=&quot;#相关API&quot; class=&quot;headerlink&quot; title=&quot;相关API&quot;&gt;&lt;/a&gt;相关API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Sobel();&lt;span class=&quot;comment&quot;&gt;//索贝尔算子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Scharr();&lt;span class=&quot;comment&quot;&gt;//Sobel的加强&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sobel:&lt;/strong&gt; &lt;a href=&quot;https://www.jianshu.com/p/2a06c68f6c14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;边缘检测算法及各自的优缺点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用加减来简化计算机的负担:&lt;/strong&gt; &lt;a href=&quot;https://blog.csdn.net/qq_37124237/article/details/82183177&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sobel算子的原理与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;整个流程:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 高斯-&amp;gt;转灰度-&amp;gt;求梯度x与y-&amp;gt;混合&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记07-上下采样-高斯不同(DOG)</title>
    <link href="http://dynais.xyz/2020/02/15/NT-OC-A07_%E4%B8%8A%E4%B8%8B%E9%87%87%E6%A0%B7_%E9%AB%98%E6%96%AF%E4%B8%8D%E5%90%8C(DOG)/"/>
    <id>http://dynais.xyz/2020/02/15/NT-OC-A07_%E4%B8%8A%E4%B8%8B%E9%87%87%E6%A0%B7_%E9%AB%98%E6%96%AF%E4%B8%8D%E5%90%8C(DOG)/</id>
    <published>2020-02-15T12:39:00.000Z</published>
    <updated>2020-07-23T10:05:24.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- pyrUp();<span class="comment">//上采样</span></span><br><span class="line">- pyrDown();<span class="comment">//下采样</span></span><br><span class="line">- subtract();<span class="comment">//图像减法</span></span><br><span class="line"></span><br><span class="line">- threshold()<span class="comment">//二值化</span></span><br><span class="line">- binarythreshold()<span class="comment">//还是二值化</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><strong>高斯金字塔:</strong><br>涉及到上采样和下采样的概念<br>实现步骤是:   1.高斯模糊    2.删除当前层偶数行列</li></ul><ul><li><strong>高斯不同(DOG):</strong><br>同图像在不同参数下做高斯模糊然后结果相减, 最后记得归一化, 不然图很淡</li></ul><a id="more"></a><ul><li><p><strong>上/下采样对比几个像素求平均合成的优势:</strong></p><p>最大的好处就是变快了, 在人脸识别那个项目里我自己写了压缩算法,但是速度和这个相差了一倍(在720p下)</p><p>但是也发现这个算法有局限, 首先图像会便模糊, 其次只能实现2的次方倍的缩放(至少根据OpenCV里的API来看)</p></li></ul><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- pyrUp();&lt;span class=&quot;comment&quot;&gt;//上采样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- pyrDown();&lt;span class=&quot;comment&quot;&gt;//下采样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- subtract();&lt;span class=&quot;comment&quot;&gt;//图像减法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- threshold()&lt;span class=&quot;comment&quot;&gt;//二值化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- binarythreshold()&lt;span class=&quot;comment&quot;&gt;//还是二值化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯金字塔:&lt;/strong&gt;&lt;br&gt;涉及到上采样和下采样的概念&lt;br&gt;实现步骤是:   1.高斯模糊    2.删除当前层偶数行列&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯不同(DOG):&lt;/strong&gt;&lt;br&gt;同图像在不同参数下做高斯模糊然后结果相减, 最后记得归一化, 不然图很淡&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中人脸识别的Haar实现</title>
    <link href="http://dynais.xyz/2020/02/06/PJ-HF01-OC-%E4%BD%BF%E7%94%A8OpenCV%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    <id>http://dynais.xyz/2020/02/06/PJ-HF01-OC-%E4%BD%BF%E7%94%A8OpenCV%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</id>
    <published>2020-02-05T16:00:00.000Z</published>
    <updated>2020-07-23T09:41:50.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目总结-人脸识别的Haar实现"><a href="#项目总结-人脸识别的Haar实现" class="headerlink" title="项目总结_人脸识别的Haar实现"></a>项目总结_人脸识别的Haar实现</h2><h5 id="项目历时-2020-2-3-2020-2-5"><a href="#项目历时-2020-2-3-2020-2-5" class="headerlink" title="项目历时:    2020.2.3 - 2020.2.5"></a>项目历时:    2020.2.3 - 2020.2.5</h5><h5 id="负责人-Dynais"><a href="#负责人-Dynais" class="headerlink" title="负责人:    Dynais"></a>负责人:    Dynais</h5><h5 id="项目花费-无"><a href="#项目花费-无" class="headerlink" title="项目花费:    无"></a>项目花费:    无</h5><h5 id="报告撰写时间-2020-2-6"><a href="#报告撰写时间-2020-2-6" class="headerlink" title="报告撰写时间: 2020.2.6"></a>报告撰写时间: 2020.2.6</h5><hr><h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><p>本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><p><strong>第一部分</strong>    部分原理粗解</p><ul><li>1.1    图像压缩</li><li>1.2    直方图均衡化</li><li>1.3    Haar特征检测</li></ul><a id="more"></a></li></ul><ul><li><strong>第二部分</strong>    软件结构设计与实现</li></ul><ul><li><p><strong>第三部分</strong>    难点与优化方法</p><ul><li>3.1    难点一:    面部检测速度过慢</li></ul></li></ul><ul><li><p><strong>第四部分</strong>    总结</p><ul><li>4.1    不足之处</li><li>4.2    总结</li></ul></li></ul><ul><li><strong>第五部分</strong>    参考文献</li></ul><hr><h2 id="第一部分-部分原理粗解"><a href="#第一部分-部分原理粗解" class="headerlink" title="第一部分 部分原理粗解"></a>第一部分 部分原理粗解</h2><h3 id="1-1-图像压缩"><a href="#1-1-图像压缩" class="headerlink" title="1.1 图像压缩"></a>1.1 图像压缩</h3><p>对原图多个像素求和后取平均值, 得到一个新的像素值, 作为目标图像的像素值, 这样得到的新图像就是经过了压缩的原图像, 原理过于简单就不详细展开</p><h3 id="1-2-直方图均衡化"><a href="#1-2-直方图均衡化" class="headerlink" title="1.2 直方图均衡化"></a>1.2 直方图均衡化</h3><h5 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h5><p>建立一个桶, 将一幅图像的某一个通道的像素值进行桶排序并可视化, 呈现出来的图像称为直方图</p><p>一幅灰度图像的直方图通常如下:</p><p>[图没了]</p><p>直方图可以直观的反应图像上的像素值分布情况, 如:</p><p><img src="https://img-blog.csdnimg.cn/20181123160536532.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjaHdlaW5fdmFu,size_16,color_FFFFFF,t_70" alt="图1 4种基本的图像类型：暗图像、亮图像、低对比度图像、高对比度图像及其对应的直方图"></p><p><strong>直方图均衡化</strong></p><p>直方图均衡化是将原图像通过某种变换，得到一幅灰度直方图为均匀分布的新图像的方法.</p><p>直方图均衡化方法的基本思想是对在图像中像素个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减. 从而达到清晰图像的目的.</p><p><strong>将原图的像素值进行重新映射, 使直方图分布更加均匀, 达到了加强图像对比度的目的.</strong></p><p>具体解析见:</p><p><a href="https://blog.csdn.net/schwein_van/article/details/84336633" target="_blank" rel="noopener">直方图均衡化</a></p><h3 id="1-3-Haar特征检测"><a href="#1-3-Haar特征检测" class="headerlink" title="1.3 Haar特征检测"></a>1.3 Haar特征检测</h3><p>Haar 特征检测部分, 由于已经有大量的博客详细描述过了, 所以不再浪费时间写</p><p>值得一提的是原作者的论文《Robust Real-Time Face Detection》是人脸检测的经典论文, 虽然读起来很困难(更何况是英文) 但还是值得一读, 如果希望深入了解的话</p><p>更多博客文章: 印象笔记关键字: <strong>Haar</strong></p><hr><h2 id="第二部分-软件结构设计与实现方法"><a href="#第二部分-软件结构设计与实现方法" class="headerlink" title="第二部分 软件结构设计与实现方法"></a>第二部分 软件结构设计与实现方法</h2><p>文件夹”OpenCV_FaceDetectPro”中包含了两个.cpp文件:</p><ul><li>OpenCV_Process.cpp    包括人脸检测函数及其相关调用函数</li><li>OpenCV_main.cpp    程序主入口</li></ul><h3 id="人脸检测流程"><a href="#人脸检测流程" class="headerlink" title="人脸检测流程"></a>人脸检测流程</h3><p>人脸检测(优化后的版本)的步骤分为:</p><ul><li><p>识别标志位, 判断当前状态是检测还是跟踪</p></li><li><p>对摄像头当前采集图像进行分割</p></li><li>灰度化</li><li>压缩</li><li>直方图均衡化</li><li>Haar特征检测</li><li>返回人脸位置</li></ul><h3 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h3><h5 id="状态识别"><a href="#状态识别" class="headerlink" title="状态识别"></a>状态识别</h5><p>由于时间复杂度问题(在下一章会说到), 采用了检测和跟踪分开的思路, 主要的思路是降低输入图像的大小. 采用每次检测完人脸后进行标志的判断为方法, 确定程序运行在那种状态下.</p><p>对于检测和跟踪模式, 使用了不同的思路来进行图像分割</p><h5 id="Haar"><a href="#Haar" class="headerlink" title="Haar"></a>Haar</h5><p>直接使用了现成的数据, 自己并不会训练, 直接调用OpenCV的 CascadeClassifier 类实现</p><hr><h2 id="第三部分-难点与优化方法"><a href="#第三部分-难点与优化方法" class="headerlink" title="第三部分 难点与优化方法"></a>第三部分 难点与优化方法</h2><h3 id="3-1-难点一-面部检测速度过慢"><a href="#3-1-难点一-面部检测速度过慢" class="headerlink" title="3.1 难点一: 面部检测速度过慢"></a>3.1 难点一: 面部检测速度过慢</h3><p>未优化前的程序, 每次读入摄像头图像后直接进行灰度化与直方图均衡化, 然后进行全图的面部检测, 并且没有面部跟踪的实现, 导致每次图像的处理时间非常长, 达到了每帧图像0.8秒.</p><p>针对时间过长的问题, 首先引入了面部识别的标志位, 每次程序识别到面部时, 打开标志位, 然后在接下来的循环里只根据上次判断的面部位置截取小块图像进行判断,大大降低处理时间</p><p>其次, 使用图像压缩, 使待处理图像处于一个大小和准确度都可以接受的点上.</p><p><strong>引入后, 面部检测的时间从0.8秒降低到0.04秒</strong></p><p><strong>部分代码:</strong></p><p><strong>图像压缩</strong>(前置函数为自己写的areaAvarage())</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;****************************************************</span><br><span class="line">*   Function:</span><br><span class="line">*   用于图像压缩函数zipImg, 基于周边像素求出当前像素值</span><br><span class="line">*</span><br><span class="line">*   Note:</span><br><span class="line">*   算法用左上像素求, 不知道会不会失真</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">******************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">uchar areaAvarage(Mat src, Point pos, int channal, int gain) &#123;</span><br><span class="line">    int pixel &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (src.channels() !&#x3D; 1) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i &#x3D; 0; i &lt; gain; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; gain; j++) &#123;</span><br><span class="line">                pixel +&#x3D; src.at&lt;Vec3b&gt;(pos.y - j, pos.x - i)[channal];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pixel &#x2F;&#x3D; (gain * gain);</span><br><span class="line">        return saturate_cast&lt;uchar&gt;(pixel);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i &#x3D; 0; i &lt; gain; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; gain; j++) &#123;</span><br><span class="line">                pixel +&#x3D; src.at&lt;uchar&gt;(pos.y - j, pos.x - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pixel &#x2F;&#x3D; (gain * gain);</span><br><span class="line">        return saturate_cast&lt;uchar&gt;(pixel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;****************************************************</span><br><span class="line">*   Function:</span><br><span class="line">*   图像压缩 gain^2 倍,长宽变为原先 1&#x2F;gain</span><br><span class="line">*</span><br><span class="line">*   Note:</span><br><span class="line">*速度还是不够理想</span><br><span class="line">*   留出了一圈白边</span><br><span class="line">*</span><br><span class="line">******************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">void zipImg(Mat&amp; src, Mat&amp; dst, int gain) &#123;</span><br><span class="line">    dst &#x3D; Mat(src.size() &#x2F; gain, src.type());</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    if (src.channels() !&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历</span><br><span class="line">        for (i &#x3D; 1; i &lt; dst.cols - 1; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt; dst.rows - 1; j++) &#123;</span><br><span class="line">                uchar b, g, r;</span><br><span class="line">                int realpos_x &#x3D; i * gain;</span><br><span class="line">                int realpos_y &#x3D; j * gain;</span><br><span class="line">                Point pos(realpos_x, realpos_y);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;对周边像素求均值,赋值给新图</span><br><span class="line">                b &#x3D; areaAvarage(src, pos, 0, gain);</span><br><span class="line">                g &#x3D; areaAvarage(src, pos, 1, gain);</span><br><span class="line">                r &#x3D; areaAvarage(src, pos, 2, gain);</span><br><span class="line">                dst.at&lt;Vec3b&gt;(j, i) &#x3D; &#123; b,g,r &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for (i &#x3D; 1; i &lt; dst.cols - 1; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt; dst.rows - 1; j++) &#123;</span><br><span class="line">                uchar g;</span><br><span class="line">                int realpos_x &#x3D; i * gain;</span><br><span class="line">                int realpos_y &#x3D; j * gain;</span><br><span class="line">                Point pos(realpos_x, realpos_y);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;对周边像素求均值,赋值给新图</span><br><span class="line">                g &#x3D; areaAvarage(src, pos, 1, gain);</span><br><span class="line">                dst.at&lt;uchar&gt;(j, i) &#x3D; g;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第四部分-总结"><a href="#第四部分-总结" class="headerlink" title="第四部分 总结"></a>第四部分 总结</h2><h3 id="4-1-不足之处"><a href="#4-1-不足之处" class="headerlink" title="4.1    不足之处"></a>4.1    不足之处</h3><ul><li>虽然采用检测与跟踪同样裁剪画面的方法, 但是效果其实并不理想, 速度提升微弱</li><li>面部检测对侧脸准确性几乎没有</li><li>光照优化有待加强</li><li>速度还是不够快</li><li>脸太大或太小检测不了</li></ul><h3 id="4-2-总结"><a href="#4-2-总结" class="headerlink" title="4.2    总结"></a>4.2    总结</h3><p>总的来说这次项目还是挺成功的, 在几天以内就完成了, 虽然借由了大量API, 但原理也还是有所了解的. 接下来的任务是使他能够在树莓派上也能正常运行. </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目总结-人脸识别的Haar实现&quot;&gt;&lt;a href=&quot;#项目总结-人脸识别的Haar实现&quot; class=&quot;headerlink&quot; title=&quot;项目总结_人脸识别的Haar实现&quot;&gt;&lt;/a&gt;项目总结_人脸识别的Haar实现&lt;/h2&gt;&lt;h5 id=&quot;项目历时-2020-2-3-2020-2-5&quot;&gt;&lt;a href=&quot;#项目历时-2020-2-3-2020-2-5&quot; class=&quot;headerlink&quot; title=&quot;项目历时:    2020.2.3 - 2020.2.5&quot;&gt;&lt;/a&gt;项目历时:    2020.2.3 - 2020.2.5&lt;/h5&gt;&lt;h5 id=&quot;负责人-Dynais&quot;&gt;&lt;a href=&quot;#负责人-Dynais&quot; class=&quot;headerlink&quot; title=&quot;负责人:    Dynais&quot;&gt;&lt;/a&gt;负责人:    Dynais&lt;/h5&gt;&lt;h5 id=&quot;项目花费-无&quot;&gt;&lt;a href=&quot;#项目花费-无&quot; class=&quot;headerlink&quot; title=&quot;项目花费:    无&quot;&gt;&lt;/a&gt;项目花费:    无&lt;/h5&gt;&lt;h5 id=&quot;报告撰写时间-2020-2-6&quot;&gt;&lt;a href=&quot;#报告撰写时间-2020-2-6&quot; class=&quot;headerlink&quot; title=&quot;报告撰写时间: 2020.2.6&quot;&gt;&lt;/a&gt;报告撰写时间: 2020.2.6&lt;/h5&gt;&lt;hr&gt;
&lt;h3 id=&quot;项目概述&quot;&gt;&lt;a href=&quot;#项目概述&quot; class=&quot;headerlink&quot; title=&quot;项目概述&quot;&gt;&lt;/a&gt;项目概述&lt;/h3&gt;&lt;p&gt;本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一部分&lt;/strong&gt;    部分原理粗解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.1    图像压缩&lt;/li&gt;
&lt;li&gt;1.2    直方图均衡化&lt;/li&gt;
&lt;li&gt;1.3    Haar特征检测&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="harr-face-detect" scheme="http://dynais.xyz/categories/project/harr-face-detect/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记06-形态学操作</title>
    <link href="http://dynais.xyz/2020/01/30/NT-OC-A06_%E5%BD%A2%E6%80%81%E5%AD%A6%E6%93%8D%E4%BD%9C/"/>
    <id>http://dynais.xyz/2020/01/30/NT-OC-A06_%E5%BD%A2%E6%80%81%E5%AD%A6%E6%93%8D%E4%BD%9C/</id>
    <published>2020-01-29T16:00:00.000Z</published>
    <updated>2020-07-23T10:02:02.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getStructuringElement(<span class="keyword">int</span> shape, Size ksize ,Point anchor);注意<span class="built_in">size</span>还是要奇数</span><br><span class="line">dilate(src, dst, kernel);膨胀</span><br><span class="line">erode(src, dst, kernel);腐蚀</span><br><span class="line">creatTrackbar();创建滑块,比较实用,但我搞不懂</span><br><span class="line"></span><br><span class="line">morphologyEX();形态学操作</span><br><span class="line"></span><br><span class="line">adaptiveThreshold();</span><br><span class="line">threshold(); <span class="comment">//大津法</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>膨胀</li><li>腐蚀</li><li>开操作 </li><li>形态学梯度</li></ul><ul><li>提取垂直或水平的线(使用水平或竖直的结构体)</li><li>二值化</li><li>对图像取反(用~)</li></ul><a id="more"></a><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>opencv结构元素获取(getStructuringElement)我理解是类似卷积核的东西</li><li>膨胀:区域最大值覆盖中心值</li><li>腐蚀:区域最小值覆盖中心值</li></ul><ul><li>开操作:先腐蚀后膨胀,去掉小的对象</li><li>闭操作:先膨胀后腐蚀,填充小的洞</li><li>形态学梯度可以方便得提取边线</li><li>提取垂直或水平的线思路: 使用特殊的结构体来提取特殊的结构,比如一条横线进行开操作就可以提取出横线结构(操作完以后可以blur一下) </li><li>在进行阙值分割前对图像进行模糊处理(图像处理领域好像叫滤波?)再分割貌似有更好的效果</li><li>挑战: 验证码识别</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>无</p><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><p>主要是滑块的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat structs;</span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> size_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"><span class="comment">//VideoCapture cap;</span></span><br><span class="line"><span class="comment">//cap = VideoCapture(0);</span></span><br><span class="line"><span class="comment">//Mat cap0;</span></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; cap0;</span></span><br><span class="line"><span class="comment">//imshow("test", cap0);</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV学习/ImageHub/Code1.png"</span>, IMREAD_GRAYSCALE);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//imgIn = cap0.clone();</span></span><br><span class="line"><span class="comment">//cvtColor(imgIn, imgIn, COLOR_BGR2GRAY);</span></span><br><span class="line"><span class="comment">//imshow("test", imgIn);</span></span><br><span class="line"></span><br><span class="line">medianBlur(imgIn, imgIn, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//threshold(~imgIn, imgIn, 0, 255, THRESH_OTSU);</span></span><br><span class="line">adaptiveThreshold(~imgIn, imgIn, <span class="number">255</span>, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, <span class="number">33</span>, <span class="number">-10</span>);</span><br><span class="line"></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">createTrackbar(<span class="string">"Kern Size"</span>, <span class="string">"output"</span>, &amp;size_, MAXSIZE, Graph);<span class="comment">//这个函数调用的方法非常奇特我搞不懂为什么,前两句是为了初始化窗口↑,注意最后一个参数虽然是函数但是不用括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"><span class="comment">//namedWindow("input", WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow("input", imgIn);</span></span><br><span class="line"><span class="comment">//namedWindow("output2", WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow("output2", imgOut2);</span></span><br><span class="line"><span class="comment">//namedWindow("output3", WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow("output3", imgOut3);</span></span><br><span class="line"><span class="comment">//namedWindow("output4", WINDOW_AUTOSIZE);</span></span><br><span class="line"><span class="comment">//imshow("output4", imgOut4);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//imwrite("D:/Download/Family2020_Final.jpg", imgOut);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "Mat=" &lt;&lt; endl &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span> </span>&#123;<span class="comment">//注意书写格式,虽然我不知道为什么</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s = size_ * <span class="number">2</span> + <span class="number">1</span> ;</span><br><span class="line">structs = getStructuringElement(MORPH_RECT, Size(s, s), Point(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//erode(imgIn, imgOut, structs);</span></span><br><span class="line"><span class="comment">//dilate(imgOut, imgOut, structs);</span></span><br><span class="line"></span><br><span class="line">morphologyEx(imgIn, imgOut, MORPH_GRADIENT, structs);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getStructuringElement(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; shape, Size ksize ,Point anchor);注意&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;还是要奇数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dilate(src, dst, kernel);膨胀&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;erode(src, dst, kernel);腐蚀&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;creatTrackbar();创建滑块,比较实用,但我搞不懂&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;morphologyEX();形态学操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;adaptiveThreshold();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;threshold(); &lt;span class=&quot;comment&quot;&gt;//大津法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;膨胀&lt;/li&gt;
&lt;li&gt;腐蚀&lt;/li&gt;
&lt;li&gt;开操作 &lt;/li&gt;
&lt;li&gt;形态学梯度&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;提取垂直或水平的线(使用水平或竖直的结构体)&lt;/li&gt;
&lt;li&gt;二值化&lt;/li&gt;
&lt;li&gt;对图像取反(用~)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记05-各类模糊</title>
    <link href="http://dynais.xyz/2020/01/29/NT-OC-A05_%E5%90%84%E7%B1%BB%E6%A8%A1%E7%B3%8A/"/>
    <id>http://dynais.xyz/2020/01/29/NT-OC-A05_%E5%90%84%E7%B1%BB%E6%A8%A1%E7%B3%8A/</id>
    <published>2020-01-28T16:00:00.000Z</published>
    <updated>2020-07-23T10:01:08.598Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blur();<span class="comment">//均值模糊</span></span><br><span class="line">GaussianBlur();<span class="comment">//高斯模糊</span></span><br><span class="line">medianBlur();<span class="comment">//中值滤波</span></span><br><span class="line">bilateralFilter()<span class="comment">//双边滤波</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>模糊</p><ul><li>均值滤波</li><li>高斯滤波</li><li>中值滤波</li><li>双边滤波</li></ul></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><strong>高斯滤波是通过高斯函数也就是正态分布来给mask权重</strong></li><li>sigma越大正态分布上表现就是越平滑</li></ul><a id="more"></a><ul><li><strong>中值滤波是统计排序滤波器,对椒盐噪声有很好的抑制作用</strong></li><li><strong>注意区分中值和均值</strong></li></ul><ul><li>高斯模糊没有考虑像素值的差异,会导致边缘还是不那么清晰</li><li><strong>引入空间域核与值域核考虑,空间域就相当于普通的高斯滤波,根据相邻距离决定权重,而值域核是由目标像素值与中心像素值差来给定权重</strong></li><li>简单来说就是双边模糊对高斯模糊来说多了一层mask,这层mask不是根据像素空间位置来给定权重的,而是根据像素与中心像素值之差得出</li><li><strong>双边滤波可以磨皮(</strong></li></ul><ul><li>剩下的看注释</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>无</p><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line">Mat mask;</span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"Test.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="comment">//blur(imgIn, imgOut, Size(9, 9), Point(-1, -1));//均值模糊</span></span><br><span class="line"></span><br><span class="line">Mat imgOut2;</span><br><span class="line"><span class="comment">//double sigma = 3;</span></span><br><span class="line"><span class="comment">//GaussianBlur(imgIn, imgOut2, Size(9,9), sigma, sigma);//高斯模糊</span></span><br><span class="line"></span><br><span class="line">Mat imgOut3;</span><br><span class="line"><span class="comment">//medianBlur(imgIn, imgOut3, 9);//中值滤波</span></span><br><span class="line"></span><br><span class="line">Mat imgOut4;</span><br><span class="line">bilateralFilter(imgIn, imgOut, <span class="number">15</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);</span><br><span class="line">bilateralFilter(imgIn, imgOut2, <span class="number">30</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);<span class="comment">//在sigmaColor很大的情况下,修改sigmaSpace效果很小</span></span><br><span class="line">bilateralFilter(imgIn, imgOut3, <span class="number">50</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);<span class="comment">//sigmaColor越大,色块化越严重</span></span><br><span class="line">bilateralFilter(imgIn, imgOut4, <span class="number">100</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);<span class="comment">//范围d越大,柔化越明显</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">namedWindow(<span class="string">"output2"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output2"</span>, imgOut2);</span><br><span class="line">namedWindow(<span class="string">"output3"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output3"</span>, imgOut3);</span><br><span class="line">namedWindow(<span class="string">"output4"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output4"</span>, imgOut4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//imwrite("D:/Download/Family2020_Final.jpg", imgOut);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "Mat=" &lt;&lt; endl &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line">Mat mask;</span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"Test.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="comment">//blur(imgIn, imgOut, Size(9, 9), Point(-1, -1));//均值模糊</span></span><br><span class="line"></span><br><span class="line">Mat imgOut2;</span><br><span class="line"><span class="comment">//double sigma = 3;</span></span><br><span class="line"><span class="comment">//GaussianBlur(imgIn, imgOut2, Size(9,9), sigma, sigma);//高斯模糊</span></span><br><span class="line"></span><br><span class="line">Mat imgOut3;</span><br><span class="line"><span class="comment">//medianBlur(imgIn, imgOut3, 9);//中值滤波</span></span><br><span class="line"></span><br><span class="line">Mat imgOut4;</span><br><span class="line">bilateralFilter(imgIn, imgOut, <span class="number">15</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);</span><br><span class="line">bilateralFilter(imgIn, imgOut2, <span class="number">30</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);<span class="comment">//在sigmaColor很大的情况下,修改sigmaSpace效果很小</span></span><br><span class="line">bilateralFilter(imgIn, imgOut3, <span class="number">50</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);<span class="comment">//sigmaColor越大,色块化越严重</span></span><br><span class="line">bilateralFilter(imgIn, imgOut4, <span class="number">100</span>, <span class="number">30.0</span>, <span class="number">30.0</span>);<span class="comment">//范围d越大,柔化越明显</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">namedWindow(<span class="string">"output2"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output2"</span>, imgOut2);</span><br><span class="line">namedWindow(<span class="string">"output3"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output3"</span>, imgOut3);</span><br><span class="line">namedWindow(<span class="string">"output4"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output4"</span>, imgOut4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//imwrite("D:/Download/Family2020_Final.jpg", imgOut);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "Mat=" &lt;&lt; endl &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;blur();		&lt;span class=&quot;comment&quot;&gt;//均值模糊&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GaussianBlur();		&lt;span class=&quot;comment&quot;&gt;//高斯模糊&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;medianBlur();		&lt;span class=&quot;comment&quot;&gt;//中值滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bilateralFilter()		&lt;span class=&quot;comment&quot;&gt;//双边滤波&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模糊&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;均值滤波&lt;/li&gt;
&lt;li&gt;高斯滤波&lt;/li&gt;
&lt;li&gt;中值滤波&lt;/li&gt;
&lt;li&gt;双边滤波&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯滤波是通过高斯函数也就是正态分布来给mask权重&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;sigma越大正态分布上表现就是越平滑&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
  </entry>
  
</feed>
