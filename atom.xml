<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DynAis的个人站</title>
  
  <subtitle>DynAis&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dynais.xyz/"/>
  <updated>2020-07-24T17:02:23.556Z</updated>
  <id>http://dynais.xyz/</id>
  
  <author>
    <name>DynAis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欢迎! Willkommen!</title>
    <link href="http://dynais.xyz/posts/872a1608.html"/>
    <id>http://dynais.xyz/posts/872a1608.html</id>
    <published>2029-12-31T16:00:00.000Z</published>
    <updated>2020-07-24T17:02:23.556Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欢迎来到我的个人博客，这是我的第二次尝试，我会尝试持续更新的😉</strong><br><strong>Willkommen zum meinem persönlichen Blog, eigentlich ist das mein zweiter Versuch und ich werde versuchen, der Blog ständig zu aktualisieren😉</strong></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010149.png" alt=""></p><a id="more"></a><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/872a1608.html">http://dynais.xyz/posts/872a1608.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;欢迎来到我的个人博客，这是我的第二次尝试，我会尝试持续更新的😉&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Willkommen zum meinem persönlichen Blog, eigentlich ist das mein zweiter Versuch und ich werde versuchen, der Blog ständig zu aktualisieren😉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010149.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/project/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>PSpice中常用的Cursor查询命令</title>
    <link href="http://dynais.xyz/posts/457ee858.html"/>
    <id>http://dynais.xyz/posts/457ee858.html</id>
    <published>2021-12-16T16:00:00.000Z</published>
    <updated>2020-12-17T08:26:10.868Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p><br/></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了</p><p>Orcad Pspice版本: 9.1 Student</p><a id="more"></a><p>文档进入方法:</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161535.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161535.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>Win10还要上网找一下<strong>win32hlp.exe</strong>装一下才能看, 下载: <a href="http://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/storage/win10%E7%9A%84winhlp32%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%A1%88.zip" target="_blank" rel="noopener"><strong>win32hlp.exe</strong></a></p><p>路径:</p><div class="figure center" style="width:50%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png" style="width:50%;height:50%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><hr><p><code>search    [direction]    [/start_point/]    [#consecutive_points#]    [(range_x [,range_y])]    [for]    [repeat:]    &lt;condition&gt;</code></p><p>能把搜索语法写这么麻烦我真的服</p><p><br/></p><h2 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h2><hr><p>其实语法不需要打全称, 是接收缩写的, 但是文档里一点没说</p><p>常用的是:</p><div class="table-container"><table><thead><tr><th>example</th><th>describtion</th></tr></thead><tbody><tr><td><code>sf xv (这里是数字)</code></td><td>向前找到下一个X坐标最符合当前用户输入数字的点</td></tr><tr><td><code>sf le (这里是数字)</code></td><td>向前找到下一个Y坐标最符合当前用户输入数字的点</td></tr></tbody></table></div><p><code>sf</code> 是 <strong>SerchForword</strong> 的缩写, <code>xv</code> 是 <strong>XValue</strong> 的缩写, <code>ls</code> 是 <strong>LEvel</strong> 的缩写</p><p>更加具体的可以在语法里的 <code>&lt;condition&gt;</code> 下找到</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/457ee858.html">http://dynais.xyz/posts/457ee858.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了&lt;/p&gt;
&lt;p&gt;Orcad Pspice版本: 9.1 Student&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="pspice" scheme="http://dynais.xyz/categories/note/pspice/"/>
    
    
      <category term="pspice" scheme="http://dynais.xyz/tags/pspice/"/>
    
  </entry>
  
  <entry>
    <title>PSpice模拟数据导入Excel工作流</title>
    <link href="http://dynais.xyz/posts/da7f3a9c.html"/>
    <id>http://dynais.xyz/posts/da7f3a9c.html</id>
    <published>2021-12-16T16:00:00.000Z</published>
    <updated>2020-12-17T08:26:35.489Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p><br/></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析</p><a id="more"></a><p><br/></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><hr><p>在 PSpice 得到模拟数据后, 选中需要导出的曲线</p><div class="figure center" style="width:50%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png" style="width:50%;height:50%;"alt=""></a></div><div style="clear:both;"></div><p>看到它变红了</p><p>然后直接 <code>Ctrl + C</code> 就可以获得曲线数据</p><p>然后新建一个文本文档, 复制粘贴保存成 <code>.csv</code> 文件</p><p>直接导入 Excel 应该也是可行的, 但是由于改成了德国的计数方法, 这里的逗号和小数点会有问题, 先导入 csv 文件的话就没问题, 所以还是建议保存到 csv, 这样 Matlab 什么的也能用</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/da7f3a9c.html">http://dynais.xyz/posts/da7f3a9c.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="pspice" scheme="http://dynais.xyz/categories/note/pspice/"/>
    
    
      <category term="pspice" scheme="http://dynais.xyz/tags/pspice/"/>
    
  </entry>
  
  <entry>
    <title>艺术造型中的节奏感/力量感/画面平衡的表现</title>
    <link href="http://dynais.xyz/posts/4b97ec9b.html"/>
    <id>http://dynais.xyz/posts/4b97ec9b.html</id>
    <published>2021-10-12T16:00:00.000Z</published>
    <updated>2020-11-13T15:43:37.540Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><hr><div class="figure center" style="width:50%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233415.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233415.png" style="width:50%;height:50%;"alt=""></a></div><div style="clear:both;"></div><a id="more"></a><p><br/></p><h2 id="营造画面的节奏感"><a href="#营造画面的节奏感" class="headerlink" title="营造画面的节奏感"></a>营造画面的节奏感</h2><hr><h3 id="反面：缺乏节奏的画面"><a href="#反面：缺乏节奏的画面" class="headerlink" title="反面：缺乏节奏的画面"></a>反面：缺乏节奏的画面</h3><p>如下图所示, 三块石头放在一起, 如果大小一致, 看起来就会觉得单调, 这就是节奏单一的表现</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233424.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233424.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>节奏也可以称为变化, <strong>大小</strong>, <strong>形状</strong>, <strong>疏密</strong>, <strong>明暗</strong>都可以称为节奏的一部分, 具有节奏感的画面看起来就会觉得舒适, 具有视觉重心</p><p><br/></p><h3 id="大小的变化"><a href="#大小的变化" class="headerlink" title="大小的变化"></a>大小的变化</h3><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233432.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233432.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>大小的对比可以很简单的营造画面的节奏感, 但是需要注意在分布大小比例时不要束缚手脚，对于绘画来说, 可以适当夸大对比，3：7和2：8是比较推荐的尺寸</p><p>下图是一个很好地例子: 角色的身体部位被适当的夸张比例, 营造出了很好地节奏感</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233436.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233436.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>这种大小对比在卡通角色身上表现得会更加明显</p><p><br/></p><h3 id="形状的变化"><a href="#形状的变化" class="headerlink" title="形状的变化"></a>形状的变化</h3><p>除了在大小上做出变化以外, 物理的形状也应该多种多样</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233441.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233441.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="疏密的变化"><a href="#疏密的变化" class="headerlink" title="疏密的变化"></a>疏密的变化</h3><p>疏密一般来说可以指细节的分布, 举例来说, 如果一幅画面全是细节, 没有一个视觉重心, 那么就会让人产生疲劳的感觉, 所以有的时候一味的加细节并不是很好地选择, 适当选择细节的分布既可以减轻整体的工作量, 又可以使画面更上一层</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233445.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233445.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>细节的疏密在很大程度上与明暗关系有关, 过暗或者过亮的地方细节会丢失, 而中性灰的地方保留了最多的物体细节</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233450.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233450.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233454.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233454.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="结合以上的案例分析"><a href="#结合以上的案例分析" class="headerlink" title="结合以上的案例分析"></a>结合以上的案例分析</h3><p>看下面这张图</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233458.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233458.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>下面涂黑的地方差不多是每个物体的<strong>大小面积</strong>, 可以看出, 中间的主体建筑在画面中占据了绝大部分的画面, 而剩下的远处的高楼大小分布也错落有致, 这样的分布就使得整体的画面看起来和谐, 并且具有一个视觉中心</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233502.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233502.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>接着看下图红笔圈出的地方, 可以看出全图中的整体<strong>形状分布错落有致</strong>, 基本上是三种几何形状的穿插, 这样的好处就是不会让人觉得画面单调</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233506.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233506.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>在整体细节分布方面, <strong>主体建筑占据了绝大部分细节</strong>, 虽然这是张草图, 但是任然可以看出主要细节是分布在视觉中心上的, 远处或者暗处的物体细节应该尽量减少, 在渲染阶段, 也许我们会得到一张全图细节都非常高的图, 那在后期阶段就需要手动去降低某些地方的细节</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233510.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233510.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>总结：忌讳重复，需要有一定的变化</strong></p><p><br/></p><h3 id="节奏变化在建模中的具体表现（以卡通为例）"><a href="#节奏变化在建模中的具体表现（以卡通为例）" class="headerlink" title="节奏变化在建模中的具体表现（以卡通为例）"></a>节奏变化在建模中的具体表现（以卡通为例）</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233514.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233514.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>上图是节奏变化理论在卡通造型中的一种体现(也许是卡通特色), 人物的肩甲及手环腰带等常规来说是粗细相等的物体在实际建模的时候变成了粗细不一的样子, 在一些不需要特别写实的动画上, 这样做能显著加强画面的动感.</p><p><br/></p><h2 id="营造画面和力量感"><a href="#营造画面和力量感" class="headerlink" title="营造画面和力量感"></a>营造画面和力量感</h2><hr><h3 id="力量感的表现"><a href="#力量感的表现" class="headerlink" title="力量感的表现"></a>力量感的表现</h3><p>观察迪士尼的动画</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233518.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233518.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>如上图中的史迪奇, 右边的史迪奇明显看起来更加具有动感, 这是因为左边的史迪奇相比拥有了更多的曲线变化, 简而言之就是没有”大曲线”, 或者说, 原有曲线的力量感被多余的曲线给”打断了”</p><p>也就是说: <strong>直线具有力量感，太多的曲线让力量感缺失</strong> </p><p>看下面这张草图</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233522.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233522.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>从身体两边的对比来看, 一遍是干净的C型曲线, 一边有着更多的弯折, 就形成了一种力量感的对比</p><p>再看下面这两张图</p><p>相比左图, 右图主要修改了刀和身体的曲线, 马上就使兽人挥刀的姿势更具有力量感</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233526.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233526.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="曲线的表达手法"><a href="#曲线的表达手法" class="headerlink" title="曲线的表达手法"></a>曲线的表达手法</h3><p>虽说干净的曲线会让画面更具力量感, 但我们仍然需要注意一些曲线排布的误区</p><p>典型来说, 首要规避的就是下图左边所示的所谓”葫芦形”曲线, 表现时可以让两条曲线错开, 画面就会和谐很多</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233529.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233529.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p>在另一方面, 直线和曲线的对比就会比较舒适, 如下图雕像少女左边身体的曲线便和右边形成了鲜明的对比</p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233533.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233533.png" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h2 id="画面重量的分布"><a href="#画面重量的分布" class="headerlink" title="画面重量的分布"></a>画面重量的分布</h2><hr><p>画面中, 重量的分布是很重要的手法, 画面的重量分布和视觉的平衡和整体画面给人的感觉都有关系</p><p>在感觉上, 如果画面整体的视觉重心偏下,就会给人稳定的感觉, 相反, 提高重心有时候会有一种敏捷的感觉(某些情况)</p><p>例如, 在人体体块的分布上, 使用重量分布的原则就可以很轻易塑造出角色给人的感觉</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233536.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233536.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>下面是一个直观的例子</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233539.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233539.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/4b97ec9b.html">http://dynais.xyz/posts/4b97ec9b.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;hr&gt;
&lt;div class=&quot;figure center&quot; style=&quot;width:50%;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233415.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;&quot; data-caption=&quot;&quot; data-fancybox=&quot;default&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201113233415.png&quot; style=&quot;width:50%;height:50%;&quot;alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="art" scheme="http://dynais.xyz/categories/note/art/"/>
    
    
      <category term="Art" scheme="http://dynais.xyz/tags/Art/"/>
    
  </entry>
  
  <entry>
    <title>DuinoAccess指纹锁项目 - Part.1</title>
    <link href="http://dynais.xyz/posts/c75b2aac.html"/>
    <id>http://dynais.xyz/posts/c75b2aac.html</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2020-08-20T12:54:18.348Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><hr><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 - 前言"></a>0x00 - 前言</h2><p>这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。</p><p>这个项目的一个主要的灵感来源是@<a href="https://space.bilibili.com/20259914/dynamic" target="_blank" rel="noopener">稚晖君</a>很早以前发在Arduino论坛上的一个项目 (<a href="https://www.arduino.cn/thread-86889-1-3.html" target="_blank" rel="noopener">Link: 如何制作一个带指纹识别的机械键盘</a>), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能</p><p>然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目…</p><p>这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：<a href="https://github.com/DynAis/duino-access" target="_blank" rel="noopener">https://github.com/DynAis/duino-access</a></p><a id="more"></a><p><br/></p><p><br/></p><hr><h2 id="0x01-核心部分元器件选型"><a href="#0x01-核心部分元器件选型" class="headerlink" title="0x01 - 核心部分元器件选型"></a>0x01 - 核心部分元器件选型</h2><p>这次的目标是能够使用指纹解锁的方式让电脑自动解锁，思路是使用指纹模块给出信号+单片机模拟键盘输入的简单思路，由于整体的体积要求越小越好，所以元件的选型基本没有选择</p><div class="table-container"><table><thead><tr><th>使用模块</th><th>价格</th></tr></thead><tbody><tr><td>arduino-pro-micro (VCC 5v or 3.3v)</td><td>19.80 CNY</td></tr><tr><td>HN0610 指纹模块</td><td>45.00 CNY</td></tr><tr><td>AMS1117-3.3v/5v 降压模块 (假如使用5v的arduino，3.3v的不需要)</td><td>1.29 CNY</td></tr><tr><td>蜂鸣器、导线若干</td><td>-</td></tr></tbody></table></div><p>之所以没有用稚晖的那个FPM3X指纹模块的原因是因为那个好像在TB上已经快找不到了，只剩下最后一家而且卖的很贵，所以当时就选择了这个卖得最好的来做(有几天自闭的时候非常后悔这个选择)，并且从外观上来说我更喜欢这款一点</p><p><br/></p><p><br/></p><hr><h2 id="0x02-环境选择与搭建"><a href="#0x02-环境选择与搭建" class="headerlink" title="0x02 - 环境选择与搭建"></a>0x02 - 环境选择与搭建</h2><h3 id="VSCode-PlatformIO"><a href="#VSCode-PlatformIO" class="headerlink" title="VSCode + PlatformIO"></a>VSCode + PlatformIO</h3><p>整个环境方面没有使用传统的 ArduinoIDE 来做，而是选择的使用 VSCode 来完成这次的项目，主要原因是为了以后做其他单片机项目的时候也都统一到 VSCode上去，这样整个一致性会比较好</p><p>最后选择了 VSCode 的 PlatformIO 拓展</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184349.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184349.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>直接在 VSCode 的拓展商店里搜索即可，点击安装即可安装插件，不用动什么脑子，安装过程会有些慢需要耐心等待一会，安装完成后如果成功了你应该可以在左下角看到这个小图标</p><div class="figure center" style="width:30%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184359.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184359.png" style="width:30%;height:30%;"alt=""></a></div><div style="clear:both;"></div><p>恭喜，如果你看到了这个小房子，那你基本就是安装成功了，但是由于各种各样的原因，你也很有可能等了半天他也还是在转圈圈加载，像我一样</p><div class="figure center" style="width:90%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184405.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184405.png" style="width:90%;height:90%;"alt=""></a></div><div style="clear:both;"></div><p>那么大概率他是不能自己装上了，我们只能来手动安装</p><p>首先，如果你安装失败了，请先卸载原来的安装失败的 PlatformIO ，重启 VSCode，之后在VSCode的终端里输入</p><p><code>sudo pip --no-cache-dir install -U platformio</code></p><p>等待他安装完成，重启VSCode，重新去商店点一下安装，就可以顺利的装上了</p><div class="alert info"><p>如果依旧不行，可以尝试: 移除Anaconda(假如你安装了Anaconda环境)、安装Python2.7版本并且添加进环境变量、安装Python最新版本并添加进环境变量，如果这也不行，那就尝试使用ArduinoIDE吧(不过这样也许需要稍微改动下代码)</p></div><p><br/></p><h3 id="PlatformIO开发准备"><a href="#PlatformIO开发准备" class="headerlink" title="PlatformIO开发准备"></a>PlatformIO开发准备</h3><p>点击Home按钮打开 PlatformIO 主界面，new project 后选择对应的板子，他会进行自动的初始化</p><div class="figure center" style="width:90%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184414.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184414.png" style="width:90%;height:90%;"alt=""></a></div><div style="clear:both;"></div><p>初始化完成后，在src文件夹里就是我们的main文件</p><div class="figure center" style="width:90%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184421.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184421.png" style="width:90%;height:90%;"alt=""></a></div><div style="clear:both;"></div><p>PlatformIO 和 ArduinoIDE 不同的地方就是，他是使用cpp文件来进行编译上传的，而不是ino文件，所以每个需要用到 Arduino 库的文件中，都需要包含<code>#include &quot;Arduino.h&quot;</code>才能够使用</p><p>此外，比较麻烦的一点是，对于某些库的支持，也是需要我们手动来加入的，比如这块 Pro Micro 支持的HID键盘和鼠标的功能，就需要我们手动加入</p><p>首先打开刚才的Home界面，在左边一栏里可以找到 Libraries</p><div class="figure center" style="width:40%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184426.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184426.png" style="width:40%;height:40%;"alt=""></a></div><div style="clear:both;"></div><p>搜索<code>keyboard</code>，找到这个 Arduino 的官方库文件安装</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184431.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184431.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>安装完成以后，到左边的资源管理器，找到<code>platformio.ini</code>这个文件<div class="figure center" style="width:70%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184436.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184436.png" style="width:70%;height:70%;"alt=""></a></div><div style="clear:both;"></div></p><p>在文件最后加入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lib_deps</span> = </span><br><span class="line">    Keyboard</span><br></pre></td></tr></table></figure><p>告诉他我们要调用这个库，这样就完成了，可以开始硬件部分的测试了</p><p><br/></p><p><br/></p><hr><h2 id="0x03-硬件部分"><a href="#0x03-硬件部分" class="headerlink" title="0x03 - 硬件部分"></a>0x03 - 硬件部分</h2><div class="alert warning"><p>一定要注意指纹模块的供电是3.3v，使用5v虽然不会烧坏模块但是会无法工作(当初因为这个原因卡了好久不知道哪错了)</p></div><p>指纹模块的话是线给剪了直接焊在了板子上，有点粗糙</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184449.jpg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184449.jpg" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>看不清楚的话也可以看源文件里 <code>/lib/HN0610/pinDef.h</code> 里的内容</p><p>最后附上Micro的引脚图</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184454.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184454.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="测试指纹模块"><a href="#测试指纹模块" class="headerlink" title="测试指纹模块"></a>测试指纹模块</h3><p>修改 <code>/src/min.cpp</code> 文件中参数调整宏定义区域的参数  <code>DASTATE</code> 就可以设定当前运行在什么模式下，由于是测试，就把值改为0，运行在检测手指模式上，其他模式的定义也在下面给出</p><div class="table-container"><table><thead><tr><th>功能实现</th><th>DASTATE值</th></tr></thead><tbody><tr><td>检测手指按压</td><td>0</td></tr><tr><td>指纹注册</td><td>1</td></tr><tr><td>验证指纹(最后留这一个)</td><td>2</td></tr><tr><td>检测手指按压后输出硬件信息(需要打开电脑串口)</td><td>3</td></tr><tr><td>清除所有指纹信息</td><td>4</td></tr></tbody></table></div><p> 点击上传烧录进Arduino</p><p>如果没有问题的话，按下手指蜂鸣器就会鸣响了</p><p><br/></p><p><br/></p><hr><h2 id="0x04-遇到的坑和问题"><a href="#0x04-遇到的坑和问题" class="headerlink" title="0x04 - 遇到的坑和问题"></a>0x04 - 遇到的坑和问题</h2><h3 id="1-底层数据类型定义问题"><a href="#1-底层数据类型定义问题" class="headerlink" title="1. 底层数据类型定义问题"></a>1. 底层数据类型定义问题</h3><p>通常来说，开发单片机会定义一系列的UINT</p><p>在这次，定义文件写在了 <code>hzTypes.h</code> 文件里，其中对于UINT32的定义出现了兼容错误</p><p>原始内容是</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184458.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184458.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>我猜测可能是由于他们使用的单片机上int是32位，所以能够正常运行，而在Arduino上，int并不是32位的，long才是，所以需要改为</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184502.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184502.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="2-电源的坑"><a href="#2-电源的坑" class="headerlink" title="2.电源的坑"></a>2.电源的坑</h3><p>已经说过了，不过这次也是因为在家里没有万用表的缘故，并且提醒，虽然原理图上有一个SJ1来控制Micro的输出电压是5v还是3.3v，但是你并不可以通过连接或者断开这个引脚来达到修改电压的目的，因为5v的Micro和3.3v的Micro主频也是不一样的，这会导致工作不稳定</p><p>并且很有可能改了也没有作用(对于很多国产板)</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184513.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200820184513.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><h3 id="3-注意Micro的中断脚"><a href="#3-注意Micro的中断脚" class="headerlink" title="3.注意Micro的中断脚"></a>3.注意Micro的中断脚</h3><p>因为这个指纹识别模块还有自动休眠的功能，所以虽然我现在并没有使用，但是很有可能会用到这个模块的中断信号，那么就要注意Micro的中断引脚定义和Uno是不一样的</p><div class="table-container"><table><thead><tr><th>PIN</th><th>中断号</th></tr></thead><tbody><tr><td>3</td><td>0</td></tr><tr><td>2</td><td>1</td></tr><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>3</td></tr><tr><td>7</td><td>6</td></tr></tbody></table></div><p><br/></p><p><br/></p><hr><h2 id="0x05-后续开发"><a href="#0x05-后续开发" class="headerlink" title="0x05 - 后续开发"></a>0x05 - 后续开发</h2><h3 id="库HN610"><a href="#库HN610" class="headerlink" title="库HN610"></a>库HN610</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>内容</th></tr></thead><tbody><tr><td>auth</td><td>通讯签名算法(默认不签名)</td></tr><tr><td>fp</td><td>大部分能直接用的API</td></tr><tr><td>fpmComm</td><td>模块命令API</td></tr><tr><td>hzDevice</td><td>串口通信底层</td></tr><tr><td>pinDef</td><td>主板引脚定义</td></tr><tr><td>hzTypes</td><td>数据类型定义</td></tr></tbody></table></div><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/c75b2aac.html">http://dynais.xyz/posts/c75b2aac.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;hr&gt;
&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 - 前言&quot;&gt;&lt;/a&gt;0x00 - 前言&lt;/h2&gt;&lt;p&gt;这次也是因为闲的在家没有事情做，所以又给自己开了一个新坑，其实蛮早以前就有过想做一个电脑上能用的指纹锁的想法了，但是一直没有动手，刚好这次有机会，并且也是刚刚新组了一台电脑，就想着要把这个项目给做了。&lt;/p&gt;
&lt;p&gt;这个项目的一个主要的灵感来源是@&lt;a href=&quot;https://space.bilibili.com/20259914/dynamic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;稚晖君&lt;/a&gt;很早以前发在Arduino论坛上的一个项目 (&lt;a href=&quot;https://www.arduino.cn/thread-86889-1-3.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Link: 如何制作一个带指纹识别的机械键盘&lt;/a&gt;), 这次项目的的主要思路都和他的差不多，只不过我想做成独立的一个模块，并且最好能够实现便携功能，也就是说如果可以的话我想加上蓝牙的功能&lt;/p&gt;
&lt;p&gt;然后这次的文章大概也会写好几部分，具体取决于我最后能不能最后好好完成这个项目…&lt;/p&gt;
&lt;p&gt;这是一个开源项目，后续也会一直更新进度，对你有帮助的话可以给我个星星，传送门：&lt;a href=&quot;https://github.com/DynAis/duino-access&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/DynAis/duino-access&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="arduino" scheme="http://dynais.xyz/categories/note/arduino/"/>
    
    
      <category term="单片机" scheme="http://dynais.xyz/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="Arduino" scheme="http://dynais.xyz/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>Blender真实云层模拟练习</title>
    <link href="http://dynais.xyz/posts/cd7d3ea.html"/>
    <id>http://dynais.xyz/posts/cd7d3ea.html</id>
    <published>2020-08-07T16:00:00.000Z</published>
    <updated>2020-11-16T09:00:00.194Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><hr><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p><strong>一周前的周末, 当时我正在高速上, 要说那天的天气是真的好, 说实话这么蓝的天真的好久没见过了, 就是那种让人一看就觉得 “啊, 夏天就是要这个样子啊” 的感觉的那种很蓝的天.</strong> </p><p><strong>然后路过了一团很大块很立体的云:</strong></p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200808004855.jpg" target="_blank" rel="noopener" title="随手拍的" data-caption="随手拍的" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200808004855.jpg" style="width:75%;height:75%;"alt="随手拍的"></a><span class="caption">随手拍的</span></div><div style="clear:both;"></div><p><strong>当时阳光很强烈, 云的层次也非常立体, 不知道为什么, 我陷入了一种对自然开始奇妙敬畏的状态中, 然后拍了这张照想作为参考(结果完全忘记了).</strong></p><p><strong>刚好这几个月都在学3d建模, 但是由于上一个作品太烂让我陷入了自我怀疑当中, 差点想当场放弃, 如果真的有人想看的话大概是这么个东西:</strong></p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200412.jpeg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200412.jpeg" style="width:75%;height:75%;"alt=""></a></div><div style="clear:both;"></div><p><strong>啊反正当时看着这块云就想, 复杂的场景做不来就一块云我死磕难道还做不出来? </strong></p><p><strong>这么一想当时热情激昂, 心潮澎湃啊, 脑子里直接出现大片, 什么角度拍我都完全想好了(并没有), 为了防止忘记我当时还画了草图:</strong></p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200656.png" target="_blank" rel="noopener" title="狂野的线条足以表现我内心的激动" data-caption="狂野的线条足以表现我内心的激动" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200656.png" style="width:75%;height:75%;"alt="狂野的线条足以表现我内心的激动"></a><span class="caption">狂野的线条足以表现我内心的激动</span></div><div style="clear:both;"></div><p><br/></p><a id="more"></a><p><br/></p><hr><h2 id="0x01-前期准备"><a href="#0x01-前期准备" class="headerlink" title="0x01-前期准备"></a>0x01-前期准备</h2><p><strong>虽然自己画了草图, 当回过神来发现毕竟是画画苦手, 我已经快认不出来自己画的是什么了, 想了想还是看看别人的作品比较靠谱, 首先想到的就是天气之子, 和我当时的想法比较接近</strong></p><p><br/></p><h3 id="云层模拟效果参考"><a href="#云层模拟效果参考" class="headerlink" title="- 云层模拟效果参考"></a>- 云层模拟效果参考</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201742.jpeg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201742.jpeg" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>但是其实除了这个以外, 我还是想加上体积光的, 就是丁达尔效应, 没有为什么, 就觉得很帅, 然后我又找了一张体积光的参考图</strong></p><p><br/></p><h3 id="体积光模拟效果参考"><a href="#体积光模拟效果参考" class="headerlink" title="- 体积光模拟效果参考"></a>- 体积光模拟效果参考</h3><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201759.jpeg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201759.jpeg" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><p><strong>当时我觉得只要把这两张图的效果缝合一下就成了</strong></p><p><strong>之后我又去百度一下云的分类, 好到时候分别做出来</strong></p><p><br/></p><h3 id="云层分解"><a href="#云层分解" class="headerlink" title="- 云层分解"></a>- 云层分解</h3><p><strong>理了一下思路，觉得可以分为四类云来叠加处理(以下复制WIKI)：</strong></p><p><br/></p><ul><li><p><strong>积云</strong>（拉丁语：Cumulus，符号：Cu）常在晴天出现，通常具有如同棉花的形状。云顶部常呈现菜花状或是圆弧状，云底基本为水平状，多垂直向上发展。云内部的凝结核密度较高，当挡在阳光前能明显看出明暗差距。</p><p><br/></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201808.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201808.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p></li><li><p><strong>积雨云</strong>是对流云发展的极盛阶段，云体浓厚庞大，云底混乱，颜色阴暗，有滚轴或悬球状，有时扩展达几千米宽，云底在3,000到4,000米左右，云顶可以向高空伸展，可达23,000米，相成蘑菇状，也可在低部5,000米处平衍，形成铁砧状，当云顶到达-15℃以下的高空时，水滴冻结成冰晶，呈现白色，云浓密时，云体出现闪电，云色昏暗</p><p><br/></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201821.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201821.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p></li><li><p><strong>毛卷层云</strong>（学名：Cirrostratus fibratus，缩写： Cs fib )，是卷层云的一种。毛卷层云形似纤维状的面纱，云体上能见细薄的条纹。毛卷层云可以自毛卷云发展而来，在更少的情况下也可由密卷云发展而来。</p><p><br/></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201831.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201831.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p></li><li><p><strong>高层云</strong>(英语：(As)Altostratus (cloud))是中云的一类，于2000米以上高空形成，像一种带有条纹的幕，颜色多为灰白色或灰色，有时有一点微蓝色，有时较为均匀，但云底没有明显的起伏。高层云的明暗程度会因云的厚度差异而不同。</p><p><br/></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201844.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810201844.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p></li></ul><p><strong>感觉已经成功一半了! 因为其实B站和油管上面这方面的教程还算是蛮多的, 做个云我觉得不成问题, 然后我就去找了几个视频学习了一下</strong></p><p><br/></p><p><br/></p><h2 id="0x02-云的模拟"><a href="#0x02-云的模拟" class="headerlink" title="0x02-云的模拟"></a>0x02-云的模拟</h2><div class="alert warning"><p>我使用Blender进行建模, 请注意cycles和eevee渲染器的区别，虽然eevee的速度很快并且效果不错，但对于第二种建模方法来说没有找到eevee可用的方法</p></div><h3 id="程序生成法"><a href="#程序生成法" class="headerlink" title="- 程序生成法"></a>- 程序生成法</h3><p><strong>我首先看的是程序化生成云的教程, 这种方法适合做一大片一大片的云, 用来做卷层云和高层云效果应该不错</strong></p><p><br/></p><ul><li><p><a href="https://www.bilibili.com/video/BV1P44111733?p=5" target="_blank" rel="noopener">【Blender特效】震撼！！！blender写实级特效技术教程！！程序化云层制作分享</a></p></li><li><p><a href="https://www.youtube.com/watch?v=lPAYX8z9i8M" target="_blank" rel="noopener">Creating Procedural Volumetric Clouds with Blender Eevee</a></p></li></ul><p><br/></p><p>这两种方法的思路大同小异，但是首先先拉一个立方选定云层生成的范围（教程中eevee拉的是平面，不过这种方法cycles用不了，所以我换成了立方，其实是差不多的）</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202204.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202204.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>然后就可以打开材质节点直接上材质了</p><p>先放个节点的图</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202209.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202209.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>大概思路就是直接用噪波纹理来生成云的样子，通过矢量映射节点可以调节噪波具体的形状走向，在通过和一个渐变纹理的相乘来实现边缘虚化，最后传统艺能颜色渐变调个对比就可以输出了。</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202216.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202216.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><div class="alert info"><p>如果云看起来不够白的话，可能是光照不足的问题，也可以尝试将最后颜色渐变的白值（hsv的v调到超过1的范围试试，以及别忘了改原理化体积里的颜色）</p></div><p><br/></p><h3 id="建模法"><a href="#建模法" class="headerlink" title="- 建模法"></a>- 建模法</h3><p><strong>除了使用程序纹理以外, 要做大一点的类似实心的云的话还是用建模的方法感觉比较快一点.</strong></p><p><br/></p><ul><li><p><a href="https://www.youtube.com/watch?v=Y1Uc-DdRJgI" target="_blank" rel="noopener">Create clouds in blender 2.8</a></p></li><li><p><a href="https://www.youtube.com/watch?v=-AQiPn_zl2w" target="_blank" rel="noopener">How to Make Realistic Cumulus Clouds in Blender</a></p></li></ul><p><br/></p><p>用建模的方法的话，需要注意的一点就是整个模型最好就是用立方体组成，类似Minecraft的那种效果，对后面修改器的应用比较重要。可以手动拉也可以尝试一下用重构网络修改器的方块（虽然我没试过）</p><p>总之大概思路就是不停套娃细分和置换修改器，用沃罗诺伊纹理的负强度来实现云的类似球状的组成</p><p>从这样</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202227.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202227.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>干到这样</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202233.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202233.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>修改器</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202237.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202237.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>然后直接上体积（其实我觉得应该再用噪波上一些细节，因为最后的效果不是很好）</p><p>嘛但是我失败了（失败了还讲这么多的屑）</p><p>我以为我能做出这样的</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202245.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202245.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>但是实际上我是这样的</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202251.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202251.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>但是总的来说程序生成和建模的思路都是差不多的, 都是生成大的外形，用沃罗诺伊图组成云团类似圆球的部分，然后用噪波之类的加上细节. 然后给一个体积.（讲得倒是挺简单）</strong></p><p><br/></p><h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="- 一些技巧"></a>- 一些技巧</h3><ul><li><p>使用eevee时的渲染参数调试，注意把体积的平铺尺寸改到2x或者4x，这样会更加精细一点，同样道理还有体积的采样和体积阴影（记得打开）</p><p><br/></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202329.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202329.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p></li><li><p>输出时使用颜色渐变hsv超过1的白值可以使云看起来阴影更立体（可以自己斟酌使用）</p></li><li><p>灯光的强度会影响云实际看起来的颜色</p></li></ul><p><br/></p><p><strong>但是理论归理论, 实际做的时候会有各种不可控因素, 比如看起来像是由于神秘因素导致事情的发展逐渐脱离轨道的云</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202335.png" target="_blank" rel="noopener" title="这其实是积雨云..." data-caption="这其实是积雨云..." data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202335.png" style="width:100%;height:100%;"alt="这其实是积雨云..."></a><span class="caption">这其实是积雨云...</span></div><div style="clear:both;"></div><p><strong>虽然建模法的云看起来很糟心, 但是程序生成的其实看起来还不错，毕竟我的想象中是需要他们叠在一起的, 所以我尝试融合了他们一下</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202344.jpeg" target="_blank" rel="noopener" title="吐了" data-caption="吐了" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202344.jpeg" style="width:100%;height:100%;"alt="吐了"></a><span class="caption">吐了</span></div><div style="clear:both;"></div><p><strong>修修补补了好久也没什么大的效果, 后来索性就不去管他了, 当时还有个体积光的问题没有解决, 就没再管这边.</strong></p><p><br/></p><p><br/></p><h2 id="0x03-体积光模拟"><a href="#0x03-体积光模拟" class="headerlink" title="0x03-体积光模拟"></a>0x03-体积光模拟</h2><p><strong>相对做云来说, 体积光还是相对不那么容易翻车的, 因为还算是非常简单的. 只要用立方体包围所要表现的空间, 然后给一个很小的体积散射就能出效果了</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202353.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202353.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202402.jpeg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202402.jpeg" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><p><br/></p><h2 id="0x04-思路转换"><a href="#0x04-思路转换" class="headerlink" title="0x04-思路转换"></a>0x04-思路转换</h2><p><strong>由于前一天发现自己不管怎么摆弄场景看起来都很糟心, 所以第二天我决定不在一棵树上吊死。</strong></p><p><strong>我思考了一下，看起来很糟糕是因为云的细节确实有点难处理，再说我设定的是一个从天上看的角度，又没办法避免这个问题。</strong></p><p> <strong>那我只要从地上看云的话，距离这么远, 稍微粗糙一点也没人看得出来是吧. 想到这里我忍不住要为自己的机智鼓掌。</strong></p><p><strong>首先我画了新的草图</strong></p><p><strong>虽然是为了偷懒，但我本来就是为了做云，所以首先云肯定得有，而且要大，看起来才爽，所以我先画了云：</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202410.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202410.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>但是大不大这个东西是要有对比才能体现的，所以我又加上了对比物</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202416.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202416.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>为了防止有人看不懂我可以解释一下那个东西是热气球</strong></p><p><strong>然后我觉得得有个人物让画面更鲜活一点，所以我又加了个人</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202421.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202421.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>但是我后来一想，不对，我不会做草啊，所以我简化了一下</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202428.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202428.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><p><br/></p><hr><h2 id="0x05-沙地模拟"><a href="#0x05-沙地模拟" class="headerlink" title="0x05-沙地模拟"></a>0x05-沙地模拟</h2><p><strong>沙子的纹理制作我参考了两个教程，第一个是<a href="https://www.youtube.com/watch?v=sXGFhbey8P8" target="_blank" rel="noopener">Quick and Dirty: Procedural Sand Dunes in Blender 2.8</a>，这个效果远看还行，但是近看着实禁不起推敲</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202433.png" target="_blank" rel="noopener" title="我最后用来做了远景" data-caption="我最后用来做了远景" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202433.png" style="width:100%;height:100%;"alt="我最后用来做了远景"></a><span class="caption">我最后用来做了远景</span></div><div style="clear:both;"></div><p>放上节点</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202437.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202437.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>由于效果不太好我就没仔细分析节点</strong></p><p><strong>然后我又去参考了 <a href="https://www.youtube.com/watch?v=ySyxN34_qsI" target="_blank" rel="noopener">How to make sand in Blender Cycles</a> 它的思路很棒，通过两个超高缩放的沃罗诺伊和噪波纹理混合再旋转微小的角度进行叠加，模拟砂砾的效果很好</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202513.png" target="_blank" rel="noopener" title="很细腻，但是我的电脑有点卡..." data-caption="很细腻，但是我的电脑有点卡..." data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202513.png" style="width:100%;height:100%;"alt="很细腻，但是我的电脑有点卡..."></a><span class="caption">很细腻，但是我的电脑有点卡...</span></div><div style="clear:both;"></div><p>同样节点图</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202554.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202554.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><p><br/></p><hr><h2 id="0x06-人物"><a href="#0x06-人物" class="headerlink" title="0x06-人物"></a>0x06-人物</h2><p><strong>这个简单，搬MMD模型我老熟了，Amiya直接搬过来借用一下</strong></p><p><strong>模型制作：i-Fox</strong></p><p><br/></p><div class="figure center" style="width:75%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202602.png" target="_blank" rel="noopener" title="Amiya" data-caption="Amiya" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202602.png" style="width:75%;height:75%;"alt="Amiya"></a><span class="caption">Amiya</span></div><div style="clear:both;"></div><p><br/></p><p><br/></p><hr><h2 id="0x07-天空特效"><a href="#0x07-天空特效" class="headerlink" title="0x07-天空特效"></a>0x07-天空特效</h2><p><strong>最后还是就剩下天空了，后来又做了几次体积云，但是都失败了，感觉不错的只有之前做的一个卷层云，就套上去渲染了一下</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202608.jpeg" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202608.jpeg" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><strong>其实也还行，但是还是少点感觉，别问我为什么有个圆柱</strong></p><p><strong>我就想要不整个鬼酷一点的算了，然后改了一下纹理，做成那种环绕天空的云</strong></p><p><br/></p><p>大概思路就是波浪纹理打底</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202614.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202614.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>然后沃罗诺伊啊噪波什么的混合一下，再调个对比度，做成这样连上体积</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202623.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202623.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202633.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202633.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p>大概就可以得到这样的效果</p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202639.jpeg" target="_blank" rel="noopener" title="感觉还不错" data-caption="感觉还不错" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202639.jpeg" style="width:100%;height:100%;"alt="感觉还不错"></a><span class="caption">感觉还不错</span></div><div style="clear:both;"></div><p><strong>本来这样就应该结束了，毕竟我尝试了实在做不出来大块的云</strong></p><p><strong>但是还是想知道别人到底是怎么做出来的那么像的云，所以又去网上找了一下做好的资源，打开一看</strong></p><p><br/></p><p><strong>是贴图…</strong></p><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202647.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202647.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><div class="figure center" style="width:100%;"><a class="fancybox" href="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202651.png" target="_blank" rel="noopener" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810202651.png" style="width:100%;height:100%;"alt=""></a></div><div style="clear:both;"></div><p><br/></p><p><strong>算了，嫖了（躺）</strong></p><p><br/></p><!-- endcontent --><div class="figure figure--fullWidth"><img class="figure-img" src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810195007.jpg" alt="Storm  comming"><span class="caption">Storm  comming</span></div><!-- content --><p><br/><br/></p><hr><blockquote><p>参考资料链接：</p><p>[云-维基百科]:<a href="https://zh.wikipedia.org/wiki/%E4%BA%91#%E6%88%90%E5%9B%A0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%91#%E6%88%90%E5%9B%A0</a></p><p>[云隙光-维基百科]:<a href="https://zh.wikipedia.org/wiki/%E9%9B%B2%E9%9A%99%E5%85%89" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%9B%B2%E9%9A%99%E5%85%89</a></p><p>[Create clouds in blender 2.8]:<a href="https://www.youtube.com/watch?v=Y1Uc-DdRJgI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Y1Uc-DdRJgI</a></p><p>[Creating Procedural Volumetric Clouds with Blender Eevee]:<a href="https://www.youtube.com/watch?v=lPAYX8z9i8M" target="_blank" rel="noopener">https://www.youtube.com/watch?v=lPAYX8z9i8M</a></p><p>[How to Make Realistic Cumulus Clouds in Blender]:<a href="https://www.youtube.com/watch?v=-AQiPn_zl2w" target="_blank" rel="noopener">https://www.youtube.com/watch?v=-AQiPn_zl2w</a></p><p>[【Blender特效】震撼！！！blender写实级特效技术教程！！程序化云层制作分享]:<a href="https://www.bilibili.com/video/BV1P44111733?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1P44111733?p=5</a></p></blockquote><p><br/></p><p><strong>写文章也太累了</strong></p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/cd7d3ea.html">http://dynais.xyz/posts/cd7d3ea.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;hr&gt;
&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00-前言&quot;&gt;&lt;/a&gt;0x00-前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一周前的周末, 当时我正在高速上, 要说那天的天气是真的好, 说实话这么蓝的天真的好久没见过了, 就是那种让人一看就觉得 “啊, 夏天就是要这个样子啊” 的感觉的那种很蓝的天.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后路过了一团很大块很立体的云:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;figure center&quot; style=&quot;width:75%;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200808004855.jpg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;随手拍的&quot; data-caption=&quot;随手拍的&quot; data-fancybox=&quot;default&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200808004855.jpg&quot; style=&quot;width:75%;height:75%;&quot;alt=&quot;随手拍的&quot;&gt;&lt;/a&gt;&lt;span class=&quot;caption&quot;&gt;随手拍的&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;当时阳光很强烈, 云的层次也非常立体, 不知道为什么, 我陷入了一种对自然开始奇妙敬畏的状态中, 然后拍了这张照想作为参考(结果完全忘记了).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刚好这几个月都在学3d建模, 但是由于上一个作品太烂让我陷入了自我怀疑当中, 差点想当场放弃, 如果真的有人想看的话大概是这么个东西:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;figure center&quot; style=&quot;width:75%;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200412.jpeg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;&quot; data-caption=&quot;&quot; data-fancybox=&quot;default&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200412.jpeg&quot; style=&quot;width:75%;height:75%;&quot;alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;啊反正当时看着这块云就想, 复杂的场景做不来就一块云我死磕难道还做不出来? &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这么一想当时热情激昂, 心潮澎湃啊, 脑子里直接出现大片, 什么角度拍我都完全想好了(并没有), 为了防止忘记我当时还画了草图:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;figure center&quot; style=&quot;width:75%;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200656.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;狂野的线条足以表现我内心的激动&quot; data-caption=&quot;狂野的线条足以表现我内心的激动&quot; data-fancybox=&quot;default&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200810200656.png&quot; style=&quot;width:75%;height:75%;&quot;alt=&quot;狂野的线条足以表现我内心的激动&quot;&gt;&lt;/a&gt;&lt;span class=&quot;caption&quot;&gt;狂野的线条足以表现我内心的激动&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="blender" scheme="http://dynais.xyz/categories/note/blender/"/>
    
    
      <category term="blender" scheme="http://dynais.xyz/tags/blender/"/>
    
      <category term="cycles" scheme="http://dynais.xyz/tags/cycles/"/>
    
  </entry>
  
  <entry>
    <title>[转载]Hexo+Github Page搭建博客教程</title>
    <link href="http://dynais.xyz/posts/4f8b0717.html"/>
    <id>http://dynais.xyz/posts/4f8b0717.html</id>
    <published>2020-07-23T02:40:06.000Z</published>
    <updated>2020-07-24T17:12:23.604Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">前往原文</a></strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。</p><p>这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p><p>下面就开始吧~</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>准备 node 和 git 环境，<br>首先，安装 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a>，因为 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。<br>然后，安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git</a> 教程。</p><a id="more"></a><p>两个工具不同的平台安装方法有所不一样，可自行了解按步骤安装，这里不详述了。安装成功后打开git bash（Windowns）或者终端（Mac），下方中将统一称为命令行。<br>在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011037" alt="image"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 的详细文档。<br>在命令行输入执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds # 模版文件夹</span><br><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br><span class="line">|   ├── _drafts # 草稿文件</span><br><span class="line">|   └── _posts # 文章Markdowm文件 </span><br><span class="line">└── themes  # 主题文件夹</span><br></pre></td></tr></table></figure><p>好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>:4000 回车就可以预览效果了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011041" alt="image"></p><p>至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。</p><h2 id="注册-Github"><a href="#注册-Github" class="headerlink" title="注册 Github"></a>注册 Github</h2><p>首先如果你还没有 Github 账号的先<a href="https://github.com/" target="_blank" rel="noopener">注册</a>一个，具体过程如下</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011044" alt="image"></p><p>点击 Start project 或者下面的 new repository 创建一个新的仓库</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011052" alt="image"></p><p>注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011055" alt="image"></p><p>然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World.</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011058" alt="image"><br><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011100" alt="image"></p><p>这个时候打开 <a href="http://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">http://你的用户名.github.io</a> 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 <a href="http://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">http://你的用户名.github.io</a> 看到你自己的博客啦！ 比如我的就是 <a href="http://webw3c.github.io/" target="_blank" rel="noopener">http://webw3c.github.io</a> 了。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011103" alt="image"></p><h2 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p><p>打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011105" alt="image"></p><p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>然后开始生成密钥 SSH key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;上面的邮箱&#39;</span><br></pre></td></tr></table></figure><p>按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011106" alt="image"></p><p>（此图引用自码云）</p><p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011109" alt="image"></p><p>到这还没完，还要登录 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上添加刚刚生成的SSH key，按以下步骤添加：</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011110" alt="image"></p><p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011112" alt="image"></p><h2 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h2><p>此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的<a href="https://hexo.io/zh-cn/docs/deployment" target="_blank" rel="noopener">部署</a>教程。<br>先不着急，部署之前还需要修改配置和安装部署插件。<br>第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011114" alt="image"></p><p>第二：要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>稍等一会，在浏览器访问网址： <a href="https://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">https://你的用户名.github.io</a> 就会看到你的博客啦！！</p><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> 官网。<br>新建文章，输入以下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#39;文章标题&#39;</span><br></pre></td></tr></table></figure><p>执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。</p><p>在 Markdown 文章里面输入你的文章内容</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011117" alt="image"></p><p>再执行一下以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>就可以看到你的文章在博客显示了，以下就是刚刚</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011119" alt="image"></p><p>最后，只要部署到你的 Github 上就可以了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="静态图床"><a href="#静态图床" class="headerlink" title="静态图床"></a>静态图床</h2><p>文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是<a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules" target="_blank" rel="noopener">测试域名</a>不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。</p><p>可以去chrome网上应用商店下载一个叫<a href="https://chrome.google.com/webstore/detail/微博图床/pinjkilghdfhnkibhcangnpmcpdpmehk?hl=zh-CN" target="_blank" rel="noopener">微博图床</a>的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011122" alt="image"></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>你可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题页</a>或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官网使用文档</a>说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。</p><h3 id="一、添加评论系统"><a href="#一、添加评论系统" class="headerlink" title="一、添加评论系统"></a><strong>一、添加评论系统</strong></h3><p><strong><em>注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置\</em></strong></p><p>添加 <a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a> 评论系统，打开 /themes/next/_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011125" alt="image"></p><p>然后到 leanCloud <a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">登录</a>或者<a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册</a> 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011127" alt="image"></p><h3 id="二、配置腾讯公益404页面"><a href="#二、配置腾讯公益404页面" class="headerlink" title="二、配置腾讯公益404页面"></a><strong>二、配置腾讯公益404页面</strong></h3><ol><li>在博客根目录 /source 文件夹下创建404.html（具体内容见下图及代码）；</li><li>在 html 上方加入上面3行代码；</li></ol><p>腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011129" alt="image"></p><p>上图最前面的那几行也要加进去哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">title: &quot;404&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这里放一下上面用到的几个js链接，来自腾讯公益404官方<a href="https://www.qq.com/404/" target="_blank" rel="noopener">接入文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;plain&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;https:&#x2F;&#x2F;pojian.xyz&quot; homePageName&#x3D;&quot;回到我的博客主页&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;data.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;page.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>你也可以直接复制我 Github 上的<a href="https://github.com/webw3c/webw3c.github.io/blob/master/404.html" target="_blank" rel="noopener">404页面代码</a>，以下是我博客的预览效果。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011131" alt="image"></p><p>另外如果需要自定义个性化404页面的只要删除相应腾讯的JS，直接修改上面的 404.html 文件就可以了。</p><h3 id="三、添加字数统计和阅读时长"><a href="#三、添加字数统计和阅读时长" class="headerlink" title="三、添加字数统计和阅读时长"></a><strong>三、添加字数统计和阅读时长</strong></h3><p>首先安装一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>接着博客根目录下的配置文件里添加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文章字数统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure><p>最后到 next 主题的配置文件下开启 symbols_count_time 字段</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011133" alt="image"></p><p>重启一下 hexo 就可以看到效果啦</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011135" alt="image"></p><h3 id="四、开启fancybox"><a href="#四、开启fancybox" class="headerlink" title="四、开启fancybox"></a><strong>四、开启fancybox</strong></h3><p>打开主题配置文件搜索 fancybox 设置为 true，另外，vendors 填上对应 CDN 地址即可开启</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011137" alt="image"></p><h3 id="五、文章分享"><a href="#五、文章分享" class="headerlink" title="五、文章分享"></a><strong>五、文章分享</strong></h3><p>百度分享有个 https 的坑，按网上的方法把文件放到自己的服务器是我以前在其他的网站上测试过是能使用的，但在 hexo 中却报错了，具体不清楚是什么原因，感觉可能是 hexo 版本的问题，因为有的人可以，有的人报和我一样的错误，忘记截图了。因为这个功能也没有十分需要，就不继续爬了。换了 <a href="https://github.com/overtrue/share.js" target="_blank" rel="noopener">share.js</a> 实现了同样的功能，具体可以看本文文末的效果。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>如果你感觉直接使用 github.io 的域名作为你的博客链接不够专业，不够程序员的话那么就购买一个域名解析绑定到你的博客，我也比较建议这样做。<br>我的是在阿里万网<a href="https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.17.365b4f157s4Od7" target="_blank" rel="noopener">注册</a>的，注册流程比较常规这里就不多详述了，</p><p>注册登录控制台后找到你的域名，点右侧的解析按钮进去解析列表</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011140" alt="image"><br><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011142" alt="image"></p><p>点右边的“添加记录”添加两条 CNAME 类型的记录，如上图，后面的记录值就填写你们自己的 Github 地址哈</p><p>记录添加完后就要到 <a href="https://www.github.com/" target="_blank" rel="noopener">Github</a> 设置绑定你购买的域名了，进入你的博客仓库点 Setting，然后拉到 GitHub Pages 那里填上你的申请购买的域名保存就可以了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011144" alt="image"><br><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011145" alt="image"></p><p>这里说下，当你点击保存的时候 Github Pages 会自动帮你生成一个 CNAME 的文件在根目录，里面的内容就是你绑定的域名地址</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011148" alt="image"></p><p>注意，如果是按上面的方法操作还会有一点小问题，就是当你执行 hexo d 部署你本地的文章到 Github 时，你本地的文件会全部覆盖掉你现有仓库上的所有内容，包括 Github Pages 帮你创建的那个 CNAME 文件，这样的话当你访问域名的时候又会访问不到了。所以呢，你需要自己手动在本地根目录 /source 目录下手动创建一个 CNAME 文件，内容就是你的域名地址，因为 source 目录下的文件部署的时候是不会被删除的，所以部署的时候也会一起被部署上去，最后还需要重新到你仓库 Setting，拉到 GitHub Pages 那里再一次绑定你的域名，这样以后就没问题了。</p><p>稍等一会就可以用你申请的域名就访问你的博客了！</p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>接下来说下百度收录，据说 Github 屏蔽了百度的蜘蛛，也有的人说没，具体不是很清楚，Github 在2015的时候遭受了史上最大规模的DDoS攻击，有国外媒体指百度干的，具体不得而知啦，但感觉百度收录 Github 确认是比较难，时间也比较长，所以还是优化一下吧。</p><h3 id="一、代码同时部署到-coding"><a href="#一、代码同时部署到-coding" class="headerlink" title="一、代码同时部署到 coding"></a>一、代码同时部署到 coding</h3><p>那有什么方法呢？就是把博客站点同时托管在国内的 coding 平台上，这样收录就会容易很多，同时又不影响 Github 上的代码，<a href="https://coding.net/" target="_blank" rel="noopener">coding</a> 是国内的一个提供代码托管服务的平台，跟 Github 差不多。使用方法也和 Github 差不多，下面我就具体说一下怎么把代码同时部署到 coding 和 Github 上面，让百度更容易收录。</p><p><a href="https://coding.net/register" target="_blank" rel="noopener">注册</a>、<a href="https://coding.net/login" target="_blank" rel="noopener">登录</a> coding 后创建一个新的仓库，注意点就是新建项目的时候命名规则和 Github 上的一样，就是 <strong>用户名.coding.me</strong> 可以看下图，还有记得别忘了添加 SSH key</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011150" alt="image"></p><p>仓库建好后进入仓库，选左侧的 Page 服务，在设置中绑定新的域名，输入后点击绑定就可以了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011152" alt="image"></p><p>接着到你的域名解析控制台修改添加两条 CNAME 记录指向你的 Page 地址，看下图，注意看记录值哦，换成你自己的。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011155" alt="image"></p><p>最后呢修改根目录下的 _config.yml 配置文件中的部署配置，把 coding 的 git 地址添加进去就行了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011156" alt="image"></p><p>最后执行部署命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>这时就可以在 coding 仓库中看到你提交部署的代码了，同时 你的用户名.coding.me 也可以访问你的博客站点了，这里 Github 和 coding 的代码是同时更新的，互不影响。而绑定的域名解析可能需要稍等一会才会生效。</p><h3 id="二、百度提交链接"><a href="#二、百度提交链接" class="headerlink" title="二、百度提交链接"></a>二、百度提交链接</h3><p>部署到 coding 后也不是百度就可以收录的，我们还需要继续优化。如果在百度搜索输入 site:你的域名 如果出现以下的效果证明就是网站还没被百度收录的，我们现在点下面的<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">提交网址</a>，进入百度站长工具提交。</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011159" alt="image"></p><h3 id="三、百度站长平台添加网站管理"><a href="#三、百度站长平台添加网站管理" class="headerlink" title="三、百度站长平台添加网站管理"></a>三、百度站长平台添加网站管理</h3><p>注册<a href="https://ziyuan.baidu.com/site/" target="_blank" rel="noopener">百度站长</a>工具，并添加网站</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011201" alt="image"></p><p>添加网站的过程有三步，主要操作集中在最后一步的网站验证方式里，我选择的是 HTML标签验证，按下面使用方法添加代码到你的网站即可</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011203" alt="image"></p><p>而使用 next 主题的同学可以直接在主题的配置文件下搜索 baidu_site_verification 后面填上第三步中 meta 标签中 content 的值就可以</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011205" alt="image"></p><p>最后点完成验证就可以通过了。</p><h3 id="四、添加sitemap站点地图"><a href="#四、添加sitemap站点地图" class="headerlink" title="四、添加sitemap站点地图"></a>四、添加sitemap站点地图</h3><p>站点地图包含了你网站上的站点链接，方便搜索引擎蜘蛛的抓取工作，搜索蜘蛛会通过网站地图中链接的深层次爬行，抓取新的内容。所以我们要生成 sitemap 文件助于网站优化，安装生成插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>接着在博客根目录下的配置文件里添加对应配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>注意缩进，要不会编译报错</p><p>还要修改一个根目录配置文件下的URL，url 一项的值改成你在百度站长平台里面添加的自己站点的地址，这样生成的 sitemap.xml 文件里的 url 才是你站点的地址，看下图</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011208" alt="image"></p><h3 id="五、添加蜘蛛协议robots-txt"><a href="#五、添加蜘蛛协议robots-txt" class="headerlink" title="五、添加蜘蛛协议robots.txt"></a>五、添加蜘蛛协议robots.txt</h3><p>增加 robots.txt 文件，就是蜘蛛协议，新建 robots.txt 文件添加以下内容，把 robots.txt 放在 /source 文件下，我们前面说过 /source 目录下的文件是会被打包上传的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;pojian.xyz&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;pojian.xyz&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><p>Allow后面的就是你的menu，还有最下面的 Sitemap 地址请自行改成你们自己的地址</p><p>完成后，重启hexo，执行 hexo g -d 重新生成文件并提交后，在public目录下会生成对应的xml文件。可以通过 <a href="http://xxx.com/sitemap.xml" target="_blank" rel="noopener">http://xxx.com/sitemap.xml</a> 和 <a href="http://xxx.com/baidusitemap.xml" target="_blank" rel="noopener">http://xxx.com/baidusitemap.xml</a> 访问到 sitemap 文件，通过 <a href="http://xxx.com/robots.txt" target="_blank" rel="noopener">http://xxx.com/robots.txt</a> 访问到 robots.txt 文件。</p><p>可以到百度站长检测一下 robots.txt 文件是否生效</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011210" alt="image"></p><h3 id="六、自动推送"><a href="#六、自动推送" class="headerlink" title="六、自动推送"></a>六、自动推送</h3><p>百度有自动推送、主动推送、sitemap、手动提交几种方式。<br>自动推送是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。怎么安装呢？<br>如果你的是 next 主题，只要打开主题配置文件搜索找到 baidu_push 设置为 true 即可</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011213" alt="image"></p><p>如果你使用的不是 next 主题，也可以手动把以下代码粘贴到你的站点，一般放在 head 头部公共文件里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="七、主动推送"><a href="#七、主动推送" class="headerlink" title="七、主动推送"></a>七、主动推送</h3><p>这里利用一个第三方插件 <a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">hexo-baidu-url-submit</a> 进行主动推送<br>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>添加想关配置到根目录下的配置文件里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 百度链接提交-主动推送配置</span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3 ## 提交最新的一个链接</span><br><span class="line">  host: pojian.xyz ## 在百度站长平台中注册的域名</span><br><span class="line">  token: 3GIEYsuq5ZTkvDBm ## 请注意这是您的秘钥，所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><p>添加新的部署配置，注意这里跟之前有点不一样，要在 type 前添加一个破折号 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      github: https:&#x2F;&#x2F;github.com&#x2F;webw3c&#x2F;webw3c.github.io.git</span><br><span class="line">      coding: https:&#x2F;&#x2F;git.dev.tencent.com&#x2F;yusting&#x2F;yusting.coding.me.git</span><br><span class="line">  - type: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>最后，执行 hexo deploy 的时候，新的连接就会被推送了。<br><strong>实现原理</strong><br>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接<br>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</p><h3 id="八、手动推送"><a href="#八、手动推送" class="headerlink" title="八、手动推送"></a>八、手动推送</h3><p>就是直接直接把你需要提交的链接直接使用手动的方式填写提交就可以。</p><p>最后你可以看到是否已经被百度成功收录了</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011216" alt="image"></p><p>如果抓取成功了就证明已经被收录了，好像一般不会这么快，我的等了两天左右才抓取得到。</p><h3 id="九、添加百度统计"><a href="#九、添加百度统计" class="headerlink" title="九、添加百度统计"></a>九、添加百度统计</h3><p>添加<a href="https://tongji.baidu.com/web/homepage/index" target="_blank" rel="noopener">百度统计</a>就可以查看你网站相关的一些数据，便于你自己的站点</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011221" alt="image"></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725011218" alt="image"></p><h2 id="多端同步写作"><a href="#多端同步写作" class="headerlink" title="多端同步写作"></a>多端同步写作</h2><p>原理就是利用 Git 的分支功能，比如新建立一个 blog 分支来存放 Hexo 的源文件，而 master 分支则用来放编译后的静态文件，这样在使用另外一台电脑编写的时候只要把 blog 分支拉取下来然后进行写作再 push 到分支就可以了。具体内容或者步骤后续会有更新。。。</p><h2 id="手机编写"><a href="#手机编写" class="headerlink" title="手机编写"></a>手机编写</h2><p>网上好像找不到什么资料，不过通过在手机端安装 SSH 客户端远程操作服务器端，安装配置 node / git / hexo 环境编写应该可以的，原理同多台电脑编写差不多，不过这样做不太省心，不折腾了哈。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章到这差不多啦！后续有些小点深入学习后还是会保持更新的，希望文章对曾经像我一样的小白有那么一点帮助，技术有限，难免有纰漏，欢迎指正批评和讨论，感谢阅读！:-)</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/4f8b0717.html">http://dynais.xyz/posts/4f8b0717.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000017986794&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前往原文&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。&lt;/p&gt;
&lt;p&gt;这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。&lt;/p&gt;
&lt;p&gt;下面就开始吧~&lt;/p&gt;
&lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;p&gt;准备 node 和 git 环境，&lt;br&gt;首先，安装 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NodeJS&lt;/a&gt;，因为 &lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。&lt;br&gt;然后，安装 &lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git&lt;/a&gt;，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git&lt;/a&gt; 教程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="my-blog" scheme="http://dynais.xyz/categories/project/my-blog/"/>
    
    
      <category term="web" scheme="http://dynais.xyz/tags/web/"/>
    
      <category term="hexo" scheme="http://dynais.xyz/tags/hexo/"/>
    
      <category term="github-page" scheme="http://dynais.xyz/tags/github-page/"/>
    
  </entry>
  
  <entry>
    <title>使用差分散列的重复图片检测</title>
    <link href="http://dynais.xyz/posts/a33aff37.html"/>
    <id>http://dynais.xyz/posts/a33aff37.html</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-08-10T15:35:39.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning"><a href="#Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning" class="headerlink" title="Detect and remove duplicate images from a dataset for deep learning"></a>Detect and remove duplicate images from a dataset for deep learning</h2><!-- toc --><blockquote><p>文章链接:</p><p><a href="https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/</a></p><p><a href="https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb" target="_blank" rel="noopener">https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb</a></p><p>前言: </p><p>为什么要删去数据集中重复的图片?</p><p><em>Having duplicate images in your dataset creates a problem for two reasons:</em></p><ol><li><em>It introduces bias into your dataset, giving your deep neural network additional opportunities to learn patterns specific to the duplicates</em></li><li><em>It hurts the ability of your model to generalize to new images outside of what it was trained on</em></li></ol><p><em>Take the time to remove duplicates from your image dataset so you don’t accidentally introduce bias or hurt the ability of your model to generalize.</em></p></blockquote><a id="more"></a><h2 id="一-关于图像散列值"><a href="#一-关于图像散列值" class="headerlink" title="一. 关于图像散列值"></a>一. 关于图像散列值</h2><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010512.png" alt="img" style="zoom: 67%;" /></p><p>关于散列(Hash), 网上的介绍有很多,这里就不费力介绍.</p><p>而对于这个具体的项目要求来说, 我们所做的只是需要把一个图像转换为一个Hash值, 然后储存到字典中. 并且有一下要求:</p><ul><li>视觉上相差不大的图片, 他们的Hash值也应该相同</li><li>这个Hash计算需要快, 因为有时候数据量会很大</li></ul><p>那么我们有以下几个Hash函数的选择:</p><ul><li><strong>差分散列(<em>difference hashing</em>)</strong></li><li><strong>md5</strong></li><li><strong>sha-1</strong></li></ul><p>最终我们选择了<strong>差分散列</strong>的方法, 有以下的原因:</p><ol><li>差分散列速度很快, 计算量小</li><li>对于肉眼相差不大的图片, 差分散列可以得出相似的值</li><li>md5 和 sha-1 只要有一点变化, 输出值就会完全改变(这本来很好, 但在这里非常不好!)</li></ol><h2 id="二-我们所需的步骤"><a href="#二-我们所需的步骤" class="headerlink" title="二. 我们所需的步骤"></a>二. 我们所需的步骤</h2><h3 id="1-Convert-to-grayscale-转灰度"><a href="#1-Convert-to-grayscale-转灰度" class="headerlink" title="1. Convert to grayscale 转灰度"></a>1. Convert to grayscale 转灰度</h3><p>在这里, 颜色信息对于判定两张图是否相同其实并不是很重要, 所以将三通道转为一个通道可以很好的减少我们的工作量</p><h3 id="2-Resize-忽略长宽比缩放"><a href="#2-Resize-忽略长宽比缩放" class="headerlink" title="2. Resize 忽略长宽比缩放"></a>2. Resize 忽略长宽比缩放</h3><p>这是为了得到一个合适的大小, 以便符合后续的Hash计算, 所有需要保证所有的图片具有相同的大小尺寸, 这牵扯到差分散列的工作原理, 这会在后面解释</p><p>在这里, 我们需要将原图缩放到只有$ 9 * 8 $大小</p><h3 id="3-Compute-the-difference-计算差分-梯度"><a href="#3-Compute-the-difference-计算差分-梯度" class="headerlink" title="3. Compute the difference 计算差分(梯度)"></a>3. Compute the difference 计算差分(梯度)</h3><p>差分散列算法, 故名思与需要计算差分信息, 在图片里, 指的就是相邻像素之间的梯度.</p><p>好了, 这就是之前我们为什么需要 $ 9 * 8 $ 像素的原因了</p><p>因为我们需要得到的是一个64位的二进制信息, 而 $8 * 8=64$ , 由于是计算差分(梯度), 所以必然需要九行</p><p><strong>需要注意:</strong> 这里虽然说是差分, 但实际上使用的是非常简化的版本: 但前一个像素大于后一个像素时, 给出一个$1$, 否则, 给出一个$0$, 也就是说, 可以看作只提取梯度的正负符号信息, 公式为 </p><p>​                                                $P[x] &gt; P[x + 1] = 1 else 0$</p><p>那么现在我们得到了一个64bit的值, 接下来就对他进行Hash计算</p><h3 id="4-Build-the-hash-计算散列值"><a href="#4-Build-the-hash-计算散列值" class="headerlink" title="4. Build the hash 计算散列值"></a>4. Build the hash 计算散列值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dhash</span><span class="params">(image, hashSize=<span class="number">8</span>)</span>:</span></span><br><span class="line"><span class="comment"># convert the image to grayscale and resize the grayscale image,</span></span><br><span class="line"><span class="comment"># adding a single column (width) so we can compute the horizontal</span></span><br><span class="line"><span class="comment"># gradient</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">resized = cv2.resize(gray, (hashSize + <span class="number">1</span>, hashSize))</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute the (relative) horizontal gradient between adjacent</span></span><br><span class="line"><span class="comment"># column pixels</span></span><br><span class="line">diff = resized[:, <span class="number">1</span>:] &gt; resized[:, :<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert the difference image to a hash and return it</span></span><br><span class="line"><span class="keyword">return</span> sum([<span class="number">2</span> ** i <span class="keyword">for</span> (i, v) <span class="keyword">in</span> enumerate(diff.flatten()) <span class="keyword">if</span> v])</span><br></pre></td></tr></table></figure><h3 id="5-初始化字典-寻找重复并输出"><a href="#5-初始化字典-寻找重复并输出" class="headerlink" title="5. 初始化字典, 寻找重复并输出"></a>5. 初始化字典, 寻找重复并输出</h3><p>略</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/a33aff37.html">http://dynais.xyz/posts/a33aff37.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning&quot;&gt;&lt;a href=&quot;#Detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning&quot; class=&quot;headerlink&quot; title=&quot;Detect and remove duplicate images from a dataset for deep learning&quot;&gt;&lt;/a&gt;Detect and remove duplicate images from a dataset for deep learning&lt;/h2&gt;&lt;!-- toc --&gt;
&lt;blockquote&gt;
&lt;p&gt;文章链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前言: &lt;/p&gt;
&lt;p&gt;为什么要删去数据集中重复的图片?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Having duplicate images in your dataset creates a problem for two reasons:&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;It introduces bias into your dataset, giving your deep neural network additional opportunities to learn patterns specific to the duplicates&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;It hurts the ability of your model to generalize to new images outside of what it was trained on&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Take the time to remove duplicates from your image dataset so you don’t accidentally introduce bias or hurt the ability of your model to generalize.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv-py" scheme="http://dynais.xyz/categories/note/open-cv-py/"/>
    
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="python" scheme="http://dynais.xyz/tags/python/"/>
    
      <category term="open-cv-py" scheme="http://dynais.xyz/tags/open-cv-py/"/>
    
  </entry>
  
  <entry>
    <title>重构完成, 焕发新生</title>
    <link href="http://dynais.xyz/posts/237b1f9f.html"/>
    <id>http://dynais.xyz/posts/237b1f9f.html</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-07-24T16:50:57.237Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li><p>重构了代码</p></li><li><p>修正了大部分bug</p></li></ul><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-Qtimer"><a href="#1-Qtimer" class="headerlink" title="1. Qtimer"></a>1. Qtimer</h3><blockquote><p><a href="https://blog.csdn.net/jia666666/article/details/81672344" target="_blank" rel="noopener">https://blog.csdn.net/jia666666/article/details/81672344</a></p></blockquote><p>Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式</p><h5 id="多次触发"><a href="#多次触发" class="headerlink" title="多次触发"></a>多次触发</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer.timeout.connect(function)</span><br><span class="line">...</span><br><span class="line">timer = Qtimer()</span><br><span class="line">timer.start(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这里<code>timeout</code>是Qtimer的中断信号, 这里设定<code>timer.start(1000)</code>代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块</p><a id="more"></a><p>如果要停止Qtimer,使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer.stop()</span><br></pre></td></tr></table></figure><h3 id="2-自定义信号"><a href="#2-自定义信号" class="headerlink" title="2. 自定义信号"></a>2. 自定义信号</h3><blockquote><p> <a href="https://blog.csdn.net/foreveronly/article/details/82453697" target="_blank" rel="noopener">https://blog.csdn.net/foreveronly/article/details/82453697</a></p></blockquote><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>加完Qtimer中断完全没有问题</p><h3 id="3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug"><a href="#3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug" class="headerlink" title="3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug"></a>3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug</h3><p>通过将子窗口变为主窗口类的成员, 并使用以下语句初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment">#子窗口建立</span></span><br><span class="line">        self.subBreak = BreakWindow(self)<span class="comment"># 注意这里</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreakWindow</span><span class="params">(QDialog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,parent=None)</span>:</span></span><br><span class="line">        super().__init__(parent)</span><br></pre></td></tr></table></figure><p>关键也就是加入<code>def __init__(self,parent=None)</code>, 使主从窗口关联起来(具体实现逻辑尚不清晰), 再加上合理的退出判断, 就可以实现干净的退出了</p><p>响铃bug加完Qtimer中断完后全没有问题</p><h3 id="4-占用cpu过高问题"><a href="#4-占用cpu过高问题" class="headerlink" title="4. 占用cpu过高问题"></a>4. 占用cpu过高问题</h3><p>加完Qtimer中断完全没有问题</p><h3 id="5-交互逻辑混乱问题"><a href="#5-交互逻辑混乱问题" class="headerlink" title="5. 交互逻辑混乱问题"></a>5. 交互逻辑混乱问题</h3><p>通过重构代码逻辑解决了, 现在所有的子窗口都是主窗口的成员了</p><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#1-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="1. Qt里写了中文uic()命令就无法成功执行的问题"></a>1. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>暂时没有思路</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><h3 id="1-实现使用时间的统计模块-尝试使用Mysql来储存数据"><a href="#1-实现使用时间的统计模块-尝试使用Mysql来储存数据" class="headerlink" title="1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据?"></a>1. 实现使用时间的统计模块, 尝试使用Mysql来储存数据?</h3><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>再此理解了那句话, 不能让程序假死, 比如之前我想要time.sleep()来实现…</p><p>正确使用中断是很重要的, 这方面还要多加练习</p><p>并且另外很重要的一点就是, 使用一个库里现成的东西往往整个的整合度会更好</p><p>本来甚至都准备上多线程了…</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/237b1f9f.html">http://dynais.xyz/posts/237b1f9f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重构了代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修正了大部分bug&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-重要代码模块&quot;&gt;&lt;a href=&quot;#一-重要代码模块&quot; class=&quot;headerlink&quot; title=&quot;一. 重要代码模块&quot;&gt;&lt;/a&gt;一. 重要代码模块&lt;/h2&gt;&lt;h3 id=&quot;1-Qtimer&quot;&gt;&lt;a href=&quot;#1-Qtimer&quot; class=&quot;headerlink&quot; title=&quot;1. Qtimer&quot;&gt;&lt;/a&gt;1. Qtimer&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jia666666/article/details/81672344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jia666666/article/details/81672344&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Qtimer是Qt自带的定时器类, 位于PyQt5.Qcore下, 和单片机的中断函数非常像, 并且提供单次触发和多次触发两种触发方式&lt;/p&gt;
&lt;h5 id=&quot;多次触发&quot;&gt;&lt;a href=&quot;#多次触发&quot; class=&quot;headerlink&quot; title=&quot;多次触发&quot;&gt;&lt;/a&gt;多次触发&lt;/h5&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;timer.timeout.connect(function)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer = Qtimer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer.start(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;timeout&lt;/code&gt;是Qtimer的中断信号, 这里设定&lt;code&gt;timer.start(1000)&lt;/code&gt;代表每一秒执行一次中断, 在番茄钟里, 我使用这个中断来进行时间的更新, 时间的更新仍然使用的是原生的time模块&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>又不是不能用, 番茄钟基本功能建设完毕</title>
    <link href="http://dynais.xyz/posts/f3590d7f.html"/>
    <id>http://dynais.xyz/posts/f3590d7f.html</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2020-07-24T17:08:57.017Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li>加入了自己指定时间的模块</li></ul><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010843.png" alt="image-20200412153655534" style="zoom:50%;" /></p><ul><li>加入保存用户设置的文件<code>config.json</code></li><li>在倒计时结束时发出铃声通知</li><li>完善了除统计和To Do List外的Menu界面</li></ul><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010845.png" alt="image-20200412153753123" style="zoom:50%;" /></p><ul><li>修正了部分bug</li></ul><a id="more"></a><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-打包程序成exe文件"><a href="#1-打包程序成exe文件" class="headerlink" title="1. 打包程序成exe文件"></a>1. 打包程序成exe文件</h3><h5 id="pyInstaller模块"><a href="#pyInstaller模块" class="headerlink" title="pyInstaller模块"></a>pyInstaller模块</h5><p><code>pyInstaller</code>是python的一个库, 使用它可以很方便的打包文件成为exe可执行文件</p><p>要使用这个库, 首先在Pycharm里安装相应的环境, 之后新建一个.py文件, 比如我的:</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010847.png" alt="image-20200412160718129"></p><p>在里面输入代码(以这次工程为例):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> PyInstaller.__main__ <span class="keyword">import</span> run</span><br><span class="line">    opts=[<span class="string">'main.py'</span>,<span class="string">'-w'</span>,<span class="string">'-F'</span>,<span class="string">'--icon=image/tomato.ico'</span>]</span><br><span class="line">    run(opts)</span><br></pre></td></tr></table></figure><p>其中主要注意<code>opts=[&#39;main.py&#39;,&#39;-w&#39;,&#39;-F&#39;,&#39;--icon=image/tomato.ico&#39;]</code>这一句</p><p><code>main.py</code>是主文件, 是进程的入口</p><p><code>-w</code>这个参数使编译出来的文件时<code>exe</code>+<code>文件</code>的形式, 去掉这个参数编译出来是一个整体的<code>exe</code>文件</p><p><code>-F</code>参数强制编译, 也就是说本次会覆盖上次的文件, 我觉得加上比较好</p><p>最后<code>--icon=image/tomato.ico</code>是我指定的exe文件图标, 需要是一个<code>ico</code>文件</p><p>直接运行<code>.py</code>脚本就可以在<code>/dist</code>里得到编译的文件</p><h5 id="资源文件夹问题"><a href="#资源文件夹问题" class="headerlink" title="资源文件夹问题"></a>资源文件夹问题</h5><p>本次制作番茄钟使用到的资源文件, 比如配置文件, 或者是<code>.MP3</code>的铃声文件, pyInstaller在编译的时候都是不会编译的, 也就是说需要自己将文件复制到产生出来的目录下, 不然程序会报错无法运行</p><h3 id="2-读取和写入配置文件"><a href="#2-读取和写入配置文件" class="headerlink" title="2. 读取和写入配置文件"></a>2. 读取和写入配置文件</h3><h5 id="使用Json作为配置文件"><a href="#使用Json作为配置文件" class="headerlink" title="使用Json作为配置文件"></a>使用Json作为配置文件</h5><p>Json是一种常见的语言, 其中一种用法就是作为书写配置文件的语言, 虽然有人说它不适合作为配置文件语言, 但是小项目用用还是没有问题的</p><p>Json配置文件以<code>{</code>开头, 以<code>}</code>结束, 大括号在Json里代表一个对象, 具有一个键与一个值, 用<code>:</code>对应,</p><p>可以理解为Python里的字典(其实就是)</p><p>用Python的语法来看Json没有一点问题</p><p>如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"tomato"</span>: &#123;<span class="attr">"t_target"</span>: <span class="string">"00:05"</span>, <span class="attr">"t_break"</span>: <span class="string">"00:05"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是Json对语法的要求非常严格, 并且不可以有注释</p><h5 id="Python3读取Json文件"><a href="#Python3读取Json文件" class="headerlink" title="Python3读取Json文件"></a>Python3读取Json文件</h5><p>Python官方内置了Json的使用库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设config是一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Json读取</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"config.json"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> c:</span><br><span class="line">    config = json.load(c)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Json写入</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"config.json"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> c:</span><br><span class="line">    json.dump(config, c)</span><br></pre></td></tr></table></figure><p>读取文件以字典形式展现, 写入的变量也需要是一个字典</p><h3 id="3-在对象方法定义里直接调用具体的实例"><a href="#3-在对象方法定义里直接调用具体的实例" class="headerlink" title="3. 在对象方法定义里直接调用具体的实例"></a>3. 在对象方法定义里直接调用具体的实例</h3><p>发现在对象的方法定义里, 可以直接调用看起来还没有定义的实例, 比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">BreakWindow</span><span class="params">(QtWidgets.QDialog)</span>:</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_a_new_tomato</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        window.start_a_tomato()</span><br></pre></td></tr></table></figure><p>在这里我定义了<code>BreakWindow</code>类, 方法里调用了<code>window.start_a_tomato()</code>, <code>window</code>是另一个类, 并且在后文才定义(当然是在方法调用之前)</p><h3 id="4-循环不退出-使用flag标志的重要性"><a href="#4-循环不退出-使用flag标志的重要性" class="headerlink" title="4. 循环不退出? - 使用flag标志的重要性"></a>4. 循环不退出? - 使用flag标志的重要性</h3><p>因为循环不退出而产生bug已经不知道多少次了, 以后注意在书写循环的时候一定要提前想好尽可能全的情况, 并且写好flag, 循环不在该退的时候退真的很讨厌</p><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-在Python中播放声音-音乐-playsound包"><a href="#1-在Python中播放声音-音乐-playsound包" class="headerlink" title="1. 在Python中播放声音/音乐 - playsound包"></a>1. 在Python中播放声音/音乐 - playsound包</h3><p>在环境里加入playsound包</p><p>调用使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playsound <span class="keyword">import</span> playsound</span><br><span class="line"></span><br><span class="line">playsound(<span class="string">"sound/XXXX.mp3"</span>)</span><br></pre></td></tr></table></figure><p>真的是非常简单的API了</p><p>但是缺点也是太简单了, 几乎没有其他的可操作选项了, 可以看的出来作者基本也是没有什么经验的</p><p>还有一个就是响铃的速度好像不是很快</p><h3 id="2-窗口关闭事件信号-重写closeEvent-方法"><a href="#2-窗口关闭事件信号-重写closeEvent-方法" class="headerlink" title="2. 窗口关闭事件信号 - 重写closeEvent()方法"></a>2. 窗口关闭事件信号 - 重写closeEvent()方法</h3><p>在窗口关闭时, 会执行<code>.closeEvent()</code>方法, 通过重写这个方法, 可以达到检测窗口关闭的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">event.accept()</span><br></pre></td></tr></table></figure><h3 id="3-验证窗口是否在关闭-isHidden"><a href="#3-验证窗口是否在关闭-isHidden" class="headerlink" title="3. 验证窗口是否在关闭 - isHidden()"></a>3. 验证窗口是否在关闭 - isHidden()</h3><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>暂时没有思路</p><h3 id="2-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#2-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="2. Qt里写了中文uic()命令就无法成功执行的问题"></a>2. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>暂时没有思路</p><h3 id="3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug"><a href="#3-进程无法完全退出问题-gt-window-close-效果问题-gt-响铃bug" class="headerlink" title="3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug"></a>3. 进程无法完全退出问题 -&gt; window.close()效果问题 -&gt; 响铃bug</h3><h3 id="4-占用cpu过高问题"><a href="#4-占用cpu过高问题" class="headerlink" title="4. 占用cpu过高问题"></a>4. 占用cpu过高问题</h3><p>猜测是在循环时关闭窗口导致循环还在后台运行, 没有正常退出的问题</p><p>但怎么说这个占用也太夸张了吧就算是我有个循环</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010854.png" alt="image-20200412164033369"></p><p>你一个循环凭什么吃掉我1/4个CPU啊</p><h3 id="5-交互逻辑混乱问题"><a href="#5-交互逻辑混乱问题" class="headerlink" title="5. 交互逻辑混乱问题"></a>5. 交互逻辑混乱问题</h3><p>完全是我的锅, 因为各种小bug, 以及前期准备不足, 经验不到位, 结果使得各种循环判断, 各种地方交错调用, 命名没规范之类…</p><p>导致出现大问题无从下手, 如果要进一步给软件加入功能, 最起码的, 让他<strong>“能用”</strong>, 是肯定要重构代码的</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>虽然程序交互有很大进步, 但还是可以看出我的经验不足, 前期准备缺乏, 导致结构混乱, 后期出现Bug无从下手</p><p>经过这次教训, 我知道了前期纸上的准备和写代码同样重要, 写代码和我整理电脑一样, 都不可以把东西随意乱放, 不然图一时之快只会给以后的自己带来麻烦</p><p>虽然标题上写着<strong>“又不是不能用”</strong>, 但CPU占用如此之高, 进程无法干净退出, 无故响铃的软件, 确实就是<strong>“不能用”</strong>的</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/f3590d7f.html">http://dynais.xyz/posts/f3590d7f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;加入了自己指定时间的模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010843.png&quot; alt=&quot;image-20200412153655534&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加入保存用户设置的文件&lt;code&gt;config.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在倒计时结束时发出铃声通知&lt;/li&gt;
&lt;li&gt;完善了除统计和To Do List外的Menu界面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010845.png&quot; alt=&quot;image-20200412153753123&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修正了部分bug&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>番茄钟倒计时模块的基本实现</title>
    <link href="http://dynais.xyz/posts/378efd60.html"/>
    <id>http://dynais.xyz/posts/378efd60.html</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2020-07-24T17:09:32.420Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><ul><li>实现了番茄钟最基本的倒计时功能</li><li>实现了按钮交互的功能</li></ul><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010712.png" alt="image-20200409231248203" style="zoom:50%;" /></p><h2 id="一-重要代码模块"><a href="#一-重要代码模块" class="headerlink" title="一. 重要代码模块"></a>一. 重要代码模块</h2><h3 id="1-显示时间与计算时间的转换"><a href="#1-显示时间与计算时间的转换" class="headerlink" title="1. 显示时间与计算时间的转换"></a>1. 显示时间与计算时间的转换</h3><a id="more"></a><p>实现倒计时时的一个问题是: 显示的时间格式需要是”XX:XX”, 但是为了方便计算, 需要把这个格式的时间转化为秒数的形式, 这就需要一个显示时间与计算时间互相转换的模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示时间转秒数 "XX:XX" -&gt; flout</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tomato2sec</span><span class="params">(tomato)</span>:</span></span><br><span class="line">    sec = int(tomato[<span class="number">3</span>:])</span><br><span class="line">    sec = sec + <span class="number">60</span> * int(tomato[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 秒数转显示时间 flout -&gt; "XX:XX"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sec2tomato</span><span class="params">(sec)</span>:</span></span><br><span class="line">    t = []</span><br><span class="line">    t.append(str(int(sec / <span class="number">60</span>)))</span><br><span class="line">    t.append(str(int(sec % <span class="number">60</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(t)):</span><br><span class="line">        <span class="keyword">if</span> len(t[i]) &lt; <span class="number">2</span>:</span><br><span class="line">            t[i] = <span class="string">"0"</span> + t[i]</span><br><span class="line"></span><br><span class="line">    tomato = <span class="string">":"</span>.join(t)</span><br><span class="line">    <span class="keyword">return</span> tomato</span><br></pre></td></tr></table></figure><h3 id="2-获取系统时间"><a href="#2-获取系统时间" class="headerlink" title="2. 获取系统时间"></a>2. 获取系统时间</h3><p>获取系统时间在python里我使用的是time包, 还有一个相似的是datetime.time包, 注意不要搞混了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure><p>倒计时的基本思路是点击开始按钮时获取一个开启的系统时间, 然后用户会有一个给定的目标时间, 然后点按钮以后会进入一个循环, 知道计时结束才会退出, 在循环里面一直获取系统时间和其实时间运算就得到了已经过了多久, 再和目标时间判断就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_start &#x3D; time.time()</span><br></pre></td></tr></table></figure><p>这个语句是获取以秒数显示的当前系统时间, 用于运算会比较方便</p><h3 id="3-页面元素的交互"><a href="#3-页面元素的交互" class="headerlink" title="3. 页面元素的交互"></a>3. 页面元素的交互</h3><p>简单的页面元素交互可以在Qt里直接实现</p><p>原理基本上是, 按下按钮之类的东西, 会发出一个信号</p><p><code>ui_window.button_start.clicked</code>这个信号就是<code>ui_window</code>这个窗口下<code>button_start</code>按钮发出的点击信号, 使用<code>connect</code>绑定一个<strong>slot</strong>之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui_window.button_start.clicked.connect(start_a_tomato)</span><br></pre></td></tr></table></figure><p>在这里的意思就是: 单击这个按钮以后执行<code>start_a_tomato</code>函数, 注意函数名在这里不带括号</p><h2 id="二-已解决的问题"><a href="#二-已解决的问题" class="headerlink" title="二. 已解决的问题"></a>二. 已解决的问题</h2><h3 id="1-倒计时使用time-sleep-效果不好的问题"><a href="#1-倒计时使用time-sleep-效果不好的问题" class="headerlink" title="1. 倒计时使用time.sleep()效果不好的问题"></a>1. 倒计时使用time.sleep()效果不好的问题</h3><p>最开始的思路里, 用户点击开始后进入一个循环, 这个循环每次执行一秒, 然后让页面更新一次, 用到的函数是这个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment">#控制系统空置一秒</span></span><br></pre></td></tr></table></figure><p>但是问题就是, 和单片机上不能乱用<code>delay()</code>一样, 使用<code>sleep()</code>会使程序整个无法响应, 导致拖拽手感奇怪, 且拖拽时倒计时直接停止</p><p>然后换了思路, 直接不断读取系统时间实时刷新, 解决了拖拽手感的问题, 但拖拽时倒计时还是会停止, 不过放下窗口后时间并不会出错, 就先不管了</p><h3 id="2-改变窗口元素但窗口显示不刷新的问题"><a href="#2-改变窗口元素但窗口显示不刷新的问题" class="headerlink" title="2. 改变窗口元素但窗口显示不刷新的问题"></a>2. 改变窗口元素但窗口显示不刷新的问题</h3><p>最开始在循环里改变了元素, 但发现直到循环退出窗口才改变了显示, 但使用print输出又没什么问题, 于是想可能是窗口刷新的问题, 最后的解决办法就一条指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QtWidgets.QApplication.processEvents()</span><br></pre></td></tr></table></figure><p>让窗口刷新</p><h2 id="三-待解决的问题"><a href="#三-待解决的问题" class="headerlink" title="三. 待解决的问题"></a>三. 待解决的问题</h2><h3 id="1-拖动窗口时时间不走动的问题"><a href="#1-拖动窗口时时间不走动的问题" class="headerlink" title="1. 拖动窗口时时间不走动的问题"></a>1. 拖动窗口时时间不走动的问题</h3><p>暂时没有思路</p><h3 id="2-Qt里写了中文uic-命令就无法成功执行的问题"><a href="#2-Qt里写了中文uic-命令就无法成功执行的问题" class="headerlink" title="2. Qt里写了中文uic()命令就无法成功执行的问题"></a>2. Qt里写了中文<code>uic()</code>命令就无法成功执行的问题</h3><p>应该是编码不统一的问题, 但是改了Qt的编码几次还是不行, 暂时先用英文顶着, 看看以后有没有解决办法</p><p>暂时没有思路</p><h2 id="四-下一阶段的目标"><a href="#四-下一阶段的目标" class="headerlink" title="四. 下一阶段的目标"></a>四. 下一阶段的目标</h2><ul><li>加入自己指定时间的模块</li><li>加入保存用户设置的文件</li><li>在倒计时结束时尝试发出通知</li></ul><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/378efd60.html">http://dynais.xyz/posts/378efd60.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;项目进度&quot;&gt;&lt;a href=&quot;#项目进度&quot; class=&quot;headerlink&quot; title=&quot;项目进度&quot;&gt;&lt;/a&gt;项目进度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实现了番茄钟最基本的倒计时功能&lt;/li&gt;
&lt;li&gt;实现了按钮交互的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010712.png&quot; alt=&quot;image-20200409231248203&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-重要代码模块&quot;&gt;&lt;a href=&quot;#一-重要代码模块&quot; class=&quot;headerlink&quot; title=&quot;一. 重要代码模块&quot;&gt;&lt;/a&gt;一. 重要代码模块&lt;/h2&gt;&lt;h3 id=&quot;1-显示时间与计算时间的转换&quot;&gt;&lt;a href=&quot;#1-显示时间与计算时间的转换&quot; class=&quot;headerlink&quot; title=&quot;1. 显示时间与计算时间的转换&quot;&gt;&lt;/a&gt;1. 显示时间与计算时间的转换&lt;/h3&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python+Qt5项目环境的搭建</title>
    <link href="http://dynais.xyz/posts/6b47c0e1.html"/>
    <id>http://dynais.xyz/posts/6b47c0e1.html</id>
    <published>2020-04-07T16:00:00.000Z</published>
    <updated>2020-07-24T17:06:52.568Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="一-软件"><a href="#一-软件" class="headerlink" title="一. 软件"></a>一. 软件</h2><h3 id="1-Pycharm-2019-3-3"><a href="#1-Pycharm-2019-3-3" class="headerlink" title="1. Pycharm 2019.3.3"></a>1. Pycharm 2019.3.3</h3><p>​    Pycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成</p><h3 id="2-Qt-5-12-7-Qt-Creator"><a href="#2-Qt-5-12-7-Qt-Creator" class="headerlink" title="2. Qt 5.12.7 / Qt Creator"></a>2. Qt 5.12.7 / Qt Creator</h3><p>​    Qt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版</p><h2 id="二-环境搭建-对于已有Anaconda3"><a href="#二-环境搭建-对于已有Anaconda3" class="headerlink" title="二. 环境搭建(对于已有Anaconda3)"></a>二. 环境搭建(对于已有Anaconda3)</h2><h3 id="1-Python解释器"><a href="#1-Python解释器" class="headerlink" title="1.Python解释器"></a>1.Python解释器</h3><p>由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用</p><a id="more"></a><h3 id="2-配置环境变量-对于Anaconda3"><a href="#2-配置环境变量-对于Anaconda3" class="headerlink" title="2. 配置环境变量(对于Anaconda3)"></a>2. 配置环境变量(对于Anaconda3)</h3><p>对于Anaconda3的用户, 需要再自行配置一下环境变量, 在环境变量的<code>path</code>选项卡中添加Anaconda的以下目录</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010627.png" alt="image-20200408140342164"></p><p>不然在Pycharm中搭建环境时会遇到提示pip无法成功的提示, 导致包无法安装</p><h3 id="3-在Pycharm里搭建环境-安装必要的包"><a href="#3-在Pycharm里搭建环境-安装必要的包" class="headerlink" title="3. 在Pycharm里搭建环境/安装必要的包"></a>3. 在Pycharm里搭建环境/安装必要的包</h3><p>完成以上两步准备就可以开始配置Pycharm了</p><p>首先新建一个项目</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010630.png" alt="image-20200408140546920"></p><p>有几点需要注意的地方: </p><p><strong>首先, 确保<code>New environment using</code>中是新建了一个环境,而不是使用Conda.</strong> </p><p><strong>其次, 确保<code>Base interpreter</code>中选择的是<code>pythonw</code>解释器, 而不是<code>python</code></strong></p><p><strong>最后注意, 此处不需勾选</strong></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010633.png" alt="image-20200408141111529"></p><p>然后就可以让它新建一个项目了</p><p>打开工程后进入 <strong>文件 -&gt; 设置 -&gt; 项目 -&gt; Project Interpreter</strong> 在这里管理需要用到的包文件</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010635.png" alt="image-20200408142236868" style="zoom:50%;" /></p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010637.png" alt="image-20200408142313603" style="zoom:50%;" /></p><p>需要使用Qt编程的话, 必须添加<code>QtPy</code>和<code>PyQt5</code>两个包</p><p>Pycharm会自己管理, 下载好就算是配置完成了</p><h2 id="三-工作流"><a href="#三-工作流" class="headerlink" title="三. 工作流"></a>三. 工作流</h2><p>大致的思路是:</p><ul><li>使用Qt Creator创作图形界面</li><li>使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中</li><li>使用Pycharm编写整体逻辑</li></ul><h3 id="1-使用Qt-Creator创作图形界面"><a href="#1-使用Qt-Creator创作图形界面" class="headerlink" title="1. 使用Qt Creator创作图形界面"></a>1. 使用Qt Creator创作图形界面</h3><p>打开Qt Creator新建工程</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010641.png" alt="image-20200408142839431" style="zoom:50%;" /></p><p>注意创建时选择桌面图形应用, 这里不需要选Python的那个</p><p><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010643.png" alt="image-20200408143012126" style="zoom:50%;" /></p><p> 工程最好命名为<code>ui</code>, 保存在一个项目文件夹下</p><h3 id="2-使用包内置函数转化Qt的-ui文件为-py文件-作为包导入到程序中"><a href="#2-使用包内置函数转化Qt的-ui文件为-py文件-作为包导入到程序中" class="headerlink" title="2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中"></a>2. 使用包内置函数转化Qt的.ui文件为.py文件, 作为包导入到程序中</h3><p>在Pycharm中新建一个<code>builder.py</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qtpy <span class="keyword">import</span> uic</span><br><span class="line"></span><br><span class="line">uic.compileUiDir(<span class="string">"这里填入Qt工程的文件夹路径"</span>)</span><br></pre></td></tr></table></figure><p>运行便可以得到一个.py文件, 里面是应用程序外观的描述</p><p>在主程序py文件中写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> qtpy <span class="keyword">import</span> QtWidgets</span><br><span class="line"><span class="keyword">from</span> ui.mainwindow <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line">app = QtWidgets.QApplication(sys.argv)<span class="comment">#设置一个App</span></span><br><span class="line"></span><br><span class="line">window = QtWidgets.QMainWindow()<span class="comment">#新建一个窗口</span></span><br><span class="line">ui_window = Ui_MainWindow()<span class="comment">#新建一个导入包中窗口的类</span></span><br><span class="line">ui_window.setupUi(window)<span class="comment">#注意自己的窗口要填入括号</span></span><br><span class="line">window.setWindowTitle(<span class="string">"Tomato Clock v0"</span>)<span class="comment">#设置标题</span></span><br><span class="line"></span><br><span class="line">window.show()<span class="comment">#显示窗口</span></span><br><span class="line"></span><br><span class="line">sys.exit(app.exec_())<span class="comment">#设置退出</span></span><br></pre></td></tr></table></figure><p>设置完成</p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/6b47c0e1.html">http://dynais.xyz/posts/6b47c0e1.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h2 id=&quot;一-软件&quot;&gt;&lt;a href=&quot;#一-软件&quot; class=&quot;headerlink&quot; title=&quot;一. 软件&quot;&gt;&lt;/a&gt;一. 软件&lt;/h2&gt;&lt;h3 id=&quot;1-Pycharm-2019-3-3&quot;&gt;&lt;a href=&quot;#1-Pycharm-2019-3-3&quot; class=&quot;headerlink&quot; title=&quot;1. Pycharm 2019.3.3&quot;&gt;&lt;/a&gt;1. Pycharm 2019.3.3&lt;/h3&gt;&lt;p&gt;​    Pycharm主要负责进行主体逻辑的编写, 以及统筹整个项目, 此外环境的搭建大多也在Pycharm里完成&lt;/p&gt;
&lt;h3 id=&quot;2-Qt-5-12-7-Qt-Creator&quot;&gt;&lt;a href=&quot;#2-Qt-5-12-7-Qt-Creator&quot; class=&quot;headerlink&quot; title=&quot;2. Qt 5.12.7 / Qt Creator&quot;&gt;&lt;/a&gt;2. Qt 5.12.7 / Qt Creator&lt;/h3&gt;&lt;p&gt;​    Qt原本是为C++设计的UI界面搭建软件, 通过加入Py包之后同样也可以为Python编写桌面图形应用程序, 这里用的是官网的免费版&lt;/p&gt;
&lt;h2 id=&quot;二-环境搭建-对于已有Anaconda3&quot;&gt;&lt;a href=&quot;#二-环境搭建-对于已有Anaconda3&quot; class=&quot;headerlink&quot; title=&quot;二. 环境搭建(对于已有Anaconda3)&quot;&gt;&lt;/a&gt;二. 环境搭建(对于已有Anaconda3)&lt;/h2&gt;&lt;h3 id=&quot;1-Python解释器&quot;&gt;&lt;a href=&quot;#1-Python解释器&quot; class=&quot;headerlink&quot; title=&quot;1.Python解释器&quot;&gt;&lt;/a&gt;1.Python解释器&lt;/h3&gt;&lt;p&gt;由于已经安装了Anaconda3, 所以没有再安装原生的解释器, 也不清楚, 但觉得应该可以通用&lt;/p&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="tomato-clock" scheme="http://dynais.xyz/categories/project/tomato-clock/"/>
    
    
      <category term="Qt" scheme="http://dynais.xyz/tags/Qt/"/>
    
      <category term="Python" scheme="http://dynais.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在Markdown文件中使用Latex表示数学公式</title>
    <link href="http://dynais.xyz/posts/ae2a8b3f.html"/>
    <id>http://dynais.xyz/posts/ae2a8b3f.html</id>
    <published>2020-03-05T14:00:00.000Z</published>
    <updated>2020-07-24T17:01:10.097Z</updated>
    
    <content type="html"><![CDATA[<p> 在Markdown中插入数学公式的语法是 <code>$数学公式$</code> 和 <code>$$数学公式$$</code>.</p><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:</p><div class="table-container"><table><thead><tr><th>示例</th><th>显示</th></tr></thead><tbody><tr><td><code>$2x+3y=34$</code></td><td><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725005742.svg" alt="2x+3y=34"></td></tr><tr><td><code>2x+3y=34</code></td><td>2x+3y=34</td></tr></tbody></table></div><p>因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量<img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010108.svg" alt="x">,也要进入数学模式,使用<code>$1+1=2$</code>,<code>$x$</code>,而不是使用排版普通文字的方式</p><h2 id="独立公式"><a href="#独立公式" class="headerlink" title="独立公式"></a>独立公式</h2><p>独立公式单独占一行,不和其他文字混编</p><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><p>在独立公式中使用\\来换行<br> 示例:</p><a id="more"></a><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$   </span><br><span class="line"><span class="number">2</span>x+<span class="number">3</span>y=<span class="number">34</span>\\   </span><br><span class="line">x+<span class="number">4</span>y=<span class="number">25</span>  </span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示:<br> <img src="https://math.jianshu.com/math?formula=2x%2B3y%3D34\\ x%2B4y%3D25" alt="2x+3y=34\\ x+4y=25"></p><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>示例</th><th>显示</th></tr></thead><tbody><tr><td>上下标</td><td><code>S=a_{1}^2+a_{2}^2+a_{3}^2$</code></td><td><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725005759.svg" alt="S=a_{1}^2+a_{2}^2+a_{3}^2"></td></tr><tr><td>括号</td><td><code>$f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace$</code></td><td><img src="https://math.jianshu.com/math?formula=f(x%2C%20y" alt="f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace">%20%3D%20100%20<em>%20%5Clbrace%5B(x%20%2B%20y)%20</em>%203%5D%20-%205%5Crbrace)</td></tr><tr><td>分数</td><td><code>$\frac{1}{3} 与 \cfrac{1}{3}$</code></td><td><img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B3%7D%20%E4%B8%8E%20%5Ccfrac%7B1%7D%7B3%7D" alt="\frac{1}{3} 与 \cfrac{1}{3}"></td></tr><tr><td>开方</td><td><code>$\sqrt[3]{X}$</code>和<code>$\sqrt{5 - x}$</code></td><td><img src="D:\WorkSpace\.Typora Images Hub\math-1583415699231.svg" alt="\sqrt[3]{X}">和<img src="https://math.jianshu.com/math?formula=%5Csqrt%7B5%20-%20x%7D" alt="\sqrt{5 - x}"></td></tr></tbody></table></div><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\pm</td><td><img src="https://math.jianshu.com/math?formula=%5Cpm" alt="\pm"></td></tr><tr><td>\times</td><td><img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"></td></tr><tr><td>\div</td><td><img src="https://math.jianshu.com/math?formula=%5Cdiv" alt="\div"></td></tr><tr><td>\mid</td><td><img src="https://math.jianshu.com/math?formula=%5Cmid" alt="\mid"></td></tr><tr><td>\nmid</td><td><img src="https://math.jianshu.com/math?formula=%5Cnmid" alt="\nmid"></td></tr><tr><td>\cdot</td><td><img src="https://math.jianshu.com/math?formula=%5Ccdot" alt="\cdot"></td></tr><tr><td>\circ</td><td><img src="https://math.jianshu.com/math?formula=%5Ccirc" alt="\circ"></td></tr><tr><td>\ast</td><td><img src="https://math.jianshu.com/math?formula=%5Cast" alt="\ast"></td></tr><tr><td>\bigodot</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigodot" alt="\bigodot"></td></tr><tr><td>\bigotimes</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigotimes" alt="\bigotimes"></td></tr><tr><td>\bigoplus</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigoplus" alt="\bigoplus"></td></tr><tr><td>\leq</td><td><img src="https://math.jianshu.com/math?formula=%5Cleq" alt="\leq"></td></tr><tr><td>\geq</td><td><img src="https://math.jianshu.com/math?formula=%5Cgeq" alt="\geq"></td></tr><tr><td>\neq</td><td><img src="https://math.jianshu.com/math?formula=%5Cneq" alt="\neq"></td></tr><tr><td>\approx</td><td><img src="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx"></td></tr><tr><td>\equiv</td><td><img src="https://math.jianshu.com/math?formula=%5Cequiv" alt="\equiv"></td></tr><tr><td>\sum</td><td><img src="https://math.jianshu.com/math?formula=%5Csum" alt="\sum"></td></tr><tr><td>\prod</td><td><img src="https://math.jianshu.com/math?formula=%5Cprod" alt="\prod"></td></tr></tbody></table></div><h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\log</td><td><img src="https://math.jianshu.com/math?formula=%5Clog" alt="\log"></td></tr><tr><td>\lg</td><td><img src="https://math.jianshu.com/math?formula=%5Clg" alt="\lg"></td></tr><tr><td>\ln</td><td><img src="https://math.jianshu.com/math?formula=%5Cln" alt="\ln"></td></tr></tbody></table></div><h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\bot</td><td><img src="https://math.jianshu.com/math?formula=%5Cbot" alt="\bot"></td></tr><tr><td>\angle</td><td><img src="https://math.jianshu.com/math?formula=%5Cangle" alt="\angle"></td></tr><tr><td>\sin</td><td><img src="https://math.jianshu.com/math?formula=%5Csin" alt="\sin"></td></tr><tr><td>\cos</td><td><img src="https://math.jianshu.com/math?formula=%5Ccos" alt="\cos"></td></tr><tr><td>\tan</td><td><img src="https://math.jianshu.com/math?formula=%5Ctan" alt="\tan"></td></tr><tr><td>\cot</td><td><img src="https://math.jianshu.com/math?formula=%5Ccot" alt="\cot"></td></tr><tr><td>\sec</td><td><img src="https://math.jianshu.com/math?formula=%5Csec" alt="\sec"></td></tr><tr><td>\csc</td><td><img src="https://math.jianshu.com/math?formula=%5Ccsc" alt="\csc"></td></tr></tbody></table></div><h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\prime</td><td><img src="https://math.jianshu.com/math?formula=%5Cprime" alt="\prime"></td></tr><tr><td>\int</td><td><img src="https://math.jianshu.com/math?formula=%5Cint" alt="\int"></td></tr><tr><td>\iint</td><td><img src="https://math.jianshu.com/math?formula=%5Ciint" alt="\iint"></td></tr><tr><td>\iiint</td><td><img src="https://math.jianshu.com/math?formula=%5Ciiint" alt="\iiint"></td></tr><tr><td>\oint</td><td><img src="https://math.jianshu.com/math?formula=%5Coint" alt="\oint"></td></tr><tr><td>\lim</td><td><img src="https://math.jianshu.com/math?formula=%5Clim" alt="\lim"></td></tr><tr><td>\infty</td><td><img src="https://math.jianshu.com/math?formula=%5Cinfty" alt="\infty"></td></tr><tr><td>\nabla</td><td><img src="https://math.jianshu.com/math?formula=%5Cnabla" alt="\nabla"></td></tr><tr><td>\mathrm{d}</td><td><img src="https://math.jianshu.com/math?formula=%5Cmathrm%7Bd%7D" alt="\mathrm{d}"></td></tr></tbody></table></div><h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\emptyset</td><td><img src="https://math.jianshu.com/math?formula=%5Cemptyset" alt="\emptyset"></td></tr><tr><td>\in</td><td><img src="https://math.jianshu.com/math?formula=%5Cin" alt="\in"></td></tr><tr><td>\notin</td><td><img src="https://math.jianshu.com/math?formula=%5Cnotin" alt="\notin"></td></tr><tr><td>\subset</td><td><img src="https://math.jianshu.com/math?formula=%5Csubset" alt="\subset"></td></tr><tr><td>\subseteq</td><td><img src="https://math.jianshu.com/math?formula=%5Csubseteq" alt="\subseteq"></td></tr><tr><td>\supseteq</td><td><img src="https://math.jianshu.com/math?formula=%5Csupseteq" alt="\supseteq"></td></tr><tr><td>\bigcap</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcap" alt="\bigcap"></td></tr><tr><td>\bigcup</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigcup" alt="\bigcup"></td></tr><tr><td>\bigvee</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigvee" alt="\bigvee"></td></tr><tr><td>\bigwedge</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigwedge" alt="\bigwedge"></td></tr><tr><td>\biguplus</td><td><img src="https://math.jianshu.com/math?formula=%5Cbiguplus" alt="\biguplus"></td></tr><tr><td>\bigsqcup</td><td><img src="https://math.jianshu.com/math?formula=%5Cbigsqcup" alt="\bigsqcup"></td></tr></tbody></table></div><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container"><table><thead><tr><th>代码</th><th>大写</th><th>代码</th><th>小写</th></tr></thead><tbody><tr><td>A</td><td><img src="https://math.jianshu.com/math?formula=A" alt="A"></td><td>\alpha</td><td><img src="https://math.jianshu.com/math?formula=%5Calpha" alt="\alpha"></td></tr><tr><td>B</td><td><img src="https://math.jianshu.com/math?formula=B" alt="B"></td><td>\beta</td><td><img src="https://math.jianshu.com/math?formula=%5Cbeta" alt="\beta"></td></tr><tr><td>\Gamma</td><td><img src="https://math.jianshu.com/math?formula=%5CGamma" alt="\Gamma"></td><td>\gamma</td><td><img src="https://math.jianshu.com/math?formula=%5Cgamma" alt="\gamma"></td></tr><tr><td>\Delta</td><td><img src="https://math.jianshu.com/math?formula=%5CDelta" alt="\Delta"></td><td>\delta</td><td><img src="https://math.jianshu.com/math?formula=%5Cdelta" alt="\delta"></td></tr><tr><td>E</td><td><img src="https://math.jianshu.com/math?formula=E" alt="E"></td><td>\epsilon</td><td><img src="https://math.jianshu.com/math?formula=%5Cepsilon" alt="\epsilon"></td></tr><tr><td>Z</td><td><img src="https://math.jianshu.com/math?formula=Z" alt="Z"></td><td>\zeta</td><td><img src="https://math.jianshu.com/math?formula=%5Czeta" alt="\zeta"></td></tr><tr><td>H</td><td><img src="https://math.jianshu.com/math?formula=H" alt="H"></td><td>\eta</td><td><img src="https://math.jianshu.com/math?formula=%5Ceta" alt="\eta"></td></tr><tr><td>\Theta</td><td><img src="https://math.jianshu.com/math?formula=%5CTheta" alt="\Theta"></td><td>\theta</td><td><img src="https://math.jianshu.com/math?formula=%5Ctheta" alt="\theta"></td></tr><tr><td>I</td><td><img src="https://math.jianshu.com/math?formula=I" alt="I"></td><td>\iota</td><td><img src="https://math.jianshu.com/math?formula=%5Ciota" alt="\iota"></td></tr><tr><td>K</td><td><img src="https://math.jianshu.com/math?formula=K" alt="K"></td><td>\kappa</td><td><img src="https://math.jianshu.com/math?formula=%5Ckappa" alt="\kappa"></td></tr><tr><td>Lambda</td><td><img src="https://math.jianshu.com/math?formula=%5CLambda" alt="\Lambda"></td><td>\lambda</td><td><img src="https://math.jianshu.com/math?formula=%5Clambda" alt="\lambda"></td></tr><tr><td>M</td><td><img src="https://math.jianshu.com/math?formula=M" alt="M"></td><td>\mu</td><td><img src="https://math.jianshu.com/math?formula=%5Cmu" alt="\mu"></td></tr><tr><td>N</td><td><img src="https://math.jianshu.com/math?formula=N" alt="N"></td><td>\nu</td><td><img src="https://math.jianshu.com/math?formula=%5Cnu" alt="\nu"></td></tr><tr><td>Xi</td><td><img src="https://math.jianshu.com/math?formula=Xi" alt="Xi"></td><td>\xi</td><td><img src="https://math.jianshu.com/math?formula=%5Cxi" alt="\xi"></td></tr><tr><td>O</td><td><img src="https://math.jianshu.com/math?formula=O" alt="O"></td><td>\omicron</td><td><img src="https://math.jianshu.com/math?formula=%5Comicron" alt="\omicron"></td></tr><tr><td>\Pi</td><td><img src="https://math.jianshu.com/math?formula=%5CPi" alt="\Pi"></td><td>\pi</td><td><img src="https://math.jianshu.com/math?formula=%5Cpi" alt="\pi"></td></tr><tr><td>P</td><td><img src="https://math.jianshu.com/math?formula=P" alt="P"></td><td>\rho</td><td><img src="https://math.jianshu.com/math?formula=%5Crho" alt="\rho"></td></tr><tr><td>\Sigma</td><td><img src="https://math.jianshu.com/math?formula=%5CSigma" alt="\Sigma"></td><td>\sigma</td><td><img src="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma"></td></tr><tr><td>T</td><td><img src="https://math.jianshu.com/math?formula=T" alt="T"></td><td>\tau</td><td><img src="https://math.jianshu.com/math?formula=%5Ctau" alt="\tau"></td></tr><tr><td>\Upsilon</td><td><img src="https://math.jianshu.com/math?formula=%5CUpsilon" alt="\Upsilon"></td><td>\upsilon</td><td><img src="https://math.jianshu.com/math?formula=%5Cupsilon" alt="\upsilon"></td></tr><tr><td>\Phi</td><td><img src="https://math.jianshu.com/math?formula=%5CPhi" alt="\Phi"></td><td>\phi</td><td><img src="https://math.jianshu.com/math?formula=%5Cphi" alt="\phi"></td></tr><tr><td>X</td><td><img src="https://math.jianshu.com/math?formula=X" alt="X"></td><td>\chi</td><td><img src="https://math.jianshu.com/math?formula=%5Cchi" alt="\chi"></td></tr><tr><td>\Psi</td><td><img src="https://math.jianshu.com/math?formula=%5CPsi" alt="\Psi"></td><td>\psi</td><td><img src="https://math.jianshu.com/math?formula=%5Cpsi" alt="\psi"></td></tr><tr><td>\Omega</td><td><img src="https://math.jianshu.com/math?formula=%5COmega" alt="\Omega"></td><td>\omega</td><td><img src="https://math.jianshu.com/math?formula=%5Comega" alt="\omega"></td></tr></tbody></table></div><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/ae2a8b3f.html">http://dynais.xyz/posts/ae2a8b3f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在Markdown中插入数学公式的语法是 &lt;code&gt;$数学公式$&lt;/code&gt; 和 &lt;code&gt;$$数学公式$$&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;行内公式&quot;&gt;&lt;a href=&quot;#行内公式&quot; class=&quot;headerlink&quot; title=&quot;行内公式&quot;&gt;&lt;/a&gt;行内公式&lt;/h2&gt;&lt;p&gt;行内公式是可以让公式在文中与文字或其他东西混编，不独占一行.在数学模式下,符号会使用单独的字体,字母通常是倾斜的意大利体,数字和符号则是直立体.而且,数学符号之间的距离也与一般的水平模式不同:&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$2x+3y=34$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725005742.svg&quot; alt=&quot;2x+3y=34&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2x+3y=34&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2x+3y=34&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;因此,在排版数学公式时,即使没有特殊符号的算式如1+1=2,或者简单的一个字母变量&lt;img src=&quot;https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725010108.svg&quot; alt=&quot;x&quot;&gt;,也要进入数学模式,使用&lt;code&gt;$1+1=2$&lt;/code&gt;,&lt;code&gt;$x$&lt;/code&gt;,而不是使用排版普通文字的方式&lt;/p&gt;
&lt;h2 id=&quot;独立公式&quot;&gt;&lt;a href=&quot;#独立公式&quot; class=&quot;headerlink&quot; title=&quot;独立公式&quot;&gt;&lt;/a&gt;独立公式&lt;/h2&gt;&lt;p&gt;独立公式单独占一行,不和其他文字混编&lt;/p&gt;
&lt;h2 id=&quot;多行公式&quot;&gt;&lt;a href=&quot;#多行公式&quot; class=&quot;headerlink&quot; title=&quot;多行公式&quot;&gt;&lt;/a&gt;多行公式&lt;/h2&gt;&lt;p&gt;在独立公式中使用\\来换行&lt;br&gt; 示例:&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="latex" scheme="http://dynais.xyz/categories/note/latex/"/>
    
    
      <category term="latex" scheme="http://dynais.xyz/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记12-模板匹配</title>
    <link href="http://dynais.xyz/posts/63d72132.html"/>
    <id>http://dynais.xyz/posts/63d72132.html</id>
    <published>2020-02-19T16:00:00.000Z</published>
    <updated>2020-07-24T16:49:26.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matchTemplate();<span class="comment">//模式查找,API比较简单</span></span><br><span class="line">minMaxLoc();<span class="comment">//用于在模式查找的输出图像中找到极值点,也就是匹配点</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>模板匹配(Templet Match)</p><p>相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.</p></li></ul><ul><li><p>注意输出图像的大小</p><p>在API中需要提供一个储存输出结果的Mat, 他的大小是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size(src.cols-templ.cols+1, src.rows-templ.rows+1)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>OpenCV的查找模式</p><p>OpenCV提供了很多种方法,在官网上都有介绍,大部分都是取用了最大值作为最匹配</p><p>根据最小值匹配的只有 <strong>TM_SQDIFF</strong> 和 <strong>MT_SQDIFF_NORMED</strong></p><p><em>For the first two methods ( TM_SQDIFF and MT_SQDIFF_NORMED ) the best match are the lowest values.</em></p></li></ul><ul><li><p>OpenCV中32位的图像</p><p>每个数值是一个位于[0,1]间的小数,相当于8位的[0,255]</p></li></ul><hr><h3 id="源-API实现模式查找"><a href="#源-API实现模式查找" class="headerlink" title="源//API实现模式查找"></a>源//API实现模式查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat src, dst, temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">temp = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Lena.jpg"</span>);</span><br><span class="line">src = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Day1.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试尺度不变性</span></span><br><span class="line"><span class="comment">//pyrDown(temp, temp, Size(temp.cols / 2, temp.rows / 2));</span></span><br><span class="line">pyrUp(temp, temp, Size(temp.cols * <span class="number">2</span>, temp.rows * <span class="number">2</span>));</span><br><span class="line"><span class="comment">//pyrUp(temp, temp, Size(temp.cols * 2, temp.rows * 2));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp.empty() || src.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG... Check again!"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat result = Mat_&lt;<span class="keyword">float</span>&gt;::zeros(src.cols - temp.cols + <span class="number">1</span>, src.rows - temp.rows + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">matchTemplate(src, temp, result, TM_CCOEFF_NORMED);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; result;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> minVal; <span class="keyword">double</span> maxVal; Point minLoc; Point maxLoc;</span><br><span class="line">Point matchLoc;</span><br><span class="line">minMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, Mat());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minVal &lt;&lt; <span class="built_in">endl</span> &lt;&lt; maxVal &lt;&lt; <span class="built_in">endl</span> &lt;&lt; minLoc &lt;&lt; <span class="built_in">endl</span> &lt;&lt; maxLoc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">rectangle(src, maxLoc, Point(maxLoc.x + temp.cols, maxLoc.y + temp.rows), Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">rectangle(result, Point(maxLoc.x - temp.cols/<span class="number">2</span>, maxLoc.y - temp.rows/<span class="number">2</span>), Point(maxLoc.x + temp.cols/<span class="number">2</span>, maxLoc.y + temp.rows/<span class="number">2</span>), Scalar::all(<span class="number">1</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">namedWindow(<span class="string">"src"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">pyrDown(src, src, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(src, src, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));</span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line">namedWindow(<span class="string">"result"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">pyrDown(result, result, Size(result.cols / <span class="number">2</span>, result.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(result, result, Size(result.cols / <span class="number">2</span>, result.rows / <span class="number">2</span>));</span><br><span class="line">imshow(<span class="string">"result"</span>, result);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/63d72132.html">http://dynais.xyz/posts/63d72132.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;matchTemplate();&lt;span class=&quot;comment&quot;&gt;//模式查找,API比较简单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minMaxLoc();&lt;span class=&quot;comment&quot;&gt;//用于在模式查找的输出图像中找到极值点,也就是匹配点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模板匹配(Templet Match)&lt;/p&gt;
&lt;p&gt;相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注意输出图像的大小&lt;/p&gt;
&lt;p&gt;在API中需要提供一个储存输出结果的Mat, 他的大小是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Size(src.cols-templ.cols+1, src.rows-templ.rows+1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记11-直方图均衡化-直方图比较-反向投影</title>
    <link href="http://dynais.xyz/posts/81b2be88.html"/>
    <id>http://dynais.xyz/posts/81b2be88.html</id>
    <published>2020-02-18T16:00:00.000Z</published>
    <updated>2020-07-24T16:49:20.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- equalizeHist();<span class="comment">//直方图均衡化</span></span><br><span class="line">- split();<span class="comment">//分离通道</span></span><br><span class="line">- calcHist();<span class="comment">//参数dims,bin,range</span></span><br><span class="line">- waitkey();</span><br><span class="line"></span><br><span class="line">- mixChannels<span class="comment">//分离通道, 与split小有差别,建议看官方文档</span></span><br><span class="line">- cvtColer<span class="comment">//使用此api转换到hsv色彩空间</span></span><br><span class="line">- calcHist<span class="comment">//接受单通道图像计算直方图, 参数略微复杂</span></span><br><span class="line">- normalize<span class="comment">//归一化,常用</span></span><br><span class="line">- compareHist<span class="comment">//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感</span></span><br><span class="line">- backProject();<span class="comment">//直方图反向投影</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><em>这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档</em></p><a id="more"></a><ul><li><strong>直方图均衡化</strong></li></ul><p>好像在人脸识别的项目总结里写过了, API并不难理解</p><ul><li><strong>HSV模型</strong></li></ul><p>HSV是一种比较直观的颜色模型，所以在许多图像编辑工具中应用比较广泛，这个模型中颜色的参数分别是：色调（H, Hue），饱和度（S,Saturation），明度（V, Value）</p><ul><li><strong>直方图比较</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareHist();</span><br></pre></td></tr></table></figure><p>API比较方便,输入两个直方图,比较他们的相似程度</p><p><strong>这两个直方图通常会是图像的HS直方图</strong>(虽然我现在还不太懂HS为什么可以变成一张直方图,到时候要用再看原理好了),用HS猜测是要降低算法对光线的敏感度?(实测好像对光线还是很敏感)</p><p>OpenCV提供了一共四种方法</p><ul><li>相关性计算:{-1, 1}  //1最强</li><li>卡方计算:{0, ∞}  //0最强</li><li>十字交叉</li><li>巴氏距离计算:{0, 1}  //0最强</li></ul><p>其中比较推荐的是相关性计算和巴氏距离计算(不需要归一化了hhhhhhhhh)</p><p>数学公式不列出了(反正我又不会去看)</p><ul><li><strong>直方图反向投影</strong></li></ul><blockquote id="fn_0"><sup>0</sup>. 论文:《Indexing Via Color Histograms》<a href="#reffn_0" title="Jump back to footnote [0] in the text."> &#8617;</a></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixChannels();</span><br><span class="line">backProject();</span><br></pre></td></tr></table></figure><p>直方图反向投影是一种基于色彩的对象识别技术,通过该方法可以定位图像中已知物体的位置,反应直方图在目标图像中的分布</p><p>主要思路是提取已知图像的Hue(色相)空间,做出直方图,再反向找到这些色相在目标图片中的分布,已知图像中越多的色相,在backProject中就会(看起来)更亮,利用这点加上一些二值化,就可以得到一张目标物体的掩膜,覆盖到目标图片上就可以得到完成的图像了,如下</p><hr><h3 id="源-读取TIM图标-在桌面截图上找到他"><a href="#源-读取TIM图标-在桌面截图上找到他" class="headerlink" title="源//读取TIM图标, 在桌面截图上找到他"></a>源//读取TIM图标, 在桌面截图上找到他</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Mat hue;</span><br><span class="line">Mat target_hue;</span><br><span class="line"><span class="keyword">int</span> bins = <span class="number">25</span>;</span><br><span class="line">Mat src_mask_globle;</span><br><span class="line">Mat target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读入src</span></span><br><span class="line">    <span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, <span class="string">"&#123;@input |D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Tim.png  | input image&#125;"</span>)</span></span>;</span><br><span class="line">    Mat src = imread(parser.<span class="built_in">get</span>&lt;<span class="keyword">String</span>&gt;(<span class="string">"@input"</span>));</span><br><span class="line">    <span class="keyword">if</span> (src.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open or find the image!\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" &lt;Input image&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    target = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/屏幕.png"</span>);</span><br><span class="line">    pyrDown(target, target, Size(target.cols / <span class="number">2</span>, target.rows / <span class="number">2</span>));</span><br><span class="line">    pyrDown(target, target, Size(target.cols / <span class="number">2</span>, target.rows / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//pyrDown(src, src, Size(src.cols / 2, src.rows / 2));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二值化取覆膜</span></span><br><span class="line">    Mat src_gray;</span><br><span class="line">    cvtColor(src, src_gray, COLOR_BGR2GRAY);</span><br><span class="line">    Mat src_mask;</span><br><span class="line">    threshold(src_gray, src_mask, <span class="number">0</span>, <span class="number">255</span>, THRESH_TRIANGLE);</span><br><span class="line">    src_mask_globle = src_mask;</span><br><span class="line">    imshow(<span class="string">"BinMask"</span>, src_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//色彩空间转换</span></span><br><span class="line">    <span class="comment">//src = Mat(src.size(), src.type(), Scalar(255, 0, 0));</span></span><br><span class="line">    Mat hsv;</span><br><span class="line">    cvtColor(src, hsv, COLOR_BGR2HSV);</span><br><span class="line">    Mat target_hsv;</span><br><span class="line">    cvtColor(target, target_hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Hue空间通道图像</span></span><br><span class="line">    hue.create(hsv.<span class="built_in">size</span>(), hsv.depth());</span><br><span class="line">    target_hue.create(target_hsv.<span class="built_in">size</span>(), target_hsv.depth());</span><br><span class="line">    <span class="keyword">int</span> ch[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    mixChannels(&amp;hsv, <span class="number">1</span>, &amp;hue, <span class="number">1</span>, ch, <span class="number">1</span>);</span><br><span class="line">    mixChannels(&amp;target_hsv, <span class="number">1</span>, &amp;target_hue, <span class="number">1</span>, ch, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; hue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建滑块并BackProjection</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* window_image = <span class="string">"Source image"</span>;</span><br><span class="line">    namedWindow(window_image);</span><br><span class="line">    createTrackbar(<span class="string">"* Hue  bins: "</span>, window_image, &amp;bins, <span class="number">180</span>, Hist_and_Backproj);</span><br><span class="line">    Hist_and_Backproj(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    imshow(window_image, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until user exits the program</span></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//防止bins太小</span></span><br><span class="line">    <span class="keyword">int</span> histSize = MAX(bins, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算Hue空间直方图</span></span><br><span class="line">    <span class="keyword">float</span> hue_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>* ranges = &#123; hue_range &#125;;</span><br><span class="line">    Mat hist;</span><br><span class="line">    calcHist(&amp;hue, <span class="number">1</span>, <span class="number">0</span>, src_mask_globle, hist, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX, <span class="number">-1</span>, Mat());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BackProjection</span></span><br><span class="line">    Mat backproj;</span><br><span class="line">    calcBackProject(&amp;target_hue, <span class="number">1</span>, <span class="number">0</span>, hist, backproj, &amp;ranges, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    threshold(backproj, backproj, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    imshow(<span class="string">"BackProj"</span>, backproj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制直方图</span></span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">400</span>, h = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">int</span> bin_w = cvRound((<span class="keyword">double</span>)w / histSize);</span><br><span class="line">    Mat histImg = Mat::zeros(h, w, CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rectangle(histImg, Point(i * bin_w, h), Point((i + <span class="number">1</span>) * bin_w, h - cvRound(hist.at&lt;<span class="keyword">float</span>&gt;(i) * h / <span class="number">255.0</span>)),</span><br><span class="line">            Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">    &#125;</span><br><span class="line">    imshow(<span class="string">"Histogram"</span>, histImg);</span><br><span class="line"></span><br><span class="line">    Mat focus;</span><br><span class="line">    target.copyTo(focus, backproj);</span><br><span class="line">    imshow(<span class="string">"focus"</span>, focus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/81b2be88.html">http://dynais.xyz/posts/81b2be88.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- equalizeHist();&lt;span class=&quot;comment&quot;&gt;//直方图均衡化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- split();&lt;span class=&quot;comment&quot;&gt;//分离通道&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- calcHist();&lt;span class=&quot;comment&quot;&gt;//参数dims,bin,range&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- waitkey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- mixChannels&lt;span class=&quot;comment&quot;&gt;//分离通道, 与split小有差别,建议看官方文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- cvtColer&lt;span class=&quot;comment&quot;&gt;//使用此api转换到hsv色彩空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- calcHist&lt;span class=&quot;comment&quot;&gt;//接受单通道图像计算直方图, 参数略微复杂&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- normalize&lt;span class=&quot;comment&quot;&gt;//归一化,常用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- compareHist&lt;span class=&quot;comment&quot;&gt;//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- backProject();&lt;span class=&quot;comment&quot;&gt;//直方图反向投影&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;p&gt;&lt;em&gt;这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记10-霍夫线和圆检测</title>
    <link href="http://dynais.xyz/posts/e1955f21.html"/>
    <id>http://dynais.xyz/posts/e1955f21.html</id>
    <published>2020-02-16T14:00:00.000Z</published>
    <updated>2020-07-24T17:00:32.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*霍夫线检测 输入图像要先Canny过 参数为</span></span><br><span class="line"><span class="comment">- 输入图像</span></span><br><span class="line"><span class="comment">- 输出向量数组,数据类型为Vec4i(就是两个点)</span></span><br><span class="line"><span class="comment">- 默认1</span></span><br><span class="line"><span class="comment">- 默认CV_PI / 180, 转角步长</span></span><br><span class="line"><span class="comment">- 阈值(我设了100)</span></span><br><span class="line"><span class="comment">- 最小线长</span></span><br><span class="line"><span class="comment">- 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HoughLinesP</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArray lines,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> rho, <span class="keyword">double</span> theta, <span class="keyword">int</span> threshold,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">double</span> minLineLength = <span class="number">0</span>, <span class="keyword">double</span> maxLineGap = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*霍夫圆检测 参数从前往后分别是</span></span><br><span class="line"><span class="comment">- 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测)</span></span><br><span class="line"><span class="comment">- 输出向量数组,数据类型位Vec3f</span></span><br><span class="line"><span class="comment">- HOUGH_GRADIENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 图像缩放,默认1</span></span><br><span class="line"><span class="comment">- 圆心最小距离, 小于会认为是同心圆?</span></span><br><span class="line"><span class="comment">- Canny检测的大阈值,小的=大的除二计算</span></span><br><span class="line"><span class="comment">- 点重叠n个以上判定为圆,越小检出越多圆</span></span><br><span class="line"><span class="comment">- 最小圆半径</span></span><br><span class="line"><span class="comment">- 最大圆半径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HoughCircles</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArray circles,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> method, <span class="keyword">double</span> dp, <span class="keyword">double</span> minDist,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> param1 = <span class="number">100</span>, <span class="keyword">double</span> param2 = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> minRadius = <span class="number">0</span>, <span class="keyword">int</span> maxRadius = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>圆检测对噪声敏感, 需要先中值滤波</li><li>太难了,建议看下面的博客,线检测还好,圆检测真的看不懂</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><h3 id="源-检出NXP赛道上的几何图"><a href="#源-检出NXP赛道上的几何图" class="headerlink" title="源//检出NXP赛道上的几何图"></a>源//检出NXP赛道上的几何图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/直道进圆环.jpg"</span>, IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; imgIn;</span></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="keyword">double</span> tCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> tSum = <span class="number">0</span>;</span><br><span class="line">tCount = getTickCount();</span><br><span class="line"></span><br><span class="line">cvtColor(imgIn, imgIn, COLOR_BGR2GRAY);</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgIn, imgIn, Size(imgIn.cols / <span class="number">2</span>, imgIn.rows / <span class="number">2</span>));</span><br><span class="line"><span class="comment">//GaussianBlur(imgOut, imgOut, Size(3, 3), 1.4);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//霍夫圆检测</span></span><br><span class="line">imgOut = Mat::zeros(imgIn.<span class="built_in">size</span>(), imgIn.type());</span><br><span class="line"><span class="built_in">vector</span>&lt;Vec3f&gt; circles;</span><br><span class="line">HoughCircles(imgIn, circles, HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">50</span>, <span class="number">125</span>, <span class="number">30</span>);<span class="comment">//参数很难试</span></span><br><span class="line">Vec3f aCircle;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; circles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">aCircle = circles[i];</span><br><span class="line"><span class="built_in">circle</span>(imgOut, Point(aCircle[<span class="number">0</span>],aCircle[<span class="number">1</span>]), aCircle[<span class="number">2</span>], Scalar(<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//霍夫直线检测</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Vec4i&gt; lines;</span><br><span class="line">Canny(imgIn, imgIn, <span class="number">50</span>, <span class="number">125</span>, <span class="number">3</span>);</span><br><span class="line">HoughLinesP(imgIn, lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">60</span>, <span class="number">0.0</span>, <span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">Vec4i aLine;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">aLine = lines[i];</span><br><span class="line"><span class="built_in">line</span>(imgOut, Point(aLine[<span class="number">0</span>], aLine[<span class="number">1</span>]), Point(aLine[<span class="number">2</span>], aLine[<span class="number">3</span>]) ,Scalar(<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tSum = (getTickCount() - tCount) / getTickFrequency();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time consume %.4f\n\n"</span>, tSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/e1955f21.html">http://dynais.xyz/posts/e1955f21.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*霍夫线检测 输入图像要先Canny过 参数为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输入图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输出向量数组,数据类型为Vec4i(就是两个点)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 默认1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 默认CV_PI / 180, 转角步长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 阈值(我设了100)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最小线长&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HoughLinesP&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, OutputArray lines,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; rho, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; theta, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threshold,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minLineLength = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; maxLineGap = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*霍夫圆检测 参数从前往后分别是&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 输出向量数组,数据类型位Vec3f&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- HOUGH_GRADIENT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 图像缩放,默认1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 圆心最小距离, 小于会认为是同心圆?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- Canny检测的大阈值,小的=大的除二计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 点重叠n个以上判定为圆,越小检出越多圆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最小圆半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;- 最大圆半径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HoughCircles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( InputArray &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, OutputArray circles,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; method, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dp, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minDist,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; param1 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; param2 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minRadius = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxRadius = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记09-Canny边缘检测算法</title>
    <link href="http://dynais.xyz/posts/80e5fe0.html"/>
    <id>http://dynais.xyz/posts/80e5fe0.html</id>
    <published>2020-02-16T12:00:00.000Z</published>
    <updated>2020-07-24T16:49:08.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Canny();<span class="comment">//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p><strong>Canny边缘检测算法可以分为以下5个步骤：</strong></p><ul><li><p>使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)</p></li><li><p>计算图像中每个像素点的梯度强度和方向。</p></li><li><p>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</p></li><li><p>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</p></li><li><p>通过抑制孤立的弱边缘最终完成边缘检测。</p></li></ul></li></ul><ul><li><strong>非极大值抑制:</strong></li></ul><p>细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.</p><a id="more"></a><ul><li><strong>关于几种边缘检测方法:</strong></li></ul><p>Laplance, Canny 和 Sobel 都是边缘检测的方法, Canny是包含了Sobel算子的边缘检测, 所以可以说是Sobel的实际应用, Laplance的检测效果并不好, 但是有其他的用途, 总的来说Canny能应对大多数的场景</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><p>《A Computational Approach to Edge Detection》</p></li><li><p>[1]: <a href="https://www.cnblogs.com/techyan1990/p/7291771.html" target="_blank" rel="noopener">https://www.cnblogs.com/techyan1990/p/7291771.html</a>    “边缘检测之Canny”</p></li></ul><h3 id="源-对NXP赛道进行下采样和边缘检测"><a href="#源-对NXP赛道进行下采样和边缘检测" class="headerlink" title="源//对NXP赛道进行下采样和边缘检测"></a>源//对NXP赛道进行下采样和边缘检测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV_Template.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat imgIn, imgOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line">imgIn = imread(<span class="string">"D:/WorkSpace/Projects/OpenCV Learning/ImageHub/直道进圆环.jpg"</span>, IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (imgIn.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can not open this IMG..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VideoCapture(0) &gt;&gt; imgIn;</span></span><br><span class="line">imgOut = imgIn.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************初始化****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"><span class="keyword">double</span> tCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> tSum = <span class="number">0</span>;</span><br><span class="line">tCount = getTickCount();</span><br><span class="line"></span><br><span class="line">cvtColor(imgIn, imgOut, COLOR_BGR2GRAY);<span class="comment">//Canny只接受8位深度的灰度图</span></span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));<span class="comment">//下采样</span></span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));</span><br><span class="line">pyrDown(imgOut, imgOut, Size(imgOut.cols / <span class="number">2</span>, imgOut.rows / <span class="number">2</span>));</span><br><span class="line"><span class="comment">//GaussianBlur(imgOut, imgOut, Size(3, 3), 1.4);</span></span><br><span class="line"></span><br><span class="line">Canny(imgOut, imgOut, <span class="number">50</span>, <span class="number">125</span>, <span class="number">3</span>);<span class="comment">//第三,四个参数代表上下阈值, 第五个是Sobel算子的大小, 一般取3</span></span><br><span class="line"></span><br><span class="line">tSum = (getTickCount() - tCount) / getTickFrequency();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time consume %.4f\n\n"</span>, tSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像操作****************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_NORMAL);</span><br><span class="line">imshow(<span class="string">"input"</span>, imgIn);</span><br><span class="line">namedWindow(<span class="string">"output"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"output"</span>, imgOut);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; imgOut &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************图像输出****************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门使用技巧: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/80e5fe0.html">http://dynais.xyz/posts/80e5fe0.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Canny();	&lt;span class=&quot;comment&quot;&gt;//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Canny边缘检测算法可以分为以下5个步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算图像中每个像素点的梯度强度和方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过抑制孤立的弱边缘最终完成边缘检测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非极大值抑制:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记08-Sobel算子</title>
    <link href="http://dynais.xyz/posts/87b7dd44.html"/>
    <id>http://dynais.xyz/posts/87b7dd44.html</id>
    <published>2020-02-15T12:48:00.000Z</published>
    <updated>2020-07-24T16:49:03.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sobel();<span class="comment">//索贝尔算子</span></span><br><span class="line">Scharr();<span class="comment">//Sobel的加强</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p><strong>Sobel:</strong> <a href="https://www.jianshu.com/p/2a06c68f6c14" target="_blank" rel="noopener">边缘检测算法及各自的优缺点</a></p><p>Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺</p></li></ul><ul><li><p><strong>使用加减来简化计算机的负担:</strong> <a href="https://blog.csdn.net/qq_37124237/article/details/82183177" target="_blank" rel="noopener">sobel算子的原理与实现</a></p><p>乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想</p></li></ul><ul><li><p><strong>整个流程:</strong></p><p> 高斯-&gt;转灰度-&gt;求梯度x与y-&gt;混合</p> <a id="more"></a></li></ul><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/87b7dd44.html">http://dynais.xyz/posts/87b7dd44.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关API&quot;&gt;&lt;a href=&quot;#相关API&quot; class=&quot;headerlink&quot; title=&quot;相关API&quot;&gt;&lt;/a&gt;相关API&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Sobel();&lt;span class=&quot;comment&quot;&gt;//索贝尔算子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Scharr();&lt;span class=&quot;comment&quot;&gt;//Sobel的加强&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sobel:&lt;/strong&gt; &lt;a href=&quot;https://www.jianshu.com/p/2a06c68f6c14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;边缘检测算法及各自的优缺点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用加减来简化计算机的负担:&lt;/strong&gt; &lt;a href=&quot;https://blog.csdn.net/qq_37124237/article/details/82183177&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sobel算子的原理与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;整个流程:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 高斯-&amp;gt;转灰度-&amp;gt;求梯度x与y-&amp;gt;混合&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记07-上下采样-高斯不同(DOG)</title>
    <link href="http://dynais.xyz/posts/45be0b87.html"/>
    <id>http://dynais.xyz/posts/45be0b87.html</id>
    <published>2020-02-15T12:39:00.000Z</published>
    <updated>2020-07-24T16:48:57.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- pyrUp();<span class="comment">//上采样</span></span><br><span class="line">- pyrDown();<span class="comment">//下采样</span></span><br><span class="line">- subtract();<span class="comment">//图像减法</span></span><br><span class="line"></span><br><span class="line">- threshold()<span class="comment">//二值化</span></span><br><span class="line">- binarythreshold()<span class="comment">//还是二值化</span></span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><strong>高斯金字塔:</strong><br>涉及到上采样和下采样的概念<br>实现步骤是:   1.高斯模糊    2.删除当前层偶数行列</li></ul><ul><li><strong>高斯不同(DOG):</strong><br>同图像在不同参数下做高斯模糊然后结果相减, 最后记得归一化, 不然图很淡</li></ul><a id="more"></a><ul><li><p><strong>上/下采样对比几个像素求平均合成的优势:</strong></p><p>最大的好处就是变快了, 在人脸识别那个项目里我自己写了压缩算法,但是速度和这个相差了一倍(在720p下)</p><p>但是也发现这个算法有局限, 首先图像会便模糊, 其次只能实现2的次方倍的缩放(至少根据OpenCV里的API来看)</p></li></ul><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/45be0b87.html">http://dynais.xyz/posts/45be0b87.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- pyrUp();&lt;span class=&quot;comment&quot;&gt;//上采样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- pyrDown();&lt;span class=&quot;comment&quot;&gt;//下采样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- subtract();&lt;span class=&quot;comment&quot;&gt;//图像减法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- threshold()&lt;span class=&quot;comment&quot;&gt;//二值化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- binarythreshold()&lt;span class=&quot;comment&quot;&gt;//还是二值化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯金字塔:&lt;/strong&gt;&lt;br&gt;涉及到上采样和下采样的概念&lt;br&gt;实现步骤是:   1.高斯模糊    2.删除当前层偶数行列&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高斯不同(DOG):&lt;/strong&gt;&lt;br&gt;同图像在不同参数下做高斯模糊然后结果相减, 最后记得归一化, 不然图很淡&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://dynais.xyz/categories/note/"/>
    
      <category term="open-cv" scheme="http://dynais.xyz/categories/note/open-cv/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中人脸识别的Haar实现</title>
    <link href="http://dynais.xyz/posts/dd5a240f.html"/>
    <id>http://dynais.xyz/posts/dd5a240f.html</id>
    <published>2020-02-05T16:00:00.000Z</published>
    <updated>2020-07-24T16:49:50.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目总结-人脸识别的Haar实现"><a href="#项目总结-人脸识别的Haar实现" class="headerlink" title="项目总结_人脸识别的Haar实现"></a>项目总结_人脸识别的Haar实现</h2><h5 id="项目历时-2020-2-3-2020-2-5"><a href="#项目历时-2020-2-3-2020-2-5" class="headerlink" title="项目历时:    2020.2.3 - 2020.2.5"></a>项目历时:    2020.2.3 - 2020.2.5</h5><h5 id="负责人-Dynais"><a href="#负责人-Dynais" class="headerlink" title="负责人:    Dynais"></a>负责人:    Dynais</h5><h5 id="项目花费-无"><a href="#项目花费-无" class="headerlink" title="项目花费:    无"></a>项目花费:    无</h5><h5 id="报告撰写时间-2020-2-6"><a href="#报告撰写时间-2020-2-6" class="headerlink" title="报告撰写时间: 2020.2.6"></a>报告撰写时间: 2020.2.6</h5><hr><h3 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h3><p>本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><p><strong>第一部分</strong>    部分原理粗解</p><ul><li>1.1    图像压缩</li><li>1.2    直方图均衡化</li><li>1.3    Haar特征检测</li></ul><a id="more"></a></li></ul><ul><li><strong>第二部分</strong>    软件结构设计与实现</li></ul><ul><li><p><strong>第三部分</strong>    难点与优化方法</p><ul><li>3.1    难点一:    面部检测速度过慢</li></ul></li></ul><ul><li><p><strong>第四部分</strong>    总结</p><ul><li>4.1    不足之处</li><li>4.2    总结</li></ul></li></ul><ul><li><strong>第五部分</strong>    参考文献</li></ul><hr><h2 id="第一部分-部分原理粗解"><a href="#第一部分-部分原理粗解" class="headerlink" title="第一部分 部分原理粗解"></a>第一部分 部分原理粗解</h2><h3 id="1-1-图像压缩"><a href="#1-1-图像压缩" class="headerlink" title="1.1 图像压缩"></a>1.1 图像压缩</h3><p>对原图多个像素求和后取平均值, 得到一个新的像素值, 作为目标图像的像素值, 这样得到的新图像就是经过了压缩的原图像, 原理过于简单就不详细展开</p><h3 id="1-2-直方图均衡化"><a href="#1-2-直方图均衡化" class="headerlink" title="1.2 直方图均衡化"></a>1.2 直方图均衡化</h3><h5 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h5><p>建立一个桶, 将一幅图像的某一个通道的像素值进行桶排序并可视化, 呈现出来的图像称为直方图</p><p>一幅灰度图像的直方图通常如下:</p><p>[图没了]</p><p>直方图可以直观的反应图像上的像素值分布情况, 如:</p><p><img src="https://img-blog.csdnimg.cn/20181123160536532.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjaHdlaW5fdmFu,size_16,color_FFFFFF,t_70" alt="图1 4种基本的图像类型：暗图像、亮图像、低对比度图像、高对比度图像及其对应的直方图"></p><p><strong>直方图均衡化</strong></p><p>直方图均衡化是将原图像通过某种变换，得到一幅灰度直方图为均匀分布的新图像的方法.</p><p>直方图均衡化方法的基本思想是对在图像中像素个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减. 从而达到清晰图像的目的.</p><p><strong>将原图的像素值进行重新映射, 使直方图分布更加均匀, 达到了加强图像对比度的目的.</strong></p><p>具体解析见:</p><p><a href="https://blog.csdn.net/schwein_van/article/details/84336633" target="_blank" rel="noopener">直方图均衡化</a></p><h3 id="1-3-Haar特征检测"><a href="#1-3-Haar特征检测" class="headerlink" title="1.3 Haar特征检测"></a>1.3 Haar特征检测</h3><p>Haar 特征检测部分, 由于已经有大量的博客详细描述过了, 所以不再浪费时间写</p><p>值得一提的是原作者的论文《Robust Real-Time Face Detection》是人脸检测的经典论文, 虽然读起来很困难(更何况是英文) 但还是值得一读, 如果希望深入了解的话</p><p>更多博客文章: 印象笔记关键字: <strong>Haar</strong></p><hr><h2 id="第二部分-软件结构设计与实现方法"><a href="#第二部分-软件结构设计与实现方法" class="headerlink" title="第二部分 软件结构设计与实现方法"></a>第二部分 软件结构设计与实现方法</h2><p>文件夹”OpenCV_FaceDetectPro”中包含了两个.cpp文件:</p><ul><li>OpenCV_Process.cpp    包括人脸检测函数及其相关调用函数</li><li>OpenCV_main.cpp    程序主入口</li></ul><h3 id="人脸检测流程"><a href="#人脸检测流程" class="headerlink" title="人脸检测流程"></a>人脸检测流程</h3><p>人脸检测(优化后的版本)的步骤分为:</p><ul><li><p>识别标志位, 判断当前状态是检测还是跟踪</p></li><li><p>对摄像头当前采集图像进行分割</p></li><li>灰度化</li><li>压缩</li><li>直方图均衡化</li><li>Haar特征检测</li><li>返回人脸位置</li></ul><h3 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h3><h5 id="状态识别"><a href="#状态识别" class="headerlink" title="状态识别"></a>状态识别</h5><p>由于时间复杂度问题(在下一章会说到), 采用了检测和跟踪分开的思路, 主要的思路是降低输入图像的大小. 采用每次检测完人脸后进行标志的判断为方法, 确定程序运行在那种状态下.</p><p>对于检测和跟踪模式, 使用了不同的思路来进行图像分割</p><h5 id="Haar"><a href="#Haar" class="headerlink" title="Haar"></a>Haar</h5><p>直接使用了现成的数据, 自己并不会训练, 直接调用OpenCV的 CascadeClassifier 类实现</p><hr><h2 id="第三部分-难点与优化方法"><a href="#第三部分-难点与优化方法" class="headerlink" title="第三部分 难点与优化方法"></a>第三部分 难点与优化方法</h2><h3 id="3-1-难点一-面部检测速度过慢"><a href="#3-1-难点一-面部检测速度过慢" class="headerlink" title="3.1 难点一: 面部检测速度过慢"></a>3.1 难点一: 面部检测速度过慢</h3><p>未优化前的程序, 每次读入摄像头图像后直接进行灰度化与直方图均衡化, 然后进行全图的面部检测, 并且没有面部跟踪的实现, 导致每次图像的处理时间非常长, 达到了每帧图像0.8秒.</p><p>针对时间过长的问题, 首先引入了面部识别的标志位, 每次程序识别到面部时, 打开标志位, 然后在接下来的循环里只根据上次判断的面部位置截取小块图像进行判断,大大降低处理时间</p><p>其次, 使用图像压缩, 使待处理图像处于一个大小和准确度都可以接受的点上.</p><p><strong>引入后, 面部检测的时间从0.8秒降低到0.04秒</strong></p><p><strong>部分代码:</strong></p><p><strong>图像压缩</strong>(前置函数为自己写的areaAvarage())</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;****************************************************</span><br><span class="line">*   Function:</span><br><span class="line">*   用于图像压缩函数zipImg, 基于周边像素求出当前像素值</span><br><span class="line">*</span><br><span class="line">*   Note:</span><br><span class="line">*   算法用左上像素求, 不知道会不会失真</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">******************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">uchar areaAvarage(Mat src, Point pos, int channal, int gain) &#123;</span><br><span class="line">    int pixel &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (src.channels() !&#x3D; 1) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i &#x3D; 0; i &lt; gain; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; gain; j++) &#123;</span><br><span class="line">                pixel +&#x3D; src.at&lt;Vec3b&gt;(pos.y - j, pos.x - i)[channal];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pixel &#x2F;&#x3D; (gain * gain);</span><br><span class="line">        return saturate_cast&lt;uchar&gt;(pixel);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i &#x3D; 0; i &lt; gain; i++) &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; gain; j++) &#123;</span><br><span class="line">                pixel +&#x3D; src.at&lt;uchar&gt;(pos.y - j, pos.x - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pixel &#x2F;&#x3D; (gain * gain);</span><br><span class="line">        return saturate_cast&lt;uchar&gt;(pixel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;****************************************************</span><br><span class="line">*   Function:</span><br><span class="line">*   图像压缩 gain^2 倍,长宽变为原先 1&#x2F;gain</span><br><span class="line">*</span><br><span class="line">*   Note:</span><br><span class="line">*速度还是不够理想</span><br><span class="line">*   留出了一圈白边</span><br><span class="line">*</span><br><span class="line">******************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">void zipImg(Mat&amp; src, Mat&amp; dst, int gain) &#123;</span><br><span class="line">    dst &#x3D; Mat(src.size() &#x2F; gain, src.type());</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    if (src.channels() !&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历</span><br><span class="line">        for (i &#x3D; 1; i &lt; dst.cols - 1; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt; dst.rows - 1; j++) &#123;</span><br><span class="line">                uchar b, g, r;</span><br><span class="line">                int realpos_x &#x3D; i * gain;</span><br><span class="line">                int realpos_y &#x3D; j * gain;</span><br><span class="line">                Point pos(realpos_x, realpos_y);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;对周边像素求均值,赋值给新图</span><br><span class="line">                b &#x3D; areaAvarage(src, pos, 0, gain);</span><br><span class="line">                g &#x3D; areaAvarage(src, pos, 1, gain);</span><br><span class="line">                r &#x3D; areaAvarage(src, pos, 2, gain);</span><br><span class="line">                dst.at&lt;Vec3b&gt;(j, i) &#x3D; &#123; b,g,r &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for (i &#x3D; 1; i &lt; dst.cols - 1; i++) &#123;</span><br><span class="line">            for (j &#x3D; 1; j &lt; dst.rows - 1; j++) &#123;</span><br><span class="line">                uchar g;</span><br><span class="line">                int realpos_x &#x3D; i * gain;</span><br><span class="line">                int realpos_y &#x3D; j * gain;</span><br><span class="line">                Point pos(realpos_x, realpos_y);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;对周边像素求均值,赋值给新图</span><br><span class="line">                g &#x3D; areaAvarage(src, pos, 1, gain);</span><br><span class="line">                dst.at&lt;uchar&gt;(j, i) &#x3D; g;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第四部分-总结"><a href="#第四部分-总结" class="headerlink" title="第四部分 总结"></a>第四部分 总结</h2><h3 id="4-1-不足之处"><a href="#4-1-不足之处" class="headerlink" title="4.1    不足之处"></a>4.1    不足之处</h3><ul><li>虽然采用检测与跟踪同样裁剪画面的方法, 但是效果其实并不理想, 速度提升微弱</li><li>面部检测对侧脸准确性几乎没有</li><li>光照优化有待加强</li><li>速度还是不够快</li><li>脸太大或太小检测不了</li></ul><h3 id="4-2-总结"><a href="#4-2-总结" class="headerlink" title="4.2    总结"></a>4.2    总结</h3><p>总的来说这次项目还是挺成功的, 在几天以内就完成了, 虽然借由了大量API, 但原理也还是有所了解的. 接下来的任务是使他能够在树莓派上也能正常运行. </p><p><br /><br /><br /><strong>本文永久链接</strong>： <a href="http://dynais.xyz/posts/dd5a240f.html">http://dynais.xyz/posts/dd5a240f.html</a> <br /><strong>版权声明</strong><br /><img src="https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20200725160918.png" alt=""><br />This site by DynAis is licensed under a Creative Commons <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC-BY-NC-SA 4.0 International License</a>.<br />由Dynais创作并维护的博客采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">创作共用-署名-非商业性-相同方式共享4.0国际许可证</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目总结-人脸识别的Haar实现&quot;&gt;&lt;a href=&quot;#项目总结-人脸识别的Haar实现&quot; class=&quot;headerlink&quot; title=&quot;项目总结_人脸识别的Haar实现&quot;&gt;&lt;/a&gt;项目总结_人脸识别的Haar实现&lt;/h2&gt;&lt;h5 id=&quot;项目历时-2020-2-3-2020-2-5&quot;&gt;&lt;a href=&quot;#项目历时-2020-2-3-2020-2-5&quot; class=&quot;headerlink&quot; title=&quot;项目历时:    2020.2.3 - 2020.2.5&quot;&gt;&lt;/a&gt;项目历时:    2020.2.3 - 2020.2.5&lt;/h5&gt;&lt;h5 id=&quot;负责人-Dynais&quot;&gt;&lt;a href=&quot;#负责人-Dynais&quot; class=&quot;headerlink&quot; title=&quot;负责人:    Dynais&quot;&gt;&lt;/a&gt;负责人:    Dynais&lt;/h5&gt;&lt;h5 id=&quot;项目花费-无&quot;&gt;&lt;a href=&quot;#项目花费-无&quot; class=&quot;headerlink&quot; title=&quot;项目花费:    无&quot;&gt;&lt;/a&gt;项目花费:    无&lt;/h5&gt;&lt;h5 id=&quot;报告撰写时间-2020-2-6&quot;&gt;&lt;a href=&quot;#报告撰写时间-2020-2-6&quot; class=&quot;headerlink&quot; title=&quot;报告撰写时间: 2020.2.6&quot;&gt;&lt;/a&gt;报告撰写时间: 2020.2.6&lt;/h5&gt;&lt;hr&gt;
&lt;h3 id=&quot;项目概述&quot;&gt;&lt;a href=&quot;#项目概述&quot; class=&quot;headerlink&quot; title=&quot;项目概述&quot;&gt;&lt;/a&gt;项目概述&lt;/h3&gt;&lt;p&gt;本次项目的计划是在短时间内制作出可以高准确度检测人脸并返回面部相对坐标的程序, 在经过参考他人的程序与查阅资料后采用了OpenCV内建的Haar级联器进行人脸的检测. 因为综合考虑可知Haar检测有准确率高, 速度快, 原理简单的优点, 虽然对于人脸侧面的检测不理想, 但是对于本次项目来说已经足够, 并且OpenCV已经有内建的Haar级联器, 以及训练好的数据集, 非常易于使用, 大大降低了项目的难度.&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一部分&lt;/strong&gt;    部分原理粗解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.1    图像压缩&lt;/li&gt;
&lt;li&gt;1.2    直方图均衡化&lt;/li&gt;
&lt;li&gt;1.3    Haar特征检测&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="project" scheme="http://dynais.xyz/categories/project/"/>
    
      <category term="harr-face-detect" scheme="http://dynais.xyz/categories/project/harr-face-detect/"/>
    
    
      <category term="open-cv" scheme="http://dynais.xyz/tags/open-cv/"/>
    
      <category term="cpp" scheme="http://dynais.xyz/tags/cpp/"/>
    
      <category term="数字图像处理" scheme="http://dynais.xyz/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
