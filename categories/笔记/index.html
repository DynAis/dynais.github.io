<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>笔记 | DynAis</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://dynais.github.io/categories/%E7%AC%94%E8%AE%B0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dynais.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dynais.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dynais.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dynais.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://dynais.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://dynais.github.io/categories/%E7%AC%94%E8%AE%B0/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="笔记" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://dynais.github.io/categories/%E7%AC%94%E8%AE%B0/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="笔记"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dynais.github.io/" accesskey="h" title="DynAis (Alt + H)">DynAis</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>笔记</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>解决Python脚本在运行环境下依赖库缺失的问题
    </h2>
  </header>
  <section class="entry-content">
    <p>在某一个虚拟环境中完成脚本后, 想要实际使用时可能会出现错误 {% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210223124433.png?x-oss-process=image/resize,h_2000/quality,q_90 %} 这是由于虚拟环境和运行环境不一致导致依赖库缺失无法import导致的
问题描述 在某一个虚拟环境中完成脚本后, 想要实际使用时可能会出现错误 {% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20210223124433.png?x-oss-process=image/resize,h_2000/quality,q_90 %} 这是由于虚拟环境和运行环境不一致导致依赖库缺失无法import导致的 解决方法 解决方式就是在编写脚本时, 对于第三方的库进行一次检测, 如果没有的话就进行pip install
try:  import regex as re except ImportError:  os.system(&#39;pip install regex&#39;)  import regex as re 对于小脚本来说这样就足够了, 项目大的话不建议这样使用</p>
  </section>
  <footer class="entry-footer"><span title='2021-02-23 12:40:37 +0000 UTC'>February 23, 2021</span></footer>
  <a class="entry-link" aria-label="post link to 解决Python脚本在运行环境下依赖库缺失的问题" href="https://dynais.github.io/posts/%E8%A7%A3%E5%86%B3python%E8%84%9A%E6%9C%AC%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BE%9D%E8%B5%96%E5%BA%93%E7%BC%BA%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>线性回归模型分析
    </h2>
  </header>
  <section class="entry-content">
    <p>线性回归是回归问题中的一种，线性回归假设目标值与特征之间线性相关，即满足一个多元一次方程。通过构建损失函数，来求解损失函数最小时的参数 $w$ 和$b$。通常我们可以表达成如下公式： $$ \hat{y} = wX &#43; b $$ $\hat{y}$ 为预测值，自变量 $x$ 和因变量 $y$ 是已知的，而我们想实现的是预测新增一个 $x$ ，其对应的 $y$ 是多少。因此，为了构建这个函数关系，目标是通过已知数据点，求解线性模型中 $w$ 和 $b$ 两个参数。
1.线性回归概述  线性回归是回归问题中的一种，线性回归假设目标值与特征之间线性相关，即满足一个多元一次方程。通过构建损失函数，来求解损失函数最小时的参数 $w$ 和$b$。通常我们可以表达成如下公式：
$$ \begin{equation}
\hat{y} = wX &#43; b \tag{1}
\end{equation} $$
$\hat{y}$ 为预测值，自变量 $x$ 和因变量 $y$ 是已知的，而我们想实现的是预测新增一个 $x$ ，其对应的 $y$ 是多少。因此，为了构建这个函数关系，目标是通过已知数据点，求解线性模型中 $w$ 和 $b$ 两个参数。
为此, 线性回归分为两个部分, 向前传播和向后传播, 向前传播负责验证当前参数下对数据的拟合程度, 而向后传播通过在向前传播内得到的数据对参数进行优化
...</p>
  </section>
  <footer class="entry-footer"><span title='2021-02-21 00:00:00 +0000 UTC'>February 21, 2021</span></footer>
  <a class="entry-link" aria-label="post link to 线性回归模型分析" href="https://dynais.github.io/posts/nt-ml-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>PSpice中常用的Cursor查询命令
    </h2>
  </header>
  <section class="entry-content">
    <p>受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了
Orcad Pspice版本: 9.1 Student
概述  受够了在 Probe 窗口中用鼠标拖 Cursor 来找结果数据了, 所以想找一下 Probe 的 SerchCommand 结果连官方用户指导里都找不到, 好不容易才在帮助文档里找到了, 写文档的真不是人, 记录一下防止以后忘了
Orcad Pspice版本: 9.1 Student
文档进入方法:
{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161535.png 100% 100% &#34; &#34; %}
Win10还要上网找一下win32hlp.exe装一下才能看, 下载: win32hlp.exe
路径:
{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217161557.png 50% 50% &#34; &#34; %}
语法  search	[direction]	[/start_point/]	[#consecutive_points#]	[(range_x [,range_y])]	[for]	[repeat:]	&lt;condition&gt;...</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-17 00:00:00 +0000 UTC'>December 17, 2020</span></footer>
  <a class="entry-link" aria-label="post link to PSpice中常用的Cursor查询命令" href="https://dynais.github.io/posts/nt-psp-probe%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84cursor%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>PSpice模拟数据导入Excel工作流
    </h2>
  </header>
  <section class="entry-content">
    <p>基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析
概述  基本思想是先保存到 csv 逗号分隔符文件再导入 Excel 里分析
流程  在 PSpice 得到模拟数据后, 选中需要导出的曲线
{% image fancybox center clear group:default https://dynais-imh-hub.oss-cn-hangzhou.aliyuncs.com/img/20201217162110.png 50% 50% &#34; &#34; %}
看到它变红了
然后直接 Ctrl &#43; C 就可以获得曲线数据
然后新建一个文本文档, 复制粘贴保存成 .csv 文件
直接导入 Excel 应该也是可行的, 但是由于改成了德国的计数方法, 这里的逗号和小数点会有问题, 先导入 csv 文件的话就没问题, 所以还是建议保存到 csv, 这样 Matlab 什么的也能用</p>
  </section>
  <footer class="entry-footer"><span title='2020-12-17 00:00:00 +0000 UTC'>December 17, 2020</span></footer>
  <a class="entry-link" aria-label="post link to PSpice模拟数据导入Excel工作流" href="https://dynais.github.io/posts/nt-psp-pspice%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5excel%E5%B7%A5%E4%BD%9C%E6%B5%81/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>使用差分散列的重复图片检测
    </h2>
  </header>
  <section class="entry-content">
    <p>关于散列(Hash), 网上的介绍有很多,这里就不费力介绍.
而对于这个具体的项目要求来说, 我们所做的只是需要把一个图像转换为一个Hash值, 然后储存到字典中. 并且有一下要求:
 视觉上相差不大的图片, 他们的Hash值也应该相同 这个Hash计算需要快, 因为有时候数据量会很大  那么我们有以下几个Hash函数的选择:
 差分散列(difference hashing) md5 sha-1  最终我们选择了差分散列的方法, 有以下的原因:
 差分散列速度很快, 计算量小 对于肉眼相差不大的图片, 差分散列可以得出相似的值 md5 和 sha-1 只要有一点变化, 输出值就会完全改变(这本来很好, 但在这里非常不好!)  Detect and remove duplicate images from a dataset for deep learning  文章链接:
https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/
https://www.pyimagesearch.com/2020/04/20/detect-and-remove-duplicate-images-from-a-dataset-for-deep-learning/?__s=bnfo5g8qgjr6gztmvjlb
  前言:
为什么要删去数据集中重复的图片?
Having duplicate images in your dataset creates a problem for two reasons:
 It introduces bias into your dataset, giving your deep neural network additional opportunities to learn patterns specific to the duplicates It hurts the ability of your model to generalize to new images outside of what it was trained on  Take the time to remove duplicates from your image dataset so you don’t accidentally introduce bias or hurt the ability of your model to generalize....</p>
  </section>
  <footer class="entry-footer"><span title='2020-04-22 00:00:00 +0000 UTC'>April 22, 2020</span></footer>
  <a class="entry-link" aria-label="post link to 使用差分散列的重复图片检测" href="https://dynais.github.io/posts/nt-ocpy-%E4%BD%BF%E7%94%A8%E5%B7%AE%E5%88%86%E6%95%A3%E5%88%97%E6%A3%80%E6%B5%8B%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV学习笔记12-模板匹配
    </h2>
  </header>
  <section class="entry-content">
    <p>API matchTemplate();//模式查找,API比较简单 minMaxLoc();//用于在模式查找的输出图像中找到极值点,也就是匹配点 笔记   模板匹配(Templet Match)
相当于上一节说的直方图匹配的实用化,通过现有图像在目标图像上滑行(原文Slide),也就是左到右上到下的以像素为单位进行匹配,找到匹配值最大的点.但也是因为这个原因,对模板图像和在目标图像里的目标的大小进行匹配就非常重要,如果大小差得远,效果就不好,所以使用条件相当苛刻.
  注意输出图像的大小
在API中需要提供一个储存输出结果的Mat, 他的大小是
Size(src.cols-templ.cols&#43;1, src.rows-templ.rows&#43;1)     OpenCV的查找模式
OpenCV提供了很多种方法,在官网上都有介绍,大部分都是取用了最大值作为最匹配
根据最小值匹配的只有 TM_SQDIFF 和 MT_SQDIFF_NORMED
For the first two methods ( TM_SQDIFF and MT_SQDIFF_NORMED ) the best match are the lowest values.
  OpenCV中32位的图像
每个数值是一个位于[0,1]间的小数,相当于8位的[0,255]
   源//API实现模式查找 // OpenCV_Template.cpp : 此文件包含 &#34;main&#34; 函数。程序执行将在此处开始并结束。 //  #include &lt;iostream&gt;#include&lt;opencv2\opencv.hpp&gt; using namespace std; using namespace cv;  Mat src, dst, temp;  int main(int, char**) { 	temp = imread(&#34;D:/WorkSpace/Projects/OpenCV Learning/ImageHub/Lena....</p>
  </section>
  <footer class="entry-footer"><span title='2020-02-20 00:00:00 +0000 UTC'>February 20, 2020</span></footer>
  <a class="entry-link" aria-label="post link to OpenCV学习笔记12-模板匹配" href="https://dynais.github.io/posts/nt-oc-a12_%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV学习笔记11-直方图均衡化-直方图比较-反向投影
    </h2>
  </header>
  <section class="entry-content">
    <p>API - equalizeHist();//直方图均衡化 - split();//分离通道 - calcHist();//参数dims,bin,range - waitkey();  - mixChannels//分离通道, 与split小有差别,建议看官方文档 - cvtColer//使用此api转换到hsv色彩空间 - calcHist//接受单通道图像计算直方图, 参数略微复杂 - normalize//归一化,常用 - compareHist//比较直方图,可以得到两张图片的相似程度,但是对光非常敏感 - backProject();//直方图反向投影 笔记 这里是几个关于直方图的总结, 这一堆实在是不太好懂, 并且映射和统计接触到了很多数学方面的东西,重要的是理解思路以及了解API, 这里的东西要是有不理解的都建议去看官方的教程文档
 直方图均衡化  好像在人脸识别的项目总结里写过了, API并不难理解
 HSV模型  HSV是一种比较直观的颜色模型，所以在许多图像编辑工具中应用比较广泛，这个模型中颜色的参数分别是：色调（H, Hue），饱和度（S,Saturation），明度（V, Value）
 直方图比较  compareHist(); API比较方便,输入两个直方图,比较他们的相似程度
这两个直方图通常会是图像的HS直方图(虽然我现在还不太懂HS为什么可以变成一张直方图,到时候要用再看原理好了),用HS猜测是要降低算法对光线的敏感度?(实测好像对光线还是很敏感)
OpenCV提供了一共四种方法
 相关性计算:{-1, 1} //1最强 卡方计算:{0, ∞} //0最强 十字交叉 巴氏距离计算:{0, 1} //0最强  其中比较推荐的是相关性计算和巴氏距离计算(不需要归一化了hhhhhhhhh)
数学公式不列出了(反正我又不会去看)
 直方图反向投影  mixChannels(); backProject(); 直方图反向投影是一种基于色彩的对象识别技术,通过该方法可以定位图像中已知物体的位置,反应直方图在目标图像中的分布
主要思路是提取已知图像的Hue(色相)空间,做出直方图,再反向找到这些色相在目标图片中的分布,已知图像中越多的色相,在backProject中就会(看起来)更亮,利用这点加上一些二值化,就可以得到一张目标物体的掩膜,覆盖到目标图片上就可以得到完成的图像了,如下
 源//读取TIM图标, 在桌面截图上找到他 // OpenCV_Template....</p>
  </section>
  <footer class="entry-footer"><span title='2020-02-19 00:00:00 +0000 UTC'>February 19, 2020</span></footer>
  <a class="entry-link" aria-label="post link to OpenCV学习笔记11-直方图均衡化-直方图比较-反向投影" href="https://dynais.github.io/posts/nt-oc-a11_%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96_%E6%AF%94%E8%BE%83_%E5%8F%8D%E5%90%91%E6%8A%95%E5%BD%B1/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV学习笔记10-霍夫线和圆检测
    </h2>
  </header>
  <section class="entry-content">
    <p>API /*霍夫线检测 输入图像要先Canny过 参数为 - 输入图像 - 输出向量数组,数据类型为Vec4i(就是两个点) - 默认1 - 默认CV_PI / 180, 转角步长 - 阈值(我设了100) - 最小线长 - 最大间隙, 小于这个值的两条线会连成一条, 对于断断续续的线效果好 */ void HoughLinesP( InputArray image, OutputArray lines,  double rho, double theta, int threshold,  double minLineLength = 0, double maxLineGap = 0 );   /*霍夫圆检测 参数从前往后分别是 - 输入图像矩阵(8bit的灰度图,这个API自带Canny边缘检测) - 输出向量数组,数据类型位Vec3f - HOUGH_GRADIENT - 图像缩放,默认1 - 圆心最小距离, 小于会认为是同心圆? - Canny检测的大阈值,小的=大的除二计算 - 点重叠n个以上判定为圆,越小检出越多圆 - 最小圆半径 - 最大圆半径 */ void HoughCircles( InputArray image, OutputArray circles,  int method, double dp, double minDist,  double param1 = 100, double param2 = 100,  int minRadius = 0, int maxRadius = 0 ); 笔记  圆检测对噪声敏感, 需要先中值滤波 太难了,建议看下面的博客,线检测还好,圆检测真的看不懂  相关 源//检出NXP赛道上的几何图 // OpenCV_Template....</p>
  </section>
  <footer class="entry-footer"><span title='2020-02-16 22:00:00 +0000 UTC'>February 16, 2020</span></footer>
  <a class="entry-link" aria-label="post link to OpenCV学习笔记10-霍夫线和圆检测" href="https://dynais.github.io/posts/nt-oc-a10_%E9%9C%8D%E5%A4%AB%E7%BA%BF%E5%92%8C%E5%9C%86%E6%A3%80%E6%B5%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV学习笔记09-Canny边缘检测算法
    </h2>
  </header>
  <section class="entry-content">
    <p>API Canny();	//Canny的API, 包含了4个步骤. 注意, 不包含高斯模糊部分 笔记   Canny边缘检测算法可以分为以下5个步骤：
  使用高斯滤波器，以平滑图像，滤除噪声。(需要调用高斯模糊API)
  计算图像中每个像素点的梯度强度和方向。
  应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。
  应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。
  通过抑制孤立的弱边缘最终完成边缘检测。
    非极大值抑制:
  细化边缘, 但技术的实现细节并不是很懂, 大致思想是取邻域中的梯度极大值点来进行有效边缘的判断, 下面的文章讲的很详细, 可以看看.
 关于几种边缘检测方法:  Laplance, Canny 和 Sobel 都是边缘检测的方法, Canny是包含了Sobel算子的边缘检测, 所以可以说是Sobel的实际应用, Laplance的检测效果并不好, 但是有其他的用途, 总的来说Canny能应对大多数的场景
参考来源   《A Computational Approach to Edge Detection》
   源//对NXP赛道进行下采样和边缘检测 // OpenCV_Template.cpp : 此文件包含 &#34;main&#34; 函数。程序执行将在此处开始并结束。 //  #include &lt;iostream&gt;#include &lt;string&gt;#include&lt;opencv2\opencv....</p>
  </section>
  <footer class="entry-footer"><span title='2020-02-16 20:00:00 +0000 UTC'>February 16, 2020</span></footer>
  <a class="entry-link" aria-label="post link to OpenCV学习笔记09-Canny边缘检测算法" href="https://dynais.github.io/posts/nt-oc-a09_canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>OpenCV学习笔记08-Sobel算子
    </h2>
  </header>
  <section class="entry-content">
    <p>相关API Sobel();//索贝尔算子 Scharr();//Sobel的加强 笔记   Sobel: 边缘检测算法及各自的优缺点
Sobel是离散的一阶微分算子,可以用来计算图像的梯度(一阶), 常用于得到图像的边缘特征, 除了Sobel之外还有其他的算子, Sobel的优势是速度比较快, 但是在准确度上有欠缺
  使用加减来简化计算机的负担: sobel算子的原理与实现
乘除对计算机很费力, 对计算机应该采用近似计算, 在Sobel求边缘的合成阶段使用到了这种思想
  整个流程:
高斯-&gt;转灰度-&gt;求梯度x与y-&gt;混合
  源 无 </p>
  </section>
  <footer class="entry-footer"><span title='2020-02-15 20:48:00 +0000 UTC'>February 15, 2020</span></footer>
  <a class="entry-link" aria-label="post link to OpenCV学习笔记08-Sobel算子" href="https://dynais.github.io/posts/nt-oc-a08_sobel%E7%AE%97%E5%AD%90/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://dynais.github.io/categories/%E7%AC%94%E8%AE%B0/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://dynais.github.io/">DynAis</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
